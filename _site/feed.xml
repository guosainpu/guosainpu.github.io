<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-01-30T14:19:39+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">一只草履虫</title><subtitle>Your Site Description
</subtitle><author><name>Your Name</name></author><entry><title type="html">时序逻辑芯片：时序门、寄存器、RAM、计数器</title><link href="http://localhost:4000/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E6%97%B6%E5%BA%8F%E9%97%A8-%E5%AF%84%E5%AD%98%E5%99%A8-RAM-%E8%AE%A1%E6%95%B0%E5%99%A8.html" rel="alternate" type="text/html" title="时序逻辑芯片：时序门、寄存器、RAM、计数器" /><published>2020-01-29T00:00:00+08:00</published><updated>2020-01-29T00:00:00+08:00</updated><id>http://localhost:4000/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87:%E6%97%B6%E5%BA%8F%E9%97%A8%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81RAM%E3%80%81%E8%AE%A1%E6%95%B0%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E6%97%B6%E5%BA%8F%E9%97%A8-%E5%AF%84%E5%AD%98%E5%99%A8-RAM-%E8%AE%A1%E6%95%B0%E5%99%A8.html">&lt;p&gt;上一篇我们实现了一系列组合逻辑芯片和CPU的运算大脑：ALU，但是组合逻辑芯片是一个实时系统，只要输入值改变了输出值也马上跟着改变，上一秒辛苦计算出来的值，下一秒就消失不见了，因此我们需要一个具备”记忆功能”的原件，用于存储数据。这就是我们本片要介绍的：时序逻辑芯片。&lt;/p&gt;

&lt;h3 id=&quot;带环电路时钟系统d触发器&quot;&gt;带环电路、时钟系统、D触发器&lt;/h3&gt;

&lt;p&gt;组合逻辑芯片之所以无法记住上一次计算的值，是因为电流信息的流向是单向的，它总是向前流动，导致我们无法两次踏入同一条河流。要解决这个问题也很简单，我们引一条导线让数据回流，形成一个环路即可。下图就是用OR门加上一路环路构成的一位存储器，但他的缺点是只能记忆一次1的输入，后续无论输入如何改变，输出总是为1。如果想要实现功能更强大的记忆芯片就需要更复杂的电路设计，但仍然是基于门的输出再重新作为输入的原理。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdrumxqvgj30l60740sl.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;提到”记忆”就不能不涉及到”时间”，计算机中的时间是基于震荡时钟系统的，震荡时钟提供连续的交变信号（高低电平）从而形成离散的时间周期。时钟周期是计算机系统中各元器件能整齐划一，协调同步的工作的基础，只有当时钟上升沿到来时，各时序芯片才会瞬间改变状态，其余时间保持状态锁定。如果把CPU、内存、输入输出设备比作乐团中各个乐器的乐手，那么时钟系统就是计算机乐团的乐队指挥。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeiyf35ixj313e02edft.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;在搭建hack的时候，我们一共用到了两个基本芯片（即不用自己实现的芯片），一个是上一篇用于搭建组合逻辑芯片系统的Nand，另外一个就是本片用于搭建时序逻辑芯片的DFF（data Flip-Flop：D触发器）。DFF的结构由SR锁存器派生而来。（如果对锁存器和DFF感兴趣，可以参考《编码的奥秘》Charles Petzold）。&lt;/p&gt;

&lt;p&gt;DFF包含1bit的输入和1bit的输出，另外DFF有一个时钟输入（图中的小三角代表时钟输入），DFF根据数据输入位和时钟输入位的输入实现了out(t)=in(t-1)，即DFF简单的将前一个时间周期的输入值作为当前时间周期的输出值。这是DFF具备记忆功能的表现，也是我们后续实现16bit寄存器，16K、64K、256K等RAM的基础。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbek01supqj30dq05kaa4.jpg&quot; width=&quot;250&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;1位寄存器和16位寄存器&quot;&gt;1位寄存器和16位寄存器&lt;/h3&gt;
&lt;p&gt;有了DFF的记忆功能，我们接下来先实现最简单1bit寄存器和16bit寄存器。1bit寄存器的接口包括：in输入管脚，负责传输输入数据；load管脚，load管脚是控制位，只有当load为1的时候，才会存储in的输入数据；out管脚输出当前存储的值。接口如下所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbec5aygpzj311i08y3yr.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;1bit芯片很好实现，主要是实现load位的控制功能即可，根据芯片描述可以把芯片设计为：load为1时选择输入in的数据，load为0时选择输入上一次寄存器保存的数据。这种选择功能正好是上一篇我们实现的Multiplexor芯片（后面在实现RAM的时候，Multiplexor在地址选择中的作用体现得更加明显）。1bit寄存器内部实现如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbece9ixdnj30gc0ceaa5.jpg&quot; width=&quot;400&quot; /&gt;&lt;/center&gt;

&lt;p&gt;然后我们用硬件描述语言（HDL）实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 1-bit register:
 * If load[t] == 1 then out[t+1] = in[t]
 *                 else out does not change (out[t+1] = out[t])
 */

CHIP Bit {
    IN in, load;
    OUT out;

    PARTS:
    Mux(a=outBack, b=in, sel=load, out=dffIn);
    DFF(in=dffIn, out=out, out=outBack);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有1bit寄存器，16bit寄存器可以看做是16个1bit寄存器的组合：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbecp634wwj30h80amdfw.jpg&quot; width=&quot;400&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：16bit寄存器&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16-bit register:
 * If load[t] == 1 then out[t+1] = in[t]
 * else out does not change
 */

CHIP Register {
    IN in[16], load;
    OUT out[16];

    PARTS:
    Mux(a=outBack0, b=in[0], sel=load, out=dffIn0);
    DFF(in=dffIn0, out=out[0], out=outBack0);

    Mux(a=outBack1, b=in[1], sel=load, out=dffIn1);
    DFF(in=dffIn1, out=out[1], out=outBack1);

    Mux(a=outBack2, b=in[2], sel=load, out=dffIn2);
    DFF(in=dffIn2, out=out[2], out=outBack2);

    Mux(a=outBack3, b=in[3], sel=load, out=dffIn3);
    DFF(in=dffIn3, out=out[3], out=outBack3);

    Mux(a=outBack4, b=in[4], sel=load, out=dffIn4);
    DFF(in=dffIn4, out=out[4], out=outBack4);

    Mux(a=outBack5, b=in[5], sel=load, out=dffIn5);
    DFF(in=dffIn5, out=out[5], out=outBack5);

    Mux(a=outBack6, b=in[6], sel=load, out=dffIn6);
    DFF(in=dffIn6, out=out[6], out=outBack6);

    Mux(a=outBack7, b=in[7], sel=load, out=dffIn7);
    DFF(in=dffIn7, out=out[7], out=outBack7);

    Mux(a=outBack8, b=in[8], sel=load, out=dffIn8);
    DFF(in=dffIn8, out=out[8], out=outBack8);

    Mux(a=outBack9, b=in[9], sel=load, out=dffIn9);
    DFF(in=dffIn9, out=out[9], out=outBack9);

    Mux(a=outBack10, b=in[10], sel=load, out=dffIn10);
    DFF(in=dffIn10, out=out[10], out=outBack10);

    Mux(a=outBack11, b=in[11], sel=load, out=dffIn11);
    DFF(in=dffIn11, out=out[11], out=outBack11);

    Mux(a=outBack12, b=in[12], sel=load, out=dffIn12);
    DFF(in=dffIn12, out=out[12], out=outBack12);

    Mux(a=outBack13, b=in[13], sel=load, out=dffIn13);
    DFF(in=dffIn13, out=out[13], out=outBack13);

    Mux(a=outBack14, b=in[14], sel=load, out=dffIn14);
    DFF(in=dffIn14, out=out[14], out=outBack14);

    Mux(a=outBack15, b=in[15], sel=load, out=dffIn15);
    DFF(in=dffIn15, out=out[15], out=outBack15);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ram&quot;&gt;RAM&lt;/h3&gt;
&lt;p&gt;接着我们来实现计算机中另一个非常重要的组成部分：RAM。刚才看到，16bit寄存器可以由16个1bit的寄存器组合而成，同理一个mKB的RAM，可以由n个16位寄存器组合而成，16位寄存器就是RAM中的基本存储单元，寄存器的宽度（此处是16位）就是RAM”字”（WORD）的宽度。我们都知道，需要通过地址来访问RAM，RAM中每个寄存器都绑定到一个唯一地址。下图是RAM的接口设计，RAM有三种输入：数据输入，地址输入和加载位。地址指定了当前周期RAM中哪一个寄存器被访问，当进行读操作时（load=0），RAM的输出立即数输出被选中的寄存器的值，当进行写操作时（load=1），被选中的寄存器在下一个周期被赋予新的值，从此RAM将开始发出新的值。输入和输出的数据宽度就是RAM”字”的宽度。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbedozihymj30ki0lsjro.jpg&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;

&lt;p&gt;接下来我们要实现RAM8，RAM64，RAM512，RAM4K，RAM16K几种内存容量的RAM。RAMn中的n即代表RAM中有n个寄存器。例如RAM16K中有16K个16位寄存器，那么他的内存容量就是16K*(16/2)byte=32Kbyte。想要实现一个RAMn芯片，我们需要在RAMn芯片中集成n个寄存器，外加一些列控制逻辑（处理load）和地址选择逻辑，那么涉及到选择逻辑自然少不了Multiplexor和DMultiplexor。那么下面我们以RAM8为例讲一下我自己的实现方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;RAM8中有8个寄存器&lt;/li&gt;
  &lt;li&gt;8个寄存器有8个地址，所以我们的地址位需要2^n=8, n=3位&lt;/li&gt;
  &lt;li&gt;DMux用于解析写入时的地址，用3位sel分离出需要写入的那一路，再和load做与操作后作为寄存器的load位输入，最终通过load位来决定哪一个寄存器被写入In。&lt;/li&gt;
  &lt;li&gt;Mux用于解析读取时的地址，用3位sel在8个寄存器中选择想要读取的那一路数据&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbef8oh05tj31ca0qywfd.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：RAM8&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 8 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel=address, a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    Register(in=in, load=load0, out=R0);
    Register(in=in, load=load1, out=R1);
    Register(in=in, load=load2, out=R2);
    Register(in=in, load=load3, out=R3);
    Register(in=in, load=load4, out=R4);
    Register(in=in, load=load5, out=R5);
    Register(in=in, load=load6, out=R6);
    Register(in=in, load=load7, out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel=address, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了RAM8，我们就可以利用8个RAM8的组合实现RAM64，以此类推实现后面容量更大的RAM。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实现RAM64的技巧是对地址位的拆分，RAM64需要6个地址位，把6个地址为拆分为3+3&lt;/li&gt;
  &lt;li&gt;和实现RAM8的时候类似，需要引入一组Mux和DMux，这组选择芯片使用6位地址中的高三位，通过高3位把地址初步划分为8个地址段，每个地址段的容量即RAM8中寄存器的数量&lt;/li&gt;
  &lt;li&gt;每个RAM8使用6位地址中的低三位，然后从中定位到目标地址寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeg2r9r8oj30wu0loaab.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：RAM64&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 64 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM64 {
    IN in[16], load, address[6];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    RAM8(in=in, load=load0, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R0);
    RAM8(in=in, load=load1, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R1);
    RAM8(in=in, load=load2, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R2);
    RAM8(in=in, load=load3, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R3);
    RAM8(in=in, load=load4, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R4);
    RAM8(in=in, load=load5, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R5);
    RAM8(in=in, load=load6, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R6);
    RAM8(in=in, load=load7, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HDL实现：RAM4K&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 4K registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM4K {
    IN in[16], load, address[12];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel[0..2]=address[9..11], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    RAM512(in=in, load=load0, address[0..8]=address[0..8], out=R0);
    RAM512(in=in, load=load1, address[0..8]=address[0..8], out=R1);
    RAM512(in=in, load=load2, address[0..8]=address[0..8], out=R2);
    RAM512(in=in, load=load3, address[0..8]=address[0..8], out=R3);
    RAM512(in=in, load=load4, address[0..8]=address[0..8], out=R4);
    RAM512(in=in, load=load5, address[0..8]=address[0..8], out=R5);
    RAM512(in=in, load=load6, address[0..8]=address[0..8], out=R6);
    RAM512(in=in, load=load7, address[0..8]=address[0..8], out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0..2]=address[9..11], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;至此，我们了解了RAM中内存访问的方式。在RAM中的存储单元可以通过解析地址信号来进行随机的访问，而不会受限于存储单元的位置，访问任何位置的存储单元的速度都是相等的，例如访问内存中一个数组中任意下标的数据的速度都是相等的。这也是Random Access Memory概念的由来。&lt;/p&gt;

&lt;h3 id=&quot;计数器&quot;&gt;计数器&lt;/h3&gt;
&lt;p&gt;计数器也是CPU中一个重要的原件，主要用来存储将要执行指令的内存地址。在大多数情况下，计数器每个周期简单的进行+1操作，这时计算机能够获取下一条地址，这和CPU顺序执行指令的模式相符，同时CPU也支持直接跳转到编号为n的指令去执行，因此计数器要支持将其值设置为n的能力。下面我们来看一下计数器的接口设计：计数器芯片有2个附加控制位reset和inc，当inc=1时，计数器在每个时钟周期自加1，其输出值为out(t)=out(t-1)+1；如果想要将计数器置为0，就将reset置为1。如果想要将计数器设置为某个值，则将load置为1，并将数值从in输入。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeis1709vj30l007it8p.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;下图是我对计数器的实现逻辑&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reset，inc，load用一个Or8way输出，只要其中有一个为1，那么register的load为就为1，register的值会被更新&lt;/li&gt;
  &lt;li&gt;3个Mux串联用于选择自增1、in的输入值、重置0这三种操作&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbejy994vbj317g0ra3z0.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：计数器&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * A 16-bit counter with load and reset control bits.
 * if      (reset[t] == 1) out[t+1] = 0
 * else if (load[t] == 1)  out[t+1] = in[t]
 * else if (inc[t] == 1)   out[t+1] = out[t] + 1  (integer addition)
 * else                    out[t+1] = out[t]
 */

CHIP PC {
    IN in[16],load,inc,reset;
    OUT out[16];

    PARTS:
    Or8Way(in[0]=inc, in[1]=reset, in[2]=load, in[3..7]=false, out=ReLoad);

    Mux16(a=outBack, b=outPlus, sel=inc, out=loadIN);
    Mux16(a=loadIN, b=in, sel=load, out=resetIN);
    Mux16(a=resetIN, b=false, sel=reset, out=ReIn);

    Register(in=ReIn, load=ReLoad, out=out, out=outBack);
    Inc16(in=outBack, out=outPlus);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们以下图为例，看一下计数器是如何在时钟系统下变化数值的。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdrw718d4j31be0hiaat.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;至此，我们实现了hack CPU所需的所有芯片。组合逻辑芯片主要负责算数运算、逻辑运算、选择逻辑，并且通过适当的组合可以用来实现指令解析和某些功能控制；时序芯片主要负责存储数据。下一篇我们会用这些芯片搭建一个简单但使用的CPU。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><summary type="html">上一篇我们实现了一系列组合逻辑芯片和CPU的运算大脑：ALU，但是组合逻辑芯片是一个实时系统，只要输入值改变了输出值也马上跟着改变，上一秒辛苦计算出来的值，下一秒就消失不见了，因此我们需要一个具备”记忆功能”的原件，用于存储数据。这就是我们本片要介绍的：时序逻辑芯片。 带环电路、时钟系统、D触发器 组合逻辑芯片之所以无法记住上一次计算的值，是因为电流信息的流向是单向的，它总是向前流动，导致我们无法两次踏入同一条河流。要解决这个问题也很简单，我们引一条导线让数据回流，形成一个环路即可。下图就是用OR门加上一路环路构成的一位存储器，但他的缺点是只能记忆一次1的输入，后续无论输入如何改变，输出总是为1。如果想要实现功能更强大的记忆芯片就需要更复杂的电路设计，但仍然是基于门的输出再重新作为输入的原理。 提到”记忆”就不能不涉及到”时间”，计算机中的时间是基于震荡时钟系统的，震荡时钟提供连续的交变信号（高低电平）从而形成离散的时间周期。时钟周期是计算机系统中各元器件能整齐划一，协调同步的工作的基础，只有当时钟上升沿到来时，各时序芯片才会瞬间改变状态，其余时间保持状态锁定。如果把CPU、内存、输入输出设备比作乐团中各个乐器的乐手，那么时钟系统就是计算机乐团的乐队指挥。 在搭建hack的时候，我们一共用到了两个基本芯片（即不用自己实现的芯片），一个是上一篇用于搭建组合逻辑芯片系统的Nand，另外一个就是本片用于搭建时序逻辑芯片的DFF（data Flip-Flop：D触发器）。DFF的结构由SR锁存器派生而来。（如果对锁存器和DFF感兴趣，可以参考《编码的奥秘》Charles Petzold）。 DFF包含1bit的输入和1bit的输出，另外DFF有一个时钟输入（图中的小三角代表时钟输入），DFF根据数据输入位和时钟输入位的输入实现了out(t)=in(t-1)，即DFF简单的将前一个时间周期的输入值作为当前时间周期的输出值。这是DFF具备记忆功能的表现，也是我们后续实现16bit寄存器，16K、64K、256K等RAM的基础。 1位寄存器和16位寄存器 有了DFF的记忆功能，我们接下来先实现最简单1bit寄存器和16bit寄存器。1bit寄存器的接口包括：in输入管脚，负责传输输入数据；load管脚，load管脚是控制位，只有当load为1的时候，才会存储in的输入数据；out管脚输出当前存储的值。接口如下所示： 1bit芯片很好实现，主要是实现load位的控制功能即可，根据芯片描述可以把芯片设计为：load为1时选择输入in的数据，load为0时选择输入上一次寄存器保存的数据。这种选择功能正好是上一篇我们实现的Multiplexor芯片（后面在实现RAM的时候，Multiplexor在地址选择中的作用体现得更加明显）。1bit寄存器内部实现如下： 然后我们用硬件描述语言（HDL）实现： /** * 1-bit register: * If load[t] == 1 then out[t+1] = in[t] * else out does not change (out[t+1] = out[t]) */ CHIP Bit { IN in, load; OUT out; PARTS: Mux(a=outBack, b=in, sel=load, out=dffIn); DFF(in=dffIn, out=out, out=outBack); } 有1bit寄存器，16bit寄存器可以看做是16个1bit寄存器的组合： HDL实现：16bit寄存器 /** * 16-bit register: * If load[t] == 1 then out[t+1] = in[t] * else out does not change */ CHIP Register { IN in[16], load; OUT out[16]; PARTS: Mux(a=outBack0, b=in[0], sel=load, out=dffIn0); DFF(in=dffIn0, out=out[0], out=outBack0); Mux(a=outBack1, b=in[1], sel=load, out=dffIn1); DFF(in=dffIn1, out=out[1], out=outBack1); Mux(a=outBack2, b=in[2], sel=load, out=dffIn2); DFF(in=dffIn2, out=out[2], out=outBack2); Mux(a=outBack3, b=in[3], sel=load, out=dffIn3); DFF(in=dffIn3, out=out[3], out=outBack3); Mux(a=outBack4, b=in[4], sel=load, out=dffIn4); DFF(in=dffIn4, out=out[4], out=outBack4); Mux(a=outBack5, b=in[5], sel=load, out=dffIn5); DFF(in=dffIn5, out=out[5], out=outBack5); Mux(a=outBack6, b=in[6], sel=load, out=dffIn6); DFF(in=dffIn6, out=out[6], out=outBack6); Mux(a=outBack7, b=in[7], sel=load, out=dffIn7); DFF(in=dffIn7, out=out[7], out=outBack7); Mux(a=outBack8, b=in[8], sel=load, out=dffIn8); DFF(in=dffIn8, out=out[8], out=outBack8); Mux(a=outBack9, b=in[9], sel=load, out=dffIn9); DFF(in=dffIn9, out=out[9], out=outBack9); Mux(a=outBack10, b=in[10], sel=load, out=dffIn10); DFF(in=dffIn10, out=out[10], out=outBack10); Mux(a=outBack11, b=in[11], sel=load, out=dffIn11); DFF(in=dffIn11, out=out[11], out=outBack11); Mux(a=outBack12, b=in[12], sel=load, out=dffIn12); DFF(in=dffIn12, out=out[12], out=outBack12); Mux(a=outBack13, b=in[13], sel=load, out=dffIn13); DFF(in=dffIn13, out=out[13], out=outBack13); Mux(a=outBack14, b=in[14], sel=load, out=dffIn14); DFF(in=dffIn14, out=out[14], out=outBack14); Mux(a=outBack15, b=in[15], sel=load, out=dffIn15); DFF(in=dffIn15, out=out[15], out=outBack15); } RAM 接着我们来实现计算机中另一个非常重要的组成部分：RAM。刚才看到，16bit寄存器可以由16个1bit的寄存器组合而成，同理一个mKB的RAM，可以由n个16位寄存器组合而成，16位寄存器就是RAM中的基本存储单元，寄存器的宽度（此处是16位）就是RAM”字”（WORD）的宽度。我们都知道，需要通过地址来访问RAM，RAM中每个寄存器都绑定到一个唯一地址。下图是RAM的接口设计，RAM有三种输入：数据输入，地址输入和加载位。地址指定了当前周期RAM中哪一个寄存器被访问，当进行读操作时（load=0），RAM的输出立即数输出被选中的寄存器的值，当进行写操作时（load=1），被选中的寄存器在下一个周期被赋予新的值，从此RAM将开始发出新的值。输入和输出的数据宽度就是RAM”字”的宽度。 接下来我们要实现RAM8，RAM64，RAM512，RAM4K，RAM16K几种内存容量的RAM。RAMn中的n即代表RAM中有n个寄存器。例如RAM16K中有16K个16位寄存器，那么他的内存容量就是16K*(16/2)byte=32Kbyte。想要实现一个RAMn芯片，我们需要在RAMn芯片中集成n个寄存器，外加一些列控制逻辑（处理load）和地址选择逻辑，那么涉及到选择逻辑自然少不了Multiplexor和DMultiplexor。那么下面我们以RAM8为例讲一下我自己的实现方式： RAM8中有8个寄存器 8个寄存器有8个地址，所以我们的地址位需要2^n=8, n=3位 DMux用于解析写入时的地址，用3位sel分离出需要写入的那一路，再和load做与操作后作为寄存器的load位输入，最终通过load位来决定哪一个寄存器被写入In。 Mux用于解析读取时的地址，用3位sel在8个寄存器中选择想要读取的那一路数据 HDL实现：RAM8 /** * Memory of 8 registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM8 { IN in[16], load, address[3]; OUT out[16]; PARTS: DMux8Way(in=true, sel=address, a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); Register(in=in, load=load0, out=R0); Register(in=in, load=load1, out=R1); Register(in=in, load=load2, out=R2); Register(in=in, load=load3, out=R3); Register(in=in, load=load4, out=R4); Register(in=in, load=load5, out=R5); Register(in=in, load=load6, out=R6); Register(in=in, load=load7, out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel=address, out=out); } 有了RAM8，我们就可以利用8个RAM8的组合实现RAM64，以此类推实现后面容量更大的RAM。 实现RAM64的技巧是对地址位的拆分，RAM64需要6个地址位，把6个地址为拆分为3+3 和实现RAM8的时候类似，需要引入一组Mux和DMux，这组选择芯片使用6位地址中的高三位，通过高3位把地址初步划分为8个地址段，每个地址段的容量即RAM8中寄存器的数量 每个RAM8使用6位地址中的低三位，然后从中定位到目标地址寄存器 HDL实现：RAM64 /** * Memory of 64 registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM64 { IN in[16], load, address[6]; OUT out[16]; PARTS: DMux8Way(in=true, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); RAM8(in=in, load=load0, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R0); RAM8(in=in, load=load1, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R1); RAM8(in=in, load=load2, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R2); RAM8(in=in, load=load3, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R3); RAM8(in=in, load=load4, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R4); RAM8(in=in, load=load5, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R5); RAM8(in=in, load=load6, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R6); RAM8(in=in, load=load7, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], out=out); } HDL实现：RAM4K /** * Memory of 4K registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM4K { IN in[16], load, address[12]; OUT out[16]; PARTS: DMux8Way(in=true, sel[0..2]=address[9..11], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); RAM512(in=in, load=load0, address[0..8]=address[0..8], out=R0); RAM512(in=in, load=load1, address[0..8]=address[0..8], out=R1); RAM512(in=in, load=load2, address[0..8]=address[0..8], out=R2); RAM512(in=in, load=load3, address[0..8]=address[0..8], out=R3); RAM512(in=in, load=load4, address[0..8]=address[0..8], out=R4); RAM512(in=in, load=load5, address[0..8]=address[0..8], out=R5); RAM512(in=in, load=load6, address[0..8]=address[0..8], out=R6); RAM512(in=in, load=load7, address[0..8]=address[0..8], out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0..2]=address[9..11], out=out); } 至此，我们了解了RAM中内存访问的方式。在RAM中的存储单元可以通过解析地址信号来进行随机的访问，而不会受限于存储单元的位置，访问任何位置的存储单元的速度都是相等的，例如访问内存中一个数组中任意下标的数据的速度都是相等的。这也是Random Access Memory概念的由来。 计数器 计数器也是CPU中一个重要的原件，主要用来存储将要执行指令的内存地址。在大多数情况下，计数器每个周期简单的进行+1操作，这时计算机能够获取下一条地址，这和CPU顺序执行指令的模式相符，同时CPU也支持直接跳转到编号为n的指令去执行，因此计数器要支持将其值设置为n的能力。下面我们来看一下计数器的接口设计：计数器芯片有2个附加控制位reset和inc，当inc=1时，计数器在每个时钟周期自加1，其输出值为out(t)=out(t-1)+1；如果想要将计数器置为0，就将reset置为1。如果想要将计数器设置为某个值，则将load置为1，并将数值从in输入。 下图是我对计数器的实现逻辑 reset，inc，load用一个Or8way输出，只要其中有一个为1，那么register的load为就为1，register的值会被更新 3个Mux串联用于选择自增1、in的输入值、重置0这三种操作 HDL实现：计数器 /** * A 16-bit counter with load and reset control bits. * if (reset[t] == 1) out[t+1] = 0 * else if (load[t] == 1) out[t+1] = in[t] * else if (inc[t] == 1) out[t+1] = out[t] + 1 (integer addition) * else out[t+1] = out[t] */ CHIP PC { IN in[16],load,inc,reset; OUT out[16]; PARTS: Or8Way(in[0]=inc, in[1]=reset, in[2]=load, in[3..7]=false, out=ReLoad); Mux16(a=outBack, b=outPlus, sel=inc, out=loadIN); Mux16(a=loadIN, b=in, sel=load, out=resetIN); Mux16(a=resetIN, b=false, sel=reset, out=ReIn); Register(in=ReIn, load=ReLoad, out=out, out=outBack); Inc16(in=outBack, out=outPlus); } 我们以下图为例，看一下计数器是如何在时钟系统下变化数值的。 总结 至此，我们实现了hack CPU所需的所有芯片。组合逻辑芯片主要负责算数运算、逻辑运算、选择逻辑，并且通过适当的组合可以用来实现指令解析和某些功能控制；时序芯片主要负责存储数据。下一篇我们会用这些芯片搭建一个简单但使用的CPU。</summary></entry><entry><title type="html">组合逻辑芯片：逻辑门&amp;amp;加法器&amp;amp;ALU</title><link href="http://localhost:4000/2019/12/16/%E9%80%BB%E8%BE%91%E9%97%A8-&-%E5%8A%A0%E6%B3%95%E5%99%A8-&-ALU.html" rel="alternate" type="text/html" title="组合逻辑芯片：逻辑门&amp;加法器&amp;ALU" /><published>2019-12-16T00:00:00+08:00</published><updated>2019-12-16T00:00:00+08:00</updated><id>http://localhost:4000/2019/12/16/%E9%80%BB%E8%BE%91%E9%97%A8%20&amp;%20%E5%8A%A0%E6%B3%95%E5%99%A8%20&amp;%20ALU</id><content type="html" xml:base="http://localhost:4000/2019/12/16/%E9%80%BB%E8%BE%91%E9%97%A8-&amp;-%E5%8A%A0%E6%B3%95%E5%99%A8-&amp;-ALU.html">&lt;p&gt;上篇说到：通过使用Nand门，我们可以实现任何逻辑门，进而实现可以一个CPU。后面我们就会搭建一个麻雀虽小但五脏俱全的计算机平台：hack。本篇我们开始第一步，实现搭建hack所需的一组芯片：组合逻辑芯片&lt;/p&gt;

&lt;h3 id=&quot;组合逻辑芯片&quot;&gt;组合逻辑芯片&lt;/h3&gt;

&lt;p&gt;一个最基本的CPU主要由两类芯片组成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;组合逻辑芯片（Combinational Chips）：与、或、非门，加法器，ALU芯片等。这些芯片主要负责逻辑计算&lt;/li&gt;
  &lt;li&gt;时序芯片（Sequential Chips）：寄存器，计数器，RAM等。这些芯片主要负责暂存数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组合逻辑芯片（下面简称逻辑芯片）可以类比为一个布尔函数，它仅负责处理逻辑运算：输出结果仅依赖于其输入变量的排列组合。逻辑芯片是没有记忆能力的，它们不能维持自身的状态，当逻辑芯片的输入值改变的时候，它们的输出值也会实时地改变。&lt;/p&gt;

&lt;p&gt;hack所需要的逻辑芯片有以下四种：基本逻辑门、多通道逻辑门、加法器、ALU（算数逻辑单元）。&lt;/p&gt;

&lt;h3 id=&quot;基本逻辑门&quot;&gt;基本逻辑门&lt;/h3&gt;
&lt;p&gt;基本逻辑门是一些简单的布尔函数的实现，我们需要的基本逻辑门如下，有1位和多位（16位）之分。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1g9yzjn8lngj30qe0mgwew.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;我们所有组合逻辑芯片都是基于Nand实现的，下面是Nand的真值表：只有当两个输入都为1时输出为0，其余输出为1反，然后输出。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga16e7ws5tj30b007s3yd.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Nand真值表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;首先我们用Nand实现一个Not。Not很简单，对其输入取反，然后输出。下面是我自己的实现方式：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga21uf1wocj30s609e3yh.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Not电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：硬件描述语言实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Not HDL实现
 * Not gate:
 * out = not in
 */

CHIP Not {
    IN in;
    OUT out;

    PARTS:
    Nand(a=in, b=in, out=out); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们继续用刚刚实现的Not和Nand组合使用，再实现一个And。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga221fwwf3j310m08mgll.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;And电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * And gate: 
 * out = 1 if (a == 1 and b == 1)
 *       0 otherwise
 */

CHIP And {
    IN a, b;
    OUT out;

    PARTS:
    Nand(a=a, b=b, out=nandOut);
    Not(in=nandOut, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多位基本逻辑门是1位基本逻辑门的简单组合，以16位And为例，用16个1位And组合成16位And.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16-bit bitwise And:
 * for i = 0..15: out[i] = (a[i] and b[i])
 */

CHIP And16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    And(a=a[0], b=b[0], out=out[0]);
    And(a=a[1], b=b[1], out=out[1]);
    And(a=a[2], b=b[2], out=out[2]);
    And(a=a[3], b=b[3], out=out[3]);
    And(a=a[4], b=b[4], out=out[4]);
    And(a=a[5], b=b[5], out=out[5]);
    And(a=a[6], b=b[6], out=out[6]);
    And(a=a[7], b=b[7], out=out[7]);
    And(a=a[8], b=b[8], out=out[8]);
    And(a=a[9], b=b[9], out=out[9]);
    And(a=a[10], b=b[10], out=out[10]);
    And(a=a[11], b=b[11], out=out[11]);
    And(a=a[12], b=b[12], out=out[12]);
    And(a=a[13], b=b[13], out=out[13]);
    And(a=a[14], b=b[14], out=out[14]);
    And(a=a[15], b=b[15], out=out[15]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;以此类推，我们可以一步步实现其他所有基本逻辑门。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;加法器&quot;&gt;加法器&lt;/h3&gt;
&lt;p&gt;有了上面实现的这些基本逻辑门，我们就可以实现CPU中一个非常重要的基本芯片：加法器。实现加法器的顺序是：半加器-&amp;gt;全加器-&amp;gt;16位加法器&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cyn6tzgj30va0d8glt.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;第一步：实现一个半加器，半加器负责计算两个一位二进制相加，输出sum和carry（进位）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xb8b2xej30sc09m74d.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;半加器&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;虽然半加器看上去跳出了布尔运算，升级到的小学数学，但其仍然可以用真值表表示，所以也就可以用基本逻辑门实现，我们用一个Xor和And就可以实现半加器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2c9rhu5bj30sa0ge3yo.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;半加器电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 半加器
 * Computes the sum of two bits.
 */

CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b 
        carry;  // Left bit of a + b

    PARTS:
    Xor(a=a, b=b, out=sum);
    And(a=a, b=b, out=carry);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;半加器只能计算两个一位二进制数相加，接着我们在输入端再加入一个进位管脚（代表低位做加法时进过来的进位），就成为了一个全加器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xom01j9j30u80de0sv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;全加器&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cemdwywj318g0gu0t1.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;全加器电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 全加器
 * Computes the sum of three bits.
 */

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, carry=carryA, sum=sumA);
    HalfAdder(a=sumA, b=c, carry=carryB, sum=sum);
    Or(a=carryA, b=carryB, out=carry);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后我们利用全加器实现16位加法器，有了16位加法器，我们就可以进行2个不大于2^16的整数的加法了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xrljwy9j30te06sdfv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;16位加法器&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16位加法器
 * Adds two 16-bit values.
 * The most significant carry bit is ignored.
 */

CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=ca0);
    FullAdder(a=a[1], b=b[1], c=ca0, sum=out[1], carry=ca1);
    FullAdder(a=a[2], b=b[2], c=ca1, sum=out[2], carry=ca2);
    FullAdder(a=a[3], b=b[3], c=ca2, sum=out[3], carry=ca3);
    FullAdder(a=a[4], b=b[4], c=ca3, sum=out[4], carry=ca4);
    FullAdder(a=a[5], b=b[5], c=ca4, sum=out[5], carry=ca5);
    FullAdder(a=a[6], b=b[6], c=ca5, sum=out[6], carry=ca6);
    FullAdder(a=a[7], b=b[7], c=ca6, sum=out[7], carry=ca7);
    FullAdder(a=a[8], b=b[8], c=ca7, sum=out[8], carry=ca8);
    FullAdder(a=a[9], b=b[9], c=ca8, sum=out[9], carry=ca9);
    FullAdder(a=a[10], b=b[10], c=ca9, sum=out[10], carry=ca10);
    FullAdder(a=a[11], b=b[11], c=ca10, sum=out[11], carry=ca11);
    FullAdder(a=a[12], b=b[12], c=ca11, sum=out[12], carry=ca12);
    FullAdder(a=a[13], b=b[13], c=ca12, sum=out[13], carry=ca13);
    FullAdder(a=a[14], b=b[14], c=ca13, sum=out[14], carry=ca14);
    FullAdder(a=a[15], b=b[15], c=ca14, sum=out[15], carry=ignorCa); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了加法器，我们再实现一个累加器，它对输入数据进行加1，然后输出。累加器是后面CPU中程序计数器的重要部分。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 累加器
 * 16-bit incrementer:
 * out = in + 1 (arithmetic addition)
 */

CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Add16(a=in, b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=false, b[5]=false, b[6]=false, b[7]=false, b[8]=false, b[9]=false, b[10]=false, b[11]=false, b[12]=false, b[13]=false, b[14]=false, b[15]=false, out=out);
}     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;多通道逻辑门&quot;&gt;多通道逻辑门&lt;/h3&gt;
&lt;p&gt;我们看到基本逻辑门负责计算布尔运算，但其只能根据输入计算出输出，缺少控制能力。下面我们介绍的多通道逻辑门则在逻辑控制方面扮演了重要角色，因为多通道逻辑门具有&lt;strong&gt;选择功能&lt;/strong&gt;。多通道逻辑门在CPU和RAM中起到了重要作用。多通道逻辑门分为以下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Multiplexor:&lt;/strong&gt; 有多路输入，一路输出，选择输入中的一路作为输出&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DMultiplexor:&lt;/strong&gt; 有一路输入，多路输出，在输出路中选择一路降输入值输出&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cyl836uj30v60meaaw.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y8t42i3j30p60dq0sv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Multiplexor&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&amp;lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y9h0fixj30me08mjrd.jpg&quot; width=&quot;600&amp;gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;DMultiplexor&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;这里我们实现一个2路1位的Mux。a，b是两路1位信号输入，sel是选择位。如果sel == 0，out管脚输出a的值，否则输出b的值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1zhhi4a2j30rm0kuq36.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;2路1位Mux电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
 * 2路1位Mux
 * Multiplexor:
 * out = a if sel == 0
 *       b otherwise
 */

CHIP Mux {
    IN a, b, sel;
    OUT out;

    PARTS:
    Not(in= sel, out=NotSel);
    And(a=a, b=NotSel, out=AndAOut);
    And(a=b, b=sel, out=AndBOut);
    Or(a=AndAOut, b=AndBOut, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然除了2路选择器，还有4路、8路、16路等多路选择器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yd61q3mj30ze09at8v.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;多路Mux&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;下面是4路16位选择器的一种实现方式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 4-way 16-bit multiplexor:
 * out = a if sel == 00
 *       b if sel == 01
 *       c if sel == 10
 *       d if sel == 11
 */

CHIP Mux4Way16 {
    IN a[16], b[16], c[16], d[16], sel[2];
    OUT out[16];

    PARTS:
    Mux16(a=a, b=b, sel=sel[0], out=outA);
    Mux16(a=c, b=d, sel=sel[0], out=outB);
    Mux16(a=outA, b=outB, sel=sel[1], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;alu&quot;&gt;ALU&lt;/h3&gt;
&lt;p&gt;有了多通道逻辑门，我们就可以进一步实现一个更为复杂的芯片：ALU。ALU是CPU的三大基本模块之一（ALU、寄存器、程序计数器）。基本逻辑门只能计算一种布尔逻辑，而ALU可以通过改变控制位输入变量的组合（zx,nz,zy,ny,f,no），可以控制实现多种计算逻辑。这类似于一个CPU可以执行指令集中的众多指令一样（当然这其中就依赖于ALU）。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cylk4d8j30uo05i3yg.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yf3rz82j30pi0i0dg1.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;ALU&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yf94f4ej314x0u0jsn.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;ALU真值表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;下面我们就用上面实现的芯片来实现一下ALU（由于比较复杂，就先不画电路图了）。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * The ALU (Arithmetic Logic Unit).
 * Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&amp;amp;y, x|y on two 16-bit inputs, 
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * In addition, the ALU computes two 1-bit outputs:
 * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;
 * if the ALU output &amp;lt; 0, ng is set to 1; otherwise ng is set to 0.
 */

// Implementation: the ALU logic manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) set x = 0        // 16-bit constant
// if (nx == 1) set x = !x       // bitwise not
// if (zy == 1) set y = 0        // 16-bit constant
// if (ny == 1) set y = !y       // bitwise not
// if (f == 1)  set out = x + y  // integer 2's complement addition
// if (f == 0)  set out = x &amp;amp; y  // bitwise and
// if (no == 1) set out = !out   // bitwise not
// if (out == 0) set zr = 1
// if (out &amp;lt; 0) set ng = 1

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute out = x + y (if 1) or x &amp;amp; y (if 0)
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out &amp;lt; 0),  0 otherwise

    PARTS:
    Mux16(a=x, b=false, sel=zx, out=zSelX);
    Not16(in=zSelX, out=notZSelx);
    Mux16(a=zSelX, b=notZSelx, sel=nx, out=outX);

    Mux16(a=y, b=false, sel=zy, out=zSelY);
    Not16(in=zSelY, out=notZSelY);
    Mux16(a=zSelY, b=notZSelY, sel=ny, out=outY);

    Add16(a=outX, b=outY, out=outAdd); // X+Y
    And16(a=outX, b=outY, out=outAnd); // X&amp;amp;Y

    Mux16(a=outAnd, b=outAdd, sel=f, out=outF);
    Not16(in=outF, out=notF);

    Mux16(a=outF, b=notF, sel=no, out=out, out[0..7]=outZrA, out[8..15]=outZrB, out[15]=outMSB);

    Or8Way(in=outZrA, out=zrL);
    Or8Way(in=outZrB, out=zrH);
    Or(a=zrL, b=zrH, out=notZr);
    Not(in=notZr, out=zr);

    And(a=true, b=outMSB, out=ng);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;补码&quot;&gt;补码&lt;/h3&gt;
&lt;p&gt;最后我们再来谈一下补码，上面我们提到的加法器都没有考虑正负符号的问题，如果引入符号，那么电路会变得更加复杂。通过使用补码可以很好的规避这个问题，因为补码有一个很重要的特性：&lt;strong&gt;任何两个用补码表示的有符号数的加法和正数的加法完全相同&lt;/strong&gt;，例如用正数加法操作（-2）+（-3），所得的结果正好是（-5）的补码；补码的减法可以用加法来代替实现，例如x-y == x+(-y)。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><summary type="html">上篇说到：通过使用Nand门，我们可以实现任何逻辑门，进而实现可以一个CPU。后面我们就会搭建一个麻雀虽小但五脏俱全的计算机平台：hack。本篇我们开始第一步，实现搭建hack所需的一组芯片：组合逻辑芯片 组合逻辑芯片 一个最基本的CPU主要由两类芯片组成： 组合逻辑芯片（Combinational Chips）：与、或、非门，加法器，ALU芯片等。这些芯片主要负责逻辑计算 时序芯片（Sequential Chips）：寄存器，计数器，RAM等。这些芯片主要负责暂存数据 组合逻辑芯片（下面简称逻辑芯片）可以类比为一个布尔函数，它仅负责处理逻辑运算：输出结果仅依赖于其输入变量的排列组合。逻辑芯片是没有记忆能力的，它们不能维持自身的状态，当逻辑芯片的输入值改变的时候，它们的输出值也会实时地改变。 hack所需要的逻辑芯片有以下四种：基本逻辑门、多通道逻辑门、加法器、ALU（算数逻辑单元）。 基本逻辑门 基本逻辑门是一些简单的布尔函数的实现，我们需要的基本逻辑门如下，有1位和多位（16位）之分。 芯片列表 我们所有组合逻辑芯片都是基于Nand实现的，下面是Nand的真值表：只有当两个输入都为1时输出为0，其余输出为1反，然后输出。 Nand真值表 首先我们用Nand实现一个Not。Not很简单，对其输入取反，然后输出。下面是我自己的实现方式： Not电路图 HDL实现：硬件描述语言实现。 /** * Not HDL实现 * Not gate: * out = not in */ CHIP Not { IN in; OUT out; PARTS: Nand(a=in, b=in, out=out); } 然后我们继续用刚刚实现的Not和Nand组合使用，再实现一个And。 And电路图 /** * And gate: * out = 1 if (a == 1 and b == 1) * 0 otherwise */ CHIP And { IN a, b; OUT out; PARTS: Nand(a=a, b=b, out=nandOut); Not(in=nandOut, out=out); } 多位基本逻辑门是1位基本逻辑门的简单组合，以16位And为例，用16个1位And组合成16位And. /** * 16-bit bitwise And: * for i = 0..15: out[i] = (a[i] and b[i]) */ CHIP And16 { IN a[16], b[16]; OUT out[16]; PARTS: And(a=a[0], b=b[0], out=out[0]); And(a=a[1], b=b[1], out=out[1]); And(a=a[2], b=b[2], out=out[2]); And(a=a[3], b=b[3], out=out[3]); And(a=a[4], b=b[4], out=out[4]); And(a=a[5], b=b[5], out=out[5]); And(a=a[6], b=b[6], out=out[6]); And(a=a[7], b=b[7], out=out[7]); And(a=a[8], b=b[8], out=out[8]); And(a=a[9], b=b[9], out=out[9]); And(a=a[10], b=b[10], out=out[10]); And(a=a[11], b=b[11], out=out[11]); And(a=a[12], b=b[12], out=out[12]); And(a=a[13], b=b[13], out=out[13]); And(a=a[14], b=b[14], out=out[14]); And(a=a[15], b=b[15], out=out[15]); } 以此类推，我们可以一步步实现其他所有基本逻辑门。 加法器 有了上面实现的这些基本逻辑门，我们就可以实现CPU中一个非常重要的基本芯片：加法器。实现加法器的顺序是：半加器-&amp;gt;全加器-&amp;gt;16位加法器 芯片列表 第一步：实现一个半加器，半加器负责计算两个一位二进制相加，输出sum和carry（进位）。 半加器 虽然半加器看上去跳出了布尔运算，升级到的小学数学，但其仍然可以用真值表表示，所以也就可以用基本逻辑门实现，我们用一个Xor和And就可以实现半加器。 半加器电路图 /** * 半加器 * Computes the sum of two bits. */ CHIP HalfAdder { IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry); } 半加器只能计算两个一位二进制数相加，接着我们在输入端再加入一个进位管脚（代表低位做加法时进过来的进位），就成为了一个全加器。 全加器 全加器电路图 /** * 全加器 * Computes the sum of three bits. */ CHIP FullAdder { IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, carry=carryA, sum=sumA); HalfAdder(a=sumA, b=c, carry=carryB, sum=sum); Or(a=carryA, b=carryB, out=carry); } 最后我们利用全加器实现16位加法器，有了16位加法器，我们就可以进行2个不大于2^16的整数的加法了。 16位加法器 /** * 16位加法器 * Adds two 16-bit values. * The most significant carry bit is ignored. */ CHIP Add16 { IN a[16], b[16]; OUT out[16]; PARTS: FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=ca0); FullAdder(a=a[1], b=b[1], c=ca0, sum=out[1], carry=ca1); FullAdder(a=a[2], b=b[2], c=ca1, sum=out[2], carry=ca2); FullAdder(a=a[3], b=b[3], c=ca2, sum=out[3], carry=ca3); FullAdder(a=a[4], b=b[4], c=ca3, sum=out[4], carry=ca4); FullAdder(a=a[5], b=b[5], c=ca4, sum=out[5], carry=ca5); FullAdder(a=a[6], b=b[6], c=ca5, sum=out[6], carry=ca6); FullAdder(a=a[7], b=b[7], c=ca6, sum=out[7], carry=ca7); FullAdder(a=a[8], b=b[8], c=ca7, sum=out[8], carry=ca8); FullAdder(a=a[9], b=b[9], c=ca8, sum=out[9], carry=ca9); FullAdder(a=a[10], b=b[10], c=ca9, sum=out[10], carry=ca10); FullAdder(a=a[11], b=b[11], c=ca10, sum=out[11], carry=ca11); FullAdder(a=a[12], b=b[12], c=ca11, sum=out[12], carry=ca12); FullAdder(a=a[13], b=b[13], c=ca12, sum=out[13], carry=ca13); FullAdder(a=a[14], b=b[14], c=ca13, sum=out[14], carry=ca14); FullAdder(a=a[15], b=b[15], c=ca14, sum=out[15], carry=ignorCa); } 有了加法器，我们再实现一个累加器，它对输入数据进行加1，然后输出。累加器是后面CPU中程序计数器的重要部分。 /** * 累加器 * 16-bit incrementer: * out = in + 1 (arithmetic addition) */ CHIP Inc16 { IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=false, b[5]=false, b[6]=false, b[7]=false, b[8]=false, b[9]=false, b[10]=false, b[11]=false, b[12]=false, b[13]=false, b[14]=false, b[15]=false, out=out); } 多通道逻辑门 我们看到基本逻辑门负责计算布尔运算，但其只能根据输入计算出输出，缺少控制能力。下面我们介绍的多通道逻辑门则在逻辑控制方面扮演了重要角色，因为多通道逻辑门具有选择功能。多通道逻辑门在CPU和RAM中起到了重要作用。多通道逻辑门分为以下两种： Multiplexor: 有多路输入，一路输出，选择输入中的一路作为输出 DMultiplexor: 有一路输入，多路输出，在输出路中选择一路降输入值输出 芯片列表 Multiplexor &amp;lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y9h0fixj30me08mjrd.jpg&quot; width=&quot;600&amp;gt; DMultiplexor 这里我们实现一个2路1位的Mux。a，b是两路1位信号输入，sel是选择位。如果sel == 0，out管脚输出a的值，否则输出b的值。 2路1位Mux电路图 /** * 2路1位Mux * Multiplexor: * out = a if sel == 0 * b otherwise */ CHIP Mux { IN a, b, sel; OUT out; PARTS: Not(in= sel, out=NotSel); And(a=a, b=NotSel, out=AndAOut); And(a=b, b=sel, out=AndBOut); Or(a=AndAOut, b=AndBOut, out=out); } 当然除了2路选择器，还有4路、8路、16路等多路选择器。 多路Mux 下面是4路16位选择器的一种实现方式 /** * 4-way 16-bit multiplexor: * out = a if sel == 00 * b if sel == 01 * c if sel == 10 * d if sel == 11 */ CHIP Mux4Way16 { IN a[16], b[16], c[16], d[16], sel[2]; OUT out[16]; PARTS: Mux16(a=a, b=b, sel=sel[0], out=outA); Mux16(a=c, b=d, sel=sel[0], out=outB); Mux16(a=outA, b=outB, sel=sel[1], out=out); } ALU 有了多通道逻辑门，我们就可以进一步实现一个更为复杂的芯片：ALU。ALU是CPU的三大基本模块之一（ALU、寄存器、程序计数器）。基本逻辑门只能计算一种布尔逻辑，而ALU可以通过改变控制位输入变量的组合（zx,nz,zy,ny,f,no），可以控制实现多种计算逻辑。这类似于一个CPU可以执行指令集中的众多指令一样（当然这其中就依赖于ALU）。 芯片列表 ALU ALU真值表 下面我们就用上面实现的芯片来实现一下ALU（由于比较复杂，就先不画电路图了）。 /** * The ALU (Arithmetic Logic Unit). * Computes one of the following functions: * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y, * x+1, y+1, x-1, y-1, x&amp;amp;y, x|y on two 16-bit inputs, * according to 6 input bits denoted zx,nx,zy,ny,f,no. * In addition, the ALU computes two 1-bit outputs: * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0; * if the ALU output &amp;lt; 0, ng is set to 1; otherwise ng is set to 0. */ // Implementation: the ALU logic manipulates the x and y inputs // and operates on the resulting values, as follows: // if (zx == 1) set x = 0 // 16-bit constant // if (nx == 1) set x = !x // bitwise not // if (zy == 1) set y = 0 // 16-bit constant // if (ny == 1) set y = !y // bitwise not // if (f == 1) set out = x + y // integer 2's complement addition // if (f == 0) set out = x &amp;amp; y // bitwise and // if (no == 1) set out = !out // bitwise not // if (out == 0) set zr = 1 // if (out &amp;lt; 0) set ng = 1 CHIP ALU { IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp;amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &amp;lt; 0), 0 otherwise PARTS: Mux16(a=x, b=false, sel=zx, out=zSelX); Not16(in=zSelX, out=notZSelx); Mux16(a=zSelX, b=notZSelx, sel=nx, out=outX); Mux16(a=y, b=false, sel=zy, out=zSelY); Not16(in=zSelY, out=notZSelY); Mux16(a=zSelY, b=notZSelY, sel=ny, out=outY); Add16(a=outX, b=outY, out=outAdd); // X+Y And16(a=outX, b=outY, out=outAnd); // X&amp;amp;Y Mux16(a=outAnd, b=outAdd, sel=f, out=outF); Not16(in=outF, out=notF); Mux16(a=outF, b=notF, sel=no, out=out, out[0..7]=outZrA, out[8..15]=outZrB, out[15]=outMSB); Or8Way(in=outZrA, out=zrL); Or8Way(in=outZrB, out=zrH); Or(a=zrL, b=zrH, out=notZr); Not(in=notZr, out=zr); And(a=true, b=outMSB, out=ng); } 补码 最后我们再来谈一下补码，上面我们提到的加法器都没有考虑正负符号的问题，如果引入符号，那么电路会变得更加复杂。通过使用补码可以很好的规避这个问题，因为补码有一个很重要的特性：任何两个用补码表示的有符号数的加法和正数的加法完全相同，例如用正数加法操作（-2）+（-3），所得的结果正好是（-5）的补码；补码的减法可以用加法来代替实现，例如x-y == x+(-y)。</summary></entry><entry><title type="html">与非门实现CPU的数理基础</title><link href="http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80.html" rel="alternate" type="text/html" title="与非门实现CPU的数理基础" /><published>2019-10-17T00:00:00+08:00</published><updated>2019-10-17T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80.html">&lt;h3 id=&quot;cpu和布尔函数&quot;&gt;CPU和布尔函数&lt;/h3&gt;

&lt;p&gt;CPU本质上是一个函数计算器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;信号通过输入管脚输入，对应着函数的入参&lt;/li&gt;
  &lt;li&gt;CPU的内部电路是函数的黑盒实现&lt;/li&gt;
  &lt;li&gt;信号通过输出管脚输出，对应着函数的出参&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdjx10y6yj31gu0och04.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;8086 CPU&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;大家有没有思考过现代计算机为什么是基于二进制的🤔？事实上，在计算机的发展历程中确实出现过其他进制的计算机，例如10进制，3进制（有兴趣的同学可以翻翻计算机发展史，有助于加深对计算机原理的理解）。我认为现代计算机基于二进制的原因主要有两个：一方面是基于二进制，在物理实现上会更加容易，例如电路设计更加简单，0和1的表示也更加稳定（高低电平）；另一方面，既然CPU是函数的实现，那么就需要有完备的数学理论做支撑，英国数学家布尔在1854年创立了布尔代数学科，布尔代数本身十分简单，但却为百年之后出现的二进制计算机提供了重要的数学方法和理论基础。布尔代数正好完美契合了现代计算机只能执行非常简单的算数逻辑指令集但却能够超高速运算的特性。&lt;/p&gt;

&lt;h3 id=&quot;布尔函数&quot;&gt;布尔函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;布尔函数：&lt;/strong&gt;布尔函数处理布尔数值(它的输入输出都是二进制数值)。布尔函数在数字计算机的芯片设计中扮演基础角色，也在密码学中扮演关键角色。&lt;/p&gt;

&lt;p&gt;布尔函数的两种表示方法：&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;真值表：&lt;/strong&gt;枚举出函数所有输入变量的组合，然后写出每一种组合对应的函数输出值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921635xlzj30d00d2wed.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;真值表&lt;/figcaption&gt;&lt;/center&gt;
&lt;p&gt;2.&lt;strong&gt;布尔表达式：&lt;/strong&gt;使用布尔操作符（And，Or，Not等）表达，上面的真值表可以用此表达式表示：&lt;/p&gt;
&lt;center&gt;f(x, y, z) = (x And y) Or (Not(x) And z)&lt;/center&gt;

&lt;h3 id=&quot;布尔函数和门&quot;&gt;布尔函数和门&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;门（gate）&lt;/strong&gt;是用来实现布尔函数的物理设备，例如与门，或门，非门，与非门等。门是基本的电子元器件，复杂的门电路就构成了CPU&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921661g24j30u004at8o.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;门有输入管脚和输出管脚，对应着布尔函数的入参和出参；门电路的具体实现方式则对应着布尔函数的运算规则。复杂的布尔函数就对应的复杂的门电路&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g92165tk1lj311g0d63yy.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;布尔函数是门电路的数学表达，门电路是布尔函数的物理实现。&lt;strong&gt;可以说CPU的实现是建立在布尔函数之上的&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;用与非门实现cpu的数理基础&quot;&gt;用与非门实现CPU的数理基础&lt;/h3&gt;

&lt;p&gt;布尔函数的一些数学结论：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;任何一个布尔函数，无论多复杂，都可以只用三种布尔操作符And，Or，Not完全表达。&lt;/li&gt;
  &lt;li&gt;And，Or，Not运算都可以只用Nand（与非）一种运算来代替实现，或者只用Nor（或非）一种运算来代替实现。&lt;/li&gt;
  &lt;li&gt;由1、2可得：仅使用Nand运算，就能够构建任何布尔函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;以上证明方法可以自行Google&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;有了上面的数理基础做支撑，我们可以得出结论：一旦我们在物理上实现了Nand（与非门），我们就能够实现任何门电路，进而实现一个CPU。&lt;/p&gt;

&lt;h3 id=&quot;用软件实现硬件&quot;&gt;用软件实现硬件&lt;/h3&gt;

&lt;p&gt;今天，硬件设计者们也不再亲手制作硬件了，而是用软件来实现设计：通过编写硬件描述语言（HDL）来描述芯片结构，并能通过测试用例来验证设计。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921650gf9j313r0u077e.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;好了，下面就让我们用Nand来实现一个CPU吧~&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><summary type="html">CPU和布尔函数 CPU本质上是一个函数计算器： 信号通过输入管脚输入，对应着函数的入参 CPU的内部电路是函数的黑盒实现 信号通过输出管脚输出，对应着函数的出参 8086 CPU 大家有没有思考过现代计算机为什么是基于二进制的🤔？事实上，在计算机的发展历程中确实出现过其他进制的计算机，例如10进制，3进制（有兴趣的同学可以翻翻计算机发展史，有助于加深对计算机原理的理解）。我认为现代计算机基于二进制的原因主要有两个：一方面是基于二进制，在物理实现上会更加容易，例如电路设计更加简单，0和1的表示也更加稳定（高低电平）；另一方面，既然CPU是函数的实现，那么就需要有完备的数学理论做支撑，英国数学家布尔在1854年创立了布尔代数学科，布尔代数本身十分简单，但却为百年之后出现的二进制计算机提供了重要的数学方法和理论基础。布尔代数正好完美契合了现代计算机只能执行非常简单的算数逻辑指令集但却能够超高速运算的特性。 布尔函数 布尔函数：布尔函数处理布尔数值(它的输入输出都是二进制数值)。布尔函数在数字计算机的芯片设计中扮演基础角色，也在密码学中扮演关键角色。 布尔函数的两种表示方法： 1.真值表：枚举出函数所有输入变量的组合，然后写出每一种组合对应的函数输出值。 真值表 2.布尔表达式：使用布尔操作符（And，Or，Not等）表达，上面的真值表可以用此表达式表示： f(x, y, z) = (x And y) Or (Not(x) And z) 布尔函数和门 门（gate）是用来实现布尔函数的物理设备，例如与门，或门，非门，与非门等。门是基本的电子元器件，复杂的门电路就构成了CPU 门有输入管脚和输出管脚，对应着布尔函数的入参和出参；门电路的具体实现方式则对应着布尔函数的运算规则。复杂的布尔函数就对应的复杂的门电路 布尔函数是门电路的数学表达，门电路是布尔函数的物理实现。可以说CPU的实现是建立在布尔函数之上的 用与非门实现CPU的数理基础 布尔函数的一些数学结论： 任何一个布尔函数，无论多复杂，都可以只用三种布尔操作符And，Or，Not完全表达。 And，Or，Not运算都可以只用Nand（与非）一种运算来代替实现，或者只用Nor（或非）一种运算来代替实现。 由1、2可得：仅使用Nand运算，就能够构建任何布尔函数。 以上证明方法可以自行Google 有了上面的数理基础做支撑，我们可以得出结论：一旦我们在物理上实现了Nand（与非门），我们就能够实现任何门电路，进而实现一个CPU。 用软件实现硬件 今天，硬件设计者们也不再亲手制作硬件了，而是用软件来实现设计：通过编写硬件描述语言（HDL）来描述芯片结构，并能通过测试用例来验证设计。 好了，下面就让我们用Nand来实现一个CPU吧~</summary></entry><entry><title type="html">从与非门到俄罗斯方块</title><link href="http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html" rel="alternate" type="text/html" title="从与非门到俄罗斯方块" /><published>2019-10-16T00:00:00+08:00</published><updated>2019-10-16T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97</id><content type="html" xml:base="http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html">&lt;p&gt;&lt;img src=&quot;/post_image/nand_start/adam_god_nand.png&quot; alt=&quot;adam_god_nand&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mark!!! 开始学习课程：&lt;a href=&quot;https://www.nand2tetris.org/&quot;&gt;From Nand To Tetris&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;还有一篇类似课程：&lt;a href=&quot;https://www.youtube.com/watch?v=WqrNphu6HaU&amp;amp;list=PLdYq_l3Bzf1elCyzIfx2JgHfSMTsWbnfg&amp;amp;index=1&quot;&gt;计算机科学速成课&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;😀😀😀&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><summary type="html">Mark!!! 开始学习课程：From Nand To Tetris 还有一篇类似课程：计算机科学速成课 😀😀😀</summary></entry></feed>