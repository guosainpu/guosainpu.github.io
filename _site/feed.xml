<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-01-29T18:54:45+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">一只草履虫</title><subtitle>Your Site Description
</subtitle><author><name>Your Name</name></author><entry><title type="html">组合逻辑芯片：逻辑门&amp;amp;加法器&amp;amp;ALU</title><link href="http://localhost:4000/2019/12/16/%E9%80%BB%E8%BE%91%E9%97%A8-&-%E5%8A%A0%E6%B3%95%E5%99%A8-&-ALU.html" rel="alternate" type="text/html" title="组合逻辑芯片：逻辑门&amp;加法器&amp;ALU" /><published>2019-12-16T00:00:00+08:00</published><updated>2019-12-16T00:00:00+08:00</updated><id>http://localhost:4000/2019/12/16/%E9%80%BB%E8%BE%91%E9%97%A8%20&amp;%20%E5%8A%A0%E6%B3%95%E5%99%A8%20&amp;%20ALU</id><content type="html" xml:base="http://localhost:4000/2019/12/16/%E9%80%BB%E8%BE%91%E9%97%A8-&amp;-%E5%8A%A0%E6%B3%95%E5%99%A8-&amp;-ALU.html">&lt;p&gt;上篇说到：通过使用Nand门，我们可以实现任何逻辑门，进而实现可以一个CPU。后面我们就会搭建一个麻雀虽小但五脏俱全的计算机平台：hack。本篇我们开始第一步，实现搭建hack所需的一组芯片：组合逻辑芯片&lt;/p&gt;

&lt;h3 id=&quot;组合逻辑芯片&quot;&gt;组合逻辑芯片&lt;/h3&gt;

&lt;p&gt;一个最基本的CPU主要由两类芯片组成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;组合逻辑芯片（Combinational Chips）：与、或、非门，加法器，ALU芯片等。这些芯片主要负责逻辑计算&lt;/li&gt;
  &lt;li&gt;时序芯片（Sequential Chips）：寄存器，计数器，RAM等。这些芯片主要负责暂存数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组合逻辑芯片（下面简称逻辑芯片）可以类比为一个布尔函数，它仅负责处理逻辑运算：输出结果仅依赖于其输入变量的排列组合。逻辑芯片是没有记忆能力的，它们不能维持自身的状态，当逻辑芯片的输入值改变的时候，它们的输出值也会实时地改变。&lt;/p&gt;

&lt;p&gt;hack所需要的逻辑芯片有以下四种：基本逻辑门、多通道逻辑门、加法器、ALU（算数逻辑单元）。&lt;/p&gt;

&lt;h3 id=&quot;基本逻辑门&quot;&gt;基本逻辑门&lt;/h3&gt;
&lt;p&gt;基本逻辑门是一些简单的布尔函数的实现，我们需要的基本逻辑门如下，有1位和多位（16位）之分。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1g9yzjn8lngj30qe0mgwew.jpg&quot; width=&quot;65%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;我们所有组合逻辑芯片都是基于Nand实现的，下面是Nand的真值表：只有当两个输入都为1时输出为0，其余输出为1反，然后输出。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga16e7ws5tj30b007s3yd.jpg&quot; width=&quot;25%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Nand真值表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;首先我们用Nand实现一个Not。Not很简单，对其输入取反，然后输出。下面是我自己的实现方式：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga21uf1wocj30s609e3yh.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Not电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：硬件描述语言实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Not HDL实现
 * Not gate:
 * out = not in
 */

CHIP Not {
    IN in;
    OUT out;

    PARTS:
    Nand(a=in, b=in, out=out); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们继续用刚刚实现的Not和Nand组合使用，再实现一个And。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga221fwwf3j310m08mgll.jpg&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;And电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * And gate: 
 * out = 1 if (a == 1 and b == 1)
 *       0 otherwise
 */

CHIP And {
    IN a, b;
    OUT out;

    PARTS:
    Nand(a=a, b=b, out=nandOut);
    Not(in=nandOut, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多位基本逻辑门是1位基本逻辑门的简单组合，以16位And为例，用16个1位And组合成16位And.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16-bit bitwise And:
 * for i = 0..15: out[i] = (a[i] and b[i])
 */

CHIP And16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    And(a=a[0], b=b[0], out=out[0]);
    And(a=a[1], b=b[1], out=out[1]);
    And(a=a[2], b=b[2], out=out[2]);
    And(a=a[3], b=b[3], out=out[3]);
    And(a=a[4], b=b[4], out=out[4]);
    And(a=a[5], b=b[5], out=out[5]);
    And(a=a[6], b=b[6], out=out[6]);
    And(a=a[7], b=b[7], out=out[7]);
    And(a=a[8], b=b[8], out=out[8]);
    And(a=a[9], b=b[9], out=out[9]);
    And(a=a[10], b=b[10], out=out[10]);
    And(a=a[11], b=b[11], out=out[11]);
    And(a=a[12], b=b[12], out=out[12]);
    And(a=a[13], b=b[13], out=out[13]);
    And(a=a[14], b=b[14], out=out[14]);
    And(a=a[15], b=b[15], out=out[15]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;以此类推，我们可以一步步实现其他所有基本逻辑门。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;加法器&quot;&gt;加法器&lt;/h3&gt;
&lt;p&gt;有了上面实现的这些基本逻辑门，我们就可以实现CPU中一个非常重要的基本芯片：加法器。实现加法器的顺序是：半加器-&amp;gt;全加器-&amp;gt;16位加法器&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cyn6tzgj30va0d8glt.jpg&quot; width=&quot;65%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;第一步：实现一个半加器，半加器负责计算两个一位二进制相加，输出sum和carry（进位）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xb8b2xej30sc09m74d.jpg&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;半加器&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;虽然半加器看上去跳出了布尔运算，升级到的小学数学，但其仍然可以用真值表表示，所以也就可以用基本逻辑门实现，我们用一个Xor和And就可以实现半加器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2c9rhu5bj30sa0ge3yo.jpg&quot; width=&quot;65%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;半加器电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 半加器
 * Computes the sum of two bits.
 */

CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b 
        carry;  // Left bit of a + b

    PARTS:
    Xor(a=a, b=b, out=sum);
    And(a=a, b=b, out=carry);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;半加器只能计算两个一位二进制数相加，接着我们在输入端再加入一个进位管脚（代表低位做加法时进过来的进位），就成为了一个全加器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xom01j9j30u80de0sv.jpg&quot; width=&quot;65%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;全加器&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cemdwywj318g0gu0t1.jpg&quot; width=&quot;70%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;全加器电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 全加器
 * Computes the sum of three bits.
 */

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, carry=carryA, sum=sumA);
    HalfAdder(a=sumA, b=c, carry=carryB, sum=sum);
    Or(a=carryA, b=carryB, out=carry);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后我们利用全加器实现16位加法器，有了16位加法器，我们就可以进行2个不大于2^16的整数的加法了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xrljwy9j30te06sdfv.jpg&quot; width=&quot;65%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;16位加法器&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16位加法器
 * Adds two 16-bit values.
 * The most significant carry bit is ignored.
 */

CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=ca0);
    FullAdder(a=a[1], b=b[1], c=ca0, sum=out[1], carry=ca1);
    FullAdder(a=a[2], b=b[2], c=ca1, sum=out[2], carry=ca2);
    FullAdder(a=a[3], b=b[3], c=ca2, sum=out[3], carry=ca3);
    FullAdder(a=a[4], b=b[4], c=ca3, sum=out[4], carry=ca4);
    FullAdder(a=a[5], b=b[5], c=ca4, sum=out[5], carry=ca5);
    FullAdder(a=a[6], b=b[6], c=ca5, sum=out[6], carry=ca6);
    FullAdder(a=a[7], b=b[7], c=ca6, sum=out[7], carry=ca7);
    FullAdder(a=a[8], b=b[8], c=ca7, sum=out[8], carry=ca8);
    FullAdder(a=a[9], b=b[9], c=ca8, sum=out[9], carry=ca9);
    FullAdder(a=a[10], b=b[10], c=ca9, sum=out[10], carry=ca10);
    FullAdder(a=a[11], b=b[11], c=ca10, sum=out[11], carry=ca11);
    FullAdder(a=a[12], b=b[12], c=ca11, sum=out[12], carry=ca12);
    FullAdder(a=a[13], b=b[13], c=ca12, sum=out[13], carry=ca13);
    FullAdder(a=a[14], b=b[14], c=ca13, sum=out[14], carry=ca14);
    FullAdder(a=a[15], b=b[15], c=ca14, sum=out[15], carry=ignorCa); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了加法器，我们再实现一个累加器，它对输入数据进行加1，然后输出。累加器是后面CPU中程序计数器的重要部分。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 累加器
 * 16-bit incrementer:
 * out = in + 1 (arithmetic addition)
 */

CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Add16(a=in, b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=false, b[5]=false, b[6]=false, b[7]=false, b[8]=false, b[9]=false, b[10]=false, b[11]=false, b[12]=false, b[13]=false, b[14]=false, b[15]=false, out=out);
}     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;多通道逻辑门&quot;&gt;多通道逻辑门&lt;/h3&gt;
&lt;p&gt;我们看到基本逻辑门负责计算布尔运算，但其只能根据输入计算出输出，缺少控制能力。下面我们介绍的多通道逻辑门则在逻辑控制方面扮演了重要角色，因为多通道逻辑门具有&lt;strong&gt;选择功能&lt;/strong&gt;。多通道逻辑门在CPU和RAM中起到了重要作用。多通道逻辑门分为以下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Multiplexor:&lt;/strong&gt; 有多路输入，一路输出，选择输入中的一路作为输出&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DMultiplexor:&lt;/strong&gt; 有一路输入，多路输出，在输出路中选择一路降输入值输出&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cyl836uj30v60meaaw.jpg&quot; width=&quot;65%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y8t42i3j30p60dq0sv.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Multiplexor&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y9h0fixj30me08mjrd.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;DMultiplexor&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;这里我们实现一个2路1位的Mux。a，b是两路1位信号输入，sel是选择位。如果sel == 0，out管脚输出a的值，否则输出b的值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1zhhi4a2j30rm0kuq36.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;2路1位Mux电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
 * 2路1位Mux
 * Multiplexor:
 * out = a if sel == 0
 *       b otherwise
 */

CHIP Mux {
    IN a, b, sel;
    OUT out;

    PARTS:
    Not(in= sel, out=NotSel);
    And(a=a, b=NotSel, out=AndAOut);
    And(a=b, b=sel, out=AndBOut);
    Or(a=AndAOut, b=AndBOut, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然除了2路选择器，还有4路、8路、16路等多路选择器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yd61q3mj30ze09at8v.jpg&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;多路Mux&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;下面是4路16位选择器的一种实现方式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 4-way 16-bit multiplexor:
 * out = a if sel == 00
 *       b if sel == 01
 *       c if sel == 10
 *       d if sel == 11
 */

CHIP Mux4Way16 {
    IN a[16], b[16], c[16], d[16], sel[2];
    OUT out[16];

    PARTS:
    Mux16(a=a, b=b, sel=sel[0], out=outA);
    Mux16(a=c, b=d, sel=sel[0], out=outB);
    Mux16(a=outA, b=outB, sel=sel[1], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;alu&quot;&gt;ALU&lt;/h3&gt;
&lt;p&gt;有了多通道逻辑门，我们就可以进一步实现一个更为复杂的芯片：ALU。ALU是CPU的三大基本模块之一（ALU、寄存器、程序计数器）。基本逻辑门只能计算一种布尔逻辑，而ALU可以通过改变控制位输入变量的组合（zx,nz,zy,ny,f,no），可以控制实现多种计算逻辑。这类似于一个CPU可以执行指令集中的众多指令一样（当然这其中就依赖于ALU）。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cylk4d8j30uo05i3yg.jpg&quot; width=&quot;65%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yf3rz82j30pi0i0dg1.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;ALU&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yf94f4ej314x0u0jsn.jpg&quot; width=&quot;60%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;ALU真值表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;下面我们就用上面实现的芯片来实现一下ALU（由于比较复杂，就先不画电路图了）。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * The ALU (Arithmetic Logic Unit).
 * Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&amp;amp;y, x|y on two 16-bit inputs, 
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * In addition, the ALU computes two 1-bit outputs:
 * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;
 * if the ALU output &amp;lt; 0, ng is set to 1; otherwise ng is set to 0.
 */

// Implementation: the ALU logic manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) set x = 0        // 16-bit constant
// if (nx == 1) set x = !x       // bitwise not
// if (zy == 1) set y = 0        // 16-bit constant
// if (ny == 1) set y = !y       // bitwise not
// if (f == 1)  set out = x + y  // integer 2's complement addition
// if (f == 0)  set out = x &amp;amp; y  // bitwise and
// if (no == 1) set out = !out   // bitwise not
// if (out == 0) set zr = 1
// if (out &amp;lt; 0) set ng = 1

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute out = x + y (if 1) or x &amp;amp; y (if 0)
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out &amp;lt; 0),  0 otherwise

    PARTS:
    Mux16(a=x, b=false, sel=zx, out=zSelX);
    Not16(in=zSelX, out=notZSelx);
    Mux16(a=zSelX, b=notZSelx, sel=nx, out=outX);

    Mux16(a=y, b=false, sel=zy, out=zSelY);
    Not16(in=zSelY, out=notZSelY);
    Mux16(a=zSelY, b=notZSelY, sel=ny, out=outY);

    Add16(a=outX, b=outY, out=outAdd); // X+Y
    And16(a=outX, b=outY, out=outAnd); // X&amp;amp;Y

    Mux16(a=outAnd, b=outAdd, sel=f, out=outF);
    Not16(in=outF, out=notF);

    Mux16(a=outF, b=notF, sel=no, out=out, out[0..7]=outZrA, out[8..15]=outZrB, out[15]=outMSB);

    Or8Way(in=outZrA, out=zrL);
    Or8Way(in=outZrB, out=zrH);
    Or(a=zrL, b=zrH, out=notZr);
    Not(in=notZr, out=zr);

    And(a=true, b=outMSB, out=ng);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;补码&quot;&gt;补码&lt;/h3&gt;
&lt;p&gt;最后我们再来谈一下补码，上面我们提到的加法器都没有考虑正负符号的问题，如果引入符号，那么电路会变得更加复杂。通过使用补码可以很好的规避这个问题，因为补码有一个很重要的特性：&lt;strong&gt;任何两个用补码表示的有符号数的加法和正数的加法完全相同&lt;/strong&gt;，例如用正数加法操作（-2）+（-3），所得的结果正好是（-5）的补码；补码的减法可以用加法来代替实现，例如x-y == x+(-y)。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><summary type="html">上篇说到：通过使用Nand门，我们可以实现任何逻辑门，进而实现可以一个CPU。后面我们就会搭建一个麻雀虽小但五脏俱全的计算机平台：hack。本篇我们开始第一步，实现搭建hack所需的一组芯片：组合逻辑芯片 组合逻辑芯片 一个最基本的CPU主要由两类芯片组成： 组合逻辑芯片（Combinational Chips）：与、或、非门，加法器，ALU芯片等。这些芯片主要负责逻辑计算 时序芯片（Sequential Chips）：寄存器，计数器，RAM等。这些芯片主要负责暂存数据 组合逻辑芯片（下面简称逻辑芯片）可以类比为一个布尔函数，它仅负责处理逻辑运算：输出结果仅依赖于其输入变量的排列组合。逻辑芯片是没有记忆能力的，它们不能维持自身的状态，当逻辑芯片的输入值改变的时候，它们的输出值也会实时地改变。 hack所需要的逻辑芯片有以下四种：基本逻辑门、多通道逻辑门、加法器、ALU（算数逻辑单元）。 基本逻辑门 基本逻辑门是一些简单的布尔函数的实现，我们需要的基本逻辑门如下，有1位和多位（16位）之分。 芯片列表 我们所有组合逻辑芯片都是基于Nand实现的，下面是Nand的真值表：只有当两个输入都为1时输出为0，其余输出为1反，然后输出。 Nand真值表 首先我们用Nand实现一个Not。Not很简单，对其输入取反，然后输出。下面是我自己的实现方式： Not电路图 HDL实现：硬件描述语言实现。 /** * Not HDL实现 * Not gate: * out = not in */ CHIP Not { IN in; OUT out; PARTS: Nand(a=in, b=in, out=out); } 然后我们继续用刚刚实现的Not和Nand组合使用，再实现一个And。 And电路图 /** * And gate: * out = 1 if (a == 1 and b == 1) * 0 otherwise */ CHIP And { IN a, b; OUT out; PARTS: Nand(a=a, b=b, out=nandOut); Not(in=nandOut, out=out); } 多位基本逻辑门是1位基本逻辑门的简单组合，以16位And为例，用16个1位And组合成16位And. /** * 16-bit bitwise And: * for i = 0..15: out[i] = (a[i] and b[i]) */ CHIP And16 { IN a[16], b[16]; OUT out[16]; PARTS: And(a=a[0], b=b[0], out=out[0]); And(a=a[1], b=b[1], out=out[1]); And(a=a[2], b=b[2], out=out[2]); And(a=a[3], b=b[3], out=out[3]); And(a=a[4], b=b[4], out=out[4]); And(a=a[5], b=b[5], out=out[5]); And(a=a[6], b=b[6], out=out[6]); And(a=a[7], b=b[7], out=out[7]); And(a=a[8], b=b[8], out=out[8]); And(a=a[9], b=b[9], out=out[9]); And(a=a[10], b=b[10], out=out[10]); And(a=a[11], b=b[11], out=out[11]); And(a=a[12], b=b[12], out=out[12]); And(a=a[13], b=b[13], out=out[13]); And(a=a[14], b=b[14], out=out[14]); And(a=a[15], b=b[15], out=out[15]); } 以此类推，我们可以一步步实现其他所有基本逻辑门。 加法器 有了上面实现的这些基本逻辑门，我们就可以实现CPU中一个非常重要的基本芯片：加法器。实现加法器的顺序是：半加器-&amp;gt;全加器-&amp;gt;16位加法器 芯片列表 第一步：实现一个半加器，半加器负责计算两个一位二进制相加，输出sum和carry（进位）。 半加器 虽然半加器看上去跳出了布尔运算，升级到的小学数学，但其仍然可以用真值表表示，所以也就可以用基本逻辑门实现，我们用一个Xor和And就可以实现半加器。 半加器电路图 /** * 半加器 * Computes the sum of two bits. */ CHIP HalfAdder { IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry); } 半加器只能计算两个一位二进制数相加，接着我们在输入端再加入一个进位管脚（代表低位做加法时进过来的进位），就成为了一个全加器。 全加器 全加器电路图 /** * 全加器 * Computes the sum of three bits. */ CHIP FullAdder { IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, carry=carryA, sum=sumA); HalfAdder(a=sumA, b=c, carry=carryB, sum=sum); Or(a=carryA, b=carryB, out=carry); } 最后我们利用全加器实现16位加法器，有了16位加法器，我们就可以进行2个不大于2^16的整数的加法了。 16位加法器 /** * 16位加法器 * Adds two 16-bit values. * The most significant carry bit is ignored. */ CHIP Add16 { IN a[16], b[16]; OUT out[16]; PARTS: FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=ca0); FullAdder(a=a[1], b=b[1], c=ca0, sum=out[1], carry=ca1); FullAdder(a=a[2], b=b[2], c=ca1, sum=out[2], carry=ca2); FullAdder(a=a[3], b=b[3], c=ca2, sum=out[3], carry=ca3); FullAdder(a=a[4], b=b[4], c=ca3, sum=out[4], carry=ca4); FullAdder(a=a[5], b=b[5], c=ca4, sum=out[5], carry=ca5); FullAdder(a=a[6], b=b[6], c=ca5, sum=out[6], carry=ca6); FullAdder(a=a[7], b=b[7], c=ca6, sum=out[7], carry=ca7); FullAdder(a=a[8], b=b[8], c=ca7, sum=out[8], carry=ca8); FullAdder(a=a[9], b=b[9], c=ca8, sum=out[9], carry=ca9); FullAdder(a=a[10], b=b[10], c=ca9, sum=out[10], carry=ca10); FullAdder(a=a[11], b=b[11], c=ca10, sum=out[11], carry=ca11); FullAdder(a=a[12], b=b[12], c=ca11, sum=out[12], carry=ca12); FullAdder(a=a[13], b=b[13], c=ca12, sum=out[13], carry=ca13); FullAdder(a=a[14], b=b[14], c=ca13, sum=out[14], carry=ca14); FullAdder(a=a[15], b=b[15], c=ca14, sum=out[15], carry=ignorCa); } 有了加法器，我们再实现一个累加器，它对输入数据进行加1，然后输出。累加器是后面CPU中程序计数器的重要部分。 /** * 累加器 * 16-bit incrementer: * out = in + 1 (arithmetic addition) */ CHIP Inc16 { IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=false, b[5]=false, b[6]=false, b[7]=false, b[8]=false, b[9]=false, b[10]=false, b[11]=false, b[12]=false, b[13]=false, b[14]=false, b[15]=false, out=out); } 多通道逻辑门 我们看到基本逻辑门负责计算布尔运算，但其只能根据输入计算出输出，缺少控制能力。下面我们介绍的多通道逻辑门则在逻辑控制方面扮演了重要角色，因为多通道逻辑门具有选择功能。多通道逻辑门在CPU和RAM中起到了重要作用。多通道逻辑门分为以下两种： Multiplexor: 有多路输入，一路输出，选择输入中的一路作为输出 DMultiplexor: 有一路输入，多路输出，在输出路中选择一路降输入值输出 芯片列表 Multiplexor DMultiplexor 这里我们实现一个2路1位的Mux。a，b是两路1位信号输入，sel是选择位。如果sel == 0，out管脚输出a的值，否则输出b的值。 2路1位Mux电路图 /** * 2路1位Mux * Multiplexor: * out = a if sel == 0 * b otherwise */ CHIP Mux { IN a, b, sel; OUT out; PARTS: Not(in= sel, out=NotSel); And(a=a, b=NotSel, out=AndAOut); And(a=b, b=sel, out=AndBOut); Or(a=AndAOut, b=AndBOut, out=out); } 当然除了2路选择器，还有4路、8路、16路等多路选择器。 多路Mux 下面是4路16位选择器的一种实现方式 /** * 4-way 16-bit multiplexor: * out = a if sel == 00 * b if sel == 01 * c if sel == 10 * d if sel == 11 */ CHIP Mux4Way16 { IN a[16], b[16], c[16], d[16], sel[2]; OUT out[16]; PARTS: Mux16(a=a, b=b, sel=sel[0], out=outA); Mux16(a=c, b=d, sel=sel[0], out=outB); Mux16(a=outA, b=outB, sel=sel[1], out=out); } ALU 有了多通道逻辑门，我们就可以进一步实现一个更为复杂的芯片：ALU。ALU是CPU的三大基本模块之一（ALU、寄存器、程序计数器）。基本逻辑门只能计算一种布尔逻辑，而ALU可以通过改变控制位输入变量的组合（zx,nz,zy,ny,f,no），可以控制实现多种计算逻辑。这类似于一个CPU可以执行指令集中的众多指令一样（当然这其中就依赖于ALU）。 芯片列表 ALU ALU真值表 下面我们就用上面实现的芯片来实现一下ALU（由于比较复杂，就先不画电路图了）。 /** * The ALU (Arithmetic Logic Unit). * Computes one of the following functions: * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y, * x+1, y+1, x-1, y-1, x&amp;amp;y, x|y on two 16-bit inputs, * according to 6 input bits denoted zx,nx,zy,ny,f,no. * In addition, the ALU computes two 1-bit outputs: * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0; * if the ALU output &amp;lt; 0, ng is set to 1; otherwise ng is set to 0. */ // Implementation: the ALU logic manipulates the x and y inputs // and operates on the resulting values, as follows: // if (zx == 1) set x = 0 // 16-bit constant // if (nx == 1) set x = !x // bitwise not // if (zy == 1) set y = 0 // 16-bit constant // if (ny == 1) set y = !y // bitwise not // if (f == 1) set out = x + y // integer 2's complement addition // if (f == 0) set out = x &amp;amp; y // bitwise and // if (no == 1) set out = !out // bitwise not // if (out == 0) set zr = 1 // if (out &amp;lt; 0) set ng = 1 CHIP ALU { IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp;amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &amp;lt; 0), 0 otherwise PARTS: Mux16(a=x, b=false, sel=zx, out=zSelX); Not16(in=zSelX, out=notZSelx); Mux16(a=zSelX, b=notZSelx, sel=nx, out=outX); Mux16(a=y, b=false, sel=zy, out=zSelY); Not16(in=zSelY, out=notZSelY); Mux16(a=zSelY, b=notZSelY, sel=ny, out=outY); Add16(a=outX, b=outY, out=outAdd); // X+Y And16(a=outX, b=outY, out=outAnd); // X&amp;amp;Y Mux16(a=outAnd, b=outAdd, sel=f, out=outF); Not16(in=outF, out=notF); Mux16(a=outF, b=notF, sel=no, out=out, out[0..7]=outZrA, out[8..15]=outZrB, out[15]=outMSB); Or8Way(in=outZrA, out=zrL); Or8Way(in=outZrB, out=zrH); Or(a=zrL, b=zrH, out=notZr); Not(in=notZr, out=zr); And(a=true, b=outMSB, out=ng); } 补码 最后我们再来谈一下补码，上面我们提到的加法器都没有考虑正负符号的问题，如果引入符号，那么电路会变得更加复杂。通过使用补码可以很好的规避这个问题，因为补码有一个很重要的特性：任何两个用补码表示的有符号数的加法和正数的加法完全相同，例如用正数加法操作（-2）+（-3），所得的结果正好是（-5）的补码；补码的减法可以用加法来代替实现，例如x-y == x+(-y)。</summary></entry><entry><title type="html">与非门实现CPU的数理基础</title><link href="http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80.html" rel="alternate" type="text/html" title="与非门实现CPU的数理基础" /><published>2019-10-17T00:00:00+08:00</published><updated>2019-10-17T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80.html">&lt;h3 id=&quot;cpu和布尔函数&quot;&gt;CPU和布尔函数&lt;/h3&gt;

&lt;p&gt;CPU本质上是一个函数计算器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;信号通过输入管脚输入，对应着函数的入参&lt;/li&gt;
  &lt;li&gt;CPU的内部电路则是函数的黑盒实现&lt;/li&gt;
  &lt;li&gt;信号通过输出管脚输出，对应着函数的出参&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdjx10y6yj31gu0och04.jpg&quot; width=&quot;70%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;8086 CPU&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;大家有没有思考过现代计算机为什么是基于二进制的🤔？事实上，在计算机的发展历程中确实出现过其他进制的计算机，例如10进制，3进制（有兴趣的同学可以翻翻计算机发展史，有助于加深对计算机原理和结构的理解）。我认为现代计算机基于二进制的原因主要有两个：一方面是基于二进制，在物理实现上会更加容易，例如电路设计更加简单，0和1的表示也更加稳定（高低电平）；另一方面，既然CPU是函数的实现，那么就需要有完备的数学理论做支撑，英国数学家布尔在1854年创立了布尔代数学科，布尔代数本身十分简单，但却为百年之后出现的二进制计算机提供了重要的数学方法和理论基础。布尔代数正好非常契合现代计算机只能执行非常简单的算数逻辑指令集但却能够超高速运算的特性。&lt;/p&gt;

&lt;h3 id=&quot;布尔函数&quot;&gt;布尔函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;布尔函数：&lt;/strong&gt;布尔函数处理布尔数值(它的输入输出都是二进制数值)。布尔函数在数字计算机的芯片设计中扮演基础角色，也在密码学中扮演关键角色。&lt;/p&gt;

&lt;p&gt;布尔函数的两种表示方法：&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;真值表：&lt;/strong&gt;枚举出函数所有输入变量的组合，然后写出每一种组合对应的函数输出值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921635xlzj30d00d2wed.jpg&quot; width=&quot;25%&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;真值表&lt;/figcaption&gt;&lt;/center&gt;
&lt;p&gt;2.&lt;strong&gt;布尔表达式：&lt;/strong&gt;使用布尔操作符（And，Or，Not等）表达，上面的真值表可以用此表达式表示：&lt;/p&gt;
&lt;center&gt;f(x, y, z) = (x And y) Or (Not(x) And z)&lt;/center&gt;

&lt;h3 id=&quot;布尔函数和门&quot;&gt;布尔函数和门&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;门（gate）&lt;/strong&gt;是用来实现布尔函数的物理设备，例如与门，或门，非门，与非门等。门是基本的电子元器件，复杂的门电路就构成了CPU&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921661g24j30u004at8o.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;

&lt;p&gt;门有输入管脚和输出管脚，对应着布尔函数的入参和出参；门电路的具体实现方式则对应着布尔函数的运算规则。复杂的布尔函数就对应的复杂的门电路&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g92165tk1lj311g0d63yy.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;

&lt;p&gt;布尔函数是门电路的数学表达，门电路是布尔函数的物理实现。&lt;strong&gt;可以说CPU的实现是建立在布尔函数之上的&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;用与非门实现cpu的数理基础&quot;&gt;用与非门实现CPU的数理基础&lt;/h3&gt;

&lt;p&gt;布尔函数的一些数学结论：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;任何一个布尔函数，无论多复杂，都可以只用三种布尔操作符And，Or，Not完全表达。&lt;/li&gt;
  &lt;li&gt;And，Or，Not运算都可以只用Nand（与非）一种运算来代替实现，或者只用Nor（或非）一种运算来代替实现。&lt;/li&gt;
  &lt;li&gt;由1、2可得：仅使用Nand运算，就能够构建任何布尔函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;以上证明方法可以自行Google&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;有了上面的数理基础做支撑，我们可以得出结论：一旦我们在物理上实现了Nand（与非门），我们就能够实现任何门电路，进而实现一个CPU。&lt;/p&gt;

&lt;h3 id=&quot;用软件实现硬件&quot;&gt;用软件实现硬件&lt;/h3&gt;

&lt;p&gt;今天，硬件设计者们也不再亲手制作硬件了，而是用软件来实现设计：通过编写硬件描述语言（HDL）来描述芯片结构，并能通过测试用例来验证设计。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921650gf9j313r0u077e.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;

&lt;p&gt;好了，下面就让我们用Nand来实现一个CPU吧~&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><summary type="html">CPU和布尔函数 CPU本质上是一个函数计算器： 信号通过输入管脚输入，对应着函数的入参 CPU的内部电路则是函数的黑盒实现 信号通过输出管脚输出，对应着函数的出参 8086 CPU 大家有没有思考过现代计算机为什么是基于二进制的🤔？事实上，在计算机的发展历程中确实出现过其他进制的计算机，例如10进制，3进制（有兴趣的同学可以翻翻计算机发展史，有助于加深对计算机原理和结构的理解）。我认为现代计算机基于二进制的原因主要有两个：一方面是基于二进制，在物理实现上会更加容易，例如电路设计更加简单，0和1的表示也更加稳定（高低电平）；另一方面，既然CPU是函数的实现，那么就需要有完备的数学理论做支撑，英国数学家布尔在1854年创立了布尔代数学科，布尔代数本身十分简单，但却为百年之后出现的二进制计算机提供了重要的数学方法和理论基础。布尔代数正好非常契合现代计算机只能执行非常简单的算数逻辑指令集但却能够超高速运算的特性。 布尔函数 布尔函数：布尔函数处理布尔数值(它的输入输出都是二进制数值)。布尔函数在数字计算机的芯片设计中扮演基础角色，也在密码学中扮演关键角色。 布尔函数的两种表示方法： 1.真值表：枚举出函数所有输入变量的组合，然后写出每一种组合对应的函数输出值。 真值表 2.布尔表达式：使用布尔操作符（And，Or，Not等）表达，上面的真值表可以用此表达式表示： f(x, y, z) = (x And y) Or (Not(x) And z) 布尔函数和门 门（gate）是用来实现布尔函数的物理设备，例如与门，或门，非门，与非门等。门是基本的电子元器件，复杂的门电路就构成了CPU 门有输入管脚和输出管脚，对应着布尔函数的入参和出参；门电路的具体实现方式则对应着布尔函数的运算规则。复杂的布尔函数就对应的复杂的门电路 布尔函数是门电路的数学表达，门电路是布尔函数的物理实现。可以说CPU的实现是建立在布尔函数之上的 用与非门实现CPU的数理基础 布尔函数的一些数学结论： 任何一个布尔函数，无论多复杂，都可以只用三种布尔操作符And，Or，Not完全表达。 And，Or，Not运算都可以只用Nand（与非）一种运算来代替实现，或者只用Nor（或非）一种运算来代替实现。 由1、2可得：仅使用Nand运算，就能够构建任何布尔函数。 以上证明方法可以自行Google 有了上面的数理基础做支撑，我们可以得出结论：一旦我们在物理上实现了Nand（与非门），我们就能够实现任何门电路，进而实现一个CPU。 用软件实现硬件 今天，硬件设计者们也不再亲手制作硬件了，而是用软件来实现设计：通过编写硬件描述语言（HDL）来描述芯片结构，并能通过测试用例来验证设计。 好了，下面就让我们用Nand来实现一个CPU吧~</summary></entry><entry><title type="html">从与非门到俄罗斯方块</title><link href="http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html" rel="alternate" type="text/html" title="从与非门到俄罗斯方块" /><published>2019-10-16T00:00:00+08:00</published><updated>2019-10-16T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97</id><content type="html" xml:base="http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html">&lt;p&gt;&lt;img src=&quot;/post_image/nand_start/adam_god_nand.png&quot; alt=&quot;adam_god_nand&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mark!!! 开始学习课程：&lt;a href=&quot;https://www.nand2tetris.org/&quot;&gt;From Nand To Tetris&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;😀😀😀&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><summary type="html">Mark!!! 开始学习课程：From Nand To Tetris 😀😀😀</summary></entry></feed>