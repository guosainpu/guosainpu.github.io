<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-02-27T15:30:12+08:00</updated><id>/feed.xml</id><title type="html">一只草履虫</title><subtitle>Your Site Description
</subtitle><author><name>Your Name</name></author><entry><title type="html">从0到1构建计算机(10/10)–简单的操作系统</title><link href="/2020/02/27/%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" rel="alternate" type="text/html" title="从0到1构建计算机(10/10)--简单的操作系统" /><published>2020-02-27T00:00:00+08:00</published><updated>2020-02-27T00:00:00+08:00</updated><id>/2020/02/27/%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</id><content type="html" xml:base="/2020/02/27/%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html">&lt;p&gt;TODO…&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">TODO…</summary></entry><entry><title type="html">从0到1构建计算机(9/10)–实现编译器</title><link href="/2020/02/25/%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8.html" rel="alternate" type="text/html" title="从0到1构建计算机(9/10)--实现编译器" /><published>2020-02-25T00:00:00+08:00</published><updated>2020-02-25T00:00:00+08:00</updated><id>/2020/02/25/%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8</id><content type="html" xml:base="/2020/02/25/%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8.html">&lt;p&gt;本篇实现Jack的编译器，也是从0到1构建计算机系列最复杂的一篇。编译器的实现本身是非常复杂的，但得益于Jack超简洁的语法，我们回避掉了很多复杂的问题。总体上Jack编译器是一个完整的编译器，它包括词法分析，语法分析，语义分析，代码生成等重要主题。&lt;/p&gt;

&lt;p&gt;高级语言为什么能够被编译器理解和编译？因为高级语言是按照某种规则的语法（上下文无关语法）组织的，结构上层次化的语言。程序的每个类，每条语句都是符合某种语法规则的，所以我们反过来能够使用这些语法规则对其进行准确地解析，而我们日常使用的自然语言则不太受语法的严格的约束，所以用算法解释自然语言会更困难。&lt;/p&gt;

&lt;h3 id=&quot;词法分析&quot;&gt;词法分析&lt;/h3&gt;

&lt;p&gt;程序基本上由语句组成，语句由单词和符号组成，每个单词或符号都有它要表达的含义：或是某种预算操作，或是某块内存的指针，或是指明当前语句是那种类型等等。编译器要做的第一件事情就是把语句拆解成一个个单词或符号，即词法分析。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc9yj7rudwj314q0h4q3a.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;Jack语法由一下五类单词构成：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 关键字：多用于指明当前语句的类型、属性。
2. 符号：算数逻辑运算符号、功能符号等。
3. 整型数字：0...32767
4. 字符创：“”括起来的字符串。
5. 字面量：类名、变量名等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc9yj6vuonj319g0m0abl.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;下面以一个程序举例：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gca095p9hmj31cg0ne0vp.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;实现&quot;&gt;实现&lt;/h4&gt;

&lt;p&gt;词法分析的过程并不复杂。先删除输入程序中的注释代码，然后通过使用Ruby的StringScanner工具和一些正则操作把源程序拆解成以上五种类型的单词即可。我们用JackTokenizer来实现Jack的词法分析：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JackTokenizer接口设计：

constructor：输入源程序，完成词法分析
hasMoreToken：是否还是token
advance：token游标前进一位
tokenType：当前token类型
keyword：返回当前关键字类型的token
symbol：返回当前symbol类型的token
intValue：返回当前int类型的token
stringValue：返回当前string类型的token
indentifier：返回当前indentifier类型的token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;词法分析关键代码如下：&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;vg&quot;&gt;$KEYWORDS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;class&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;method&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;function&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;constructor&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;int&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;boolean&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;char&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;void&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;var&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;static&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;field&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;let&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;do&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;if&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;else&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;while&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;return&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;null&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;this&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;vg&quot;&gt;$SYMBOL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&amp;amp;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;|&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;=&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;~&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JackTokenizer&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;analysizeFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#删除所有注释&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;gsub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/((?:\/\*(?:[^*]|(?:\*+[^*\/]))*\*+\/)|(?:\/\/.*))/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;#代码转成token&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@tokens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scanTextToToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;writeTokensTofile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanTextToToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;StringScanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eos?&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 扫描字符串类型&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stringToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/&quot;[^&quot;]*&quot;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringToken&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringToken&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/\s+/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;next&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# 扫描symbol&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;symbolToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/\{|\}|\(|\)|\[|\]|\.|\,|\;|\+|\-|\*|\/|\&amp;amp;|\||\&amp;lt;|\&amp;gt;|\=|\~/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbolToken&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbolToken&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/\s+/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;next&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# 扫描其他tokenotherToken&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;otherToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan_until&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/\s+|\{|\}|\(|\)|\[|\]|\.|\,|\;|\+|\-|\*|\/|\&amp;amp;|\||\&amp;lt;|\&amp;gt;|\=|\~/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherToken&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;otherToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;otherToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherToken&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/\s+/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;next&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeTokensTofile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@tokenOutputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;tokens&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isKeyword&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;vi&quot;&gt;@tokenOutputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;keyword&amp;gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &amp;lt;/keyword&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;vi&quot;&gt;@tokenOutputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;stringConstant&amp;gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &amp;lt;/stringConstant&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isSymbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;convertSymbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;vi&quot;&gt;@tokenOutputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;symbol&amp;gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &amp;lt;/symbol&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;vi&quot;&gt;@tokenOutputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;integerConstant&amp;gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &amp;lt;/integerConstant&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;vi&quot;&gt;@tokenOutputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;identifier&amp;gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &amp;lt;/identifier&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;vi&quot;&gt;@tokenOutputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;/tokens&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@tokenOutputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isKeyword&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$KEYWORDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;include?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSymbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$SYMBOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;include?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/\d+/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/&quot;[^&quot;]*&quot;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;语法分析&quot;&gt;语法分析&lt;/h3&gt;

&lt;p&gt;我们的编译器很聪明，已经掌握了Jack的单词，接下来该学习语法了。语法分析的任务分析源程序类、方法的结构和每条语句的组成，分析的结果可以以抽象语法书的方式呈现，有的编译器会显示地构造出抽象语法树（用于进一步代码生成和错误报告），有的编译器则隐式地构造抽象语法树，即实时的生成代码和错误报告，不必在内存中维护整个树的数据结构，我们的编译器属于后者（但我们在实现的过程中仍会生成一个xml格式的抽象语法树，用于验证我们的语法分析程序是否正确）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gcayvbwgqfj310k0u0q82.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;上下文无关语法&quot;&gt;上下文无关语法&lt;/h4&gt;

&lt;p&gt;几乎所有的编程语言，以及大多数用于描述复杂文件的其他形式的语言，都可以使用上下文无关语法描述。&lt;strong&gt;上下文无关语法是一组递归式的，树状结构的语法规则，用来指定语法中的语法元素如何由更简单的元素组成&lt;/strong&gt;。上下文无关语法由终结符和非终结符两种元素构成，例如针对语句：while (count &amp;lt;= 100) { count ++; …}。while、(、count、++ 等符号都属于终结符，因为它们已经无法再继续分割，是上下文无关语法世界的原子级存在；同时终结符也可以互相组合成更高级的非终结符，例如 count &amp;lt;= 100 组成了一个expression，count ++; 组成了一个statement，多个statement又可以组成statementSequence等，expression、statement、statementSequence都属于非终结符，他们是可以再向下分割的。&lt;strong&gt;语法分析过程就是揭示程序中非终结符与非终结符，非终结符与终结符关系的过程&lt;/strong&gt;。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gcazdzfktbj31ac0sgq4h.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;jack的非终结符&quot;&gt;Jack的非终结符&lt;/h4&gt;

&lt;h4 id=&quot;递归下降算法&quot;&gt;递归下降算法&lt;/h4&gt;

&lt;h4 id=&quot;实现-1&quot;&gt;实现&lt;/h4&gt;

&lt;h3 id=&quot;语义分析和代码生成&quot;&gt;语义分析和代码生成&lt;/h3&gt;

&lt;h3 id=&quot;学到了什么&quot;&gt;学到了什么&lt;/h3&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">本篇实现Jack的编译器，也是从0到1构建计算机系列最复杂的一篇。编译器的实现本身是非常复杂的，但得益于Jack超简洁的语法，我们回避掉了很多复杂的问题。总体上Jack编译器是一个完整的编译器，它包括词法分析，语法分析，语义分析，代码生成等重要主题。 高级语言为什么能够被编译器理解和编译？因为高级语言是按照某种规则的语法（上下文无关语法）组织的，结构上层次化的语言。程序的每个类，每条语句都是符合某种语法规则的，所以我们反过来能够使用这些语法规则对其进行准确地解析，而我们日常使用的自然语言则不太受语法的严格的约束，所以用算法解释自然语言会更困难。 词法分析 程序基本上由语句组成，语句由单词和符号组成，每个单词或符号都有它要表达的含义：或是某种预算操作，或是某块内存的指针，或是指明当前语句是那种类型等等。编译器要做的第一件事情就是把语句拆解成一个个单词或符号，即词法分析。 Jack语法由一下五类单词构成： 1. 关键字：多用于指明当前语句的类型、属性。 2. 符号：算数逻辑运算符号、功能符号等。 3. 整型数字：0...32767 4. 字符创：“”括起来的字符串。 5. 字面量：类名、变量名等。 下面以一个程序举例： 实现 词法分析的过程并不复杂。先删除输入程序中的注释代码，然后通过使用Ruby的StringScanner工具和一些正则操作把源程序拆解成以上五种类型的单词即可。我们用JackTokenizer来实现Jack的词法分析： JackTokenizer接口设计： constructor：输入源程序，完成词法分析 hasMoreToken：是否还是token advance：token游标前进一位 tokenType：当前token类型 keyword：返回当前关键字类型的token symbol：返回当前symbol类型的token intValue：返回当前int类型的token stringValue：返回当前string类型的token indentifier：返回当前indentifier类型的token 词法分析关键代码如下： $KEYWORDS = [&quot;class&quot;, &quot;method&quot;, &quot;function&quot;, &quot;constructor&quot;, &quot;int&quot;, &quot;boolean&quot;, &quot;char&quot;, &quot;void&quot;, &quot;var&quot;, &quot;static&quot;, &quot;field&quot;, &quot;let&quot;, &quot;do&quot;, &quot;if&quot;, &quot;else&quot;, &quot;while&quot;, &quot;return&quot;, &quot;true&quot;, &quot;false&quot;, &quot;null&quot;, &quot;this&quot;] $SYMBOL = [&quot;{&quot;, &quot;}&quot;, &quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;.&quot;, &quot;,&quot;, &quot;;&quot;, &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;&amp;amp;&quot;, &quot;|&quot;, &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;=&quot;, &quot;~&quot;] class JackTokenizer def analysizeFile(file) #删除所有注释 file = file.gsub(/((?:\/\*(?:[^*]|(?:\*+[^*\/]))*\*+\/)|(?:\/\/.*))/, '').split.join(' ') #代码转成token @tokens = self.scanTextToToken(file) self.writeTokensTofile(@tokens) end def scanTextToToken(text) tokens = [] scanner = StringScanner.new(text) while !scanner.eos? # 扫描字符串类型 stringToken = scanner.scan(/&quot;[^&quot;]*&quot;/) if stringToken tokens &amp;lt;&amp;lt; stringToken scanner.scan(/\s+/) next end # 扫描symbol symbolToken = scanner.scan(/\{|\}|\(|\)|\[|\]|\.|\,|\;|\+|\-|\*|\/|\&amp;amp;|\||\&amp;lt;|\&amp;gt;|\=|\~/) if symbolToken tokens &amp;lt;&amp;lt; symbolToken scanner.scan(/\s+/) next end # 扫描其他tokenotherToken otherToken = scanner.scan_until(/\s+|\{|\}|\(|\)|\[|\]|\.|\,|\;|\+|\-|\*|\/|\&amp;amp;|\||\&amp;lt;|\&amp;gt;|\=|\~/) if otherToken otherToken = otherToken[0..otherToken.length-2] scanner.pos = scanner.pos-1 tokens &amp;lt;&amp;lt; otherToken scanner.scan(/\s+/) next end end return tokens end def writeTokensTofile(tokens) @tokenOutputFile.write(&quot;&amp;lt;tokens&amp;gt;\n&quot;) tokens.each do |token| if self.isKeyword(token) @tokenOutputFile.write(&quot;&amp;lt;keyword&amp;gt; #{token} &amp;lt;/keyword&amp;gt;\n&quot;) elsif self.isString(token) token = token[1..token.length-2] @tokenOutputFile.write(&quot;&amp;lt;stringConstant&amp;gt; #{token} &amp;lt;/stringConstant&amp;gt;\n&quot;) elsif self.isSymbol(token) token = self.convertSymbol(token) @tokenOutputFile.write(&quot;&amp;lt;symbol&amp;gt; #{token} &amp;lt;/symbol&amp;gt;\n&quot;) elsif self.isNumber(token) @tokenOutputFile.write(&quot;&amp;lt;integerConstant&amp;gt; #{token} &amp;lt;/integerConstant&amp;gt;\n&quot;) else @tokenOutputFile.write(&quot;&amp;lt;identifier&amp;gt; #{token} &amp;lt;/identifier&amp;gt;\n&quot;) end end @tokenOutputFile.write(&quot;&amp;lt;/tokens&amp;gt;\n&quot;) @tokenOutputFile.close() end def isKeyword(token) return $KEYWORDS.include? token end def isSymbol(token) return $SYMBOL.include? token end def isNumber(token) return token.match(/\d+/) end def isString(token) return token.match(/&quot;[^&quot;]*&quot;/) end end 语法分析 我们的编译器很聪明，已经掌握了Jack的单词，接下来该学习语法了。语法分析的任务分析源程序类、方法的结构和每条语句的组成，分析的结果可以以抽象语法书的方式呈现，有的编译器会显示地构造出抽象语法树（用于进一步代码生成和错误报告），有的编译器则隐式地构造抽象语法树，即实时的生成代码和错误报告，不必在内存中维护整个树的数据结构，我们的编译器属于后者（但我们在实现的过程中仍会生成一个xml格式的抽象语法树，用于验证我们的语法分析程序是否正确）。 上下文无关语法 几乎所有的编程语言，以及大多数用于描述复杂文件的其他形式的语言，都可以使用上下文无关语法描述。上下文无关语法是一组递归式的，树状结构的语法规则，用来指定语法中的语法元素如何由更简单的元素组成。上下文无关语法由终结符和非终结符两种元素构成，例如针对语句：while (count &amp;lt;= 100) { count ++; …}。while、(、count、++ 等符号都属于终结符，因为它们已经无法再继续分割，是上下文无关语法世界的原子级存在；同时终结符也可以互相组合成更高级的非终结符，例如 count &amp;lt;= 100 组成了一个expression，count ++; 组成了一个statement，多个statement又可以组成statementSequence等，expression、statement、statementSequence都属于非终结符，他们是可以再向下分割的。语法分析过程就是揭示程序中非终结符与非终结符，非终结符与终结符关系的过程。 Jack的非终结符 递归下降算法 实现 语义分析和代码生成 学到了什么 总结</summary></entry><entry><title type="html">从0到1构建计算机(8/10)–高级语言：Jack</title><link href="/2020/02/24/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80-Jack.html" rel="alternate" type="text/html" title="从0到1构建计算机(8/10)--高级语言：Jack" /><published>2020-02-24T00:00:00+08:00</published><updated>2020-02-24T00:00:00+08:00</updated><id>/2020/02/24/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80:Jack</id><content type="html" xml:base="/2020/02/24/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80-Jack.html">&lt;p&gt;本篇我们将设计一门高级语言：Jack。Jack是一门基于面向的对象的语言，具备现代高级语言的基本特性和风格，但是语法相对简单，且不支持继承等高级属性（其实Jack非常寒酸，只是支持了“对象”的功能）。本篇的内容非常简单，主要是介绍Jack的语法。&lt;/p&gt;

&lt;h3 id=&quot;hello-world&quot;&gt;Hello, World&lt;/h3&gt;

&lt;p&gt;众所周知，学习一门新语言的第一步，是写一个 Hello, World。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Jack程序要包含一个Main类，且包含main方法，这是程序的入口函数。&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello, World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//换行&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;精通jack&quot;&gt;精通Jack&lt;/h3&gt;

&lt;p&gt;学习完 Hello, World，下面让我们再花5分钟时间来精通Jack。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class 类名 {
	---------变量声明区-----------
	可以声明2种变量：
	1.成员变量：field
	2.静态变量：static

	变量类型有4种：
	1.基本类型：int, bool, char
	2.对象类型：自己定义的类
	-----------------------------

	--------方法声明区-------------
	可以声明3种类型的方法:
	1.构造函数：constructor
	2.类方法：function
	3.实例方式：method

	constructor 对象类型 new(入参列表) {
		......
		return this；	//constructor最后一定是return this，this是指向实例的指针
	}
	 
	function/method 返回类型（可以是void）方法名(入参列表) {
		var 类型 变量名  	//用var声明局部变量
		do xxx.xxx();  	//do语句：方法调用
		let a = b;	//let语句：赋值语句
		if else
		while
		return
	 }
	-----------------------------
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** 一个链表类，一个节点存储一个整数. */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;// 声明类&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// field语句：声明成员变量&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* 构造函数 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cdr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 参数列表&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// let语句：语句类型是赋值语句&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cdr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;       
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// return语句&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** getter. */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** 打印链表 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//method语句：类的实例方法&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// var语句：声明局部变量&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// this关键字：指向当前对象本身&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(~(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//while语句&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do语句：后面接一个方法调用&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** 销毁链表 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dispose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(~(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if语句&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dispose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deAlloc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 回收内存，调用操作系统方法&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// fuction语句：声明类方法&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;      
      &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dispose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OK，掌握了Jack后我们下一步的工作是实现Jack的编译器。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">本篇我们将设计一门高级语言：Jack。Jack是一门基于面向的对象的语言，具备现代高级语言的基本特性和风格，但是语法相对简单，且不支持继承等高级属性（其实Jack非常寒酸，只是支持了“对象”的功能）。本篇的内容非常简单，主要是介绍Jack的语法。 Hello, World 众所周知，学习一门新语言的第一步，是写一个 Hello, World。 class Main { function void main() { // Jack程序要包含一个Main类，且包含main方法，这是程序的入口函数。 do Output.printString(&quot;Hello, World&quot;); do Output.println(); //换行 return; } } 精通Jack 学习完 Hello, World，下面让我们再花5分钟时间来精通Jack。 class 类名 { ---------变量声明区----------- 可以声明2种变量： 1.成员变量：field 2.静态变量：static 变量类型有4种： 1.基本类型：int, bool, char 2.对象类型：自己定义的类 ----------------------------- --------方法声明区------------- 可以声明3种类型的方法: 1.构造函数：constructor 2.类方法：function 3.实例方式：method constructor 对象类型 new(入参列表) { ...... return this； //constructor最后一定是return this，this是指向实例的指针 } function/method 返回类型（可以是void）方法名(入参列表) { var 类型 变量名 //用var声明局部变量 do xxx.xxx(); //do语句：方法调用 let a = b; //let语句：赋值语句 if else while return } ----------------------------- } 举例： /** 一个链表类，一个节点存储一个整数. */ class List { // 声明类 field int data; // field语句：声明成员变量 field List next; /* 构造函数 */ constructor List new(int car, List cdr) { // 参数列表 let data = car; // let语句：语句类型是赋值语句 let next = cdr; return this; // return语句 } /** getter. */ method int getData() { return data; } method int getNext() { return next; } /** 打印链表 */ method void print() { //method语句：类的实例方法 var List current; // var语句：声明局部变量 let current = this; // this关键字：指向当前对象本身 while (~(current = null)) { //while语句 do Output.printInt(current.getData()); // do语句：后面接一个方法调用 do Output.printChar(32); let current = current.getNext(); } return; } /** 销毁链表 */ method void dispose() { if (~(next = null)) { // if语句 do next.dispose(); } do Memory.deAlloc(this); // 回收内存，调用操作系统方法 return; } } class Main { function void main() { // fuction语句：声明类方法 var List v; let v = List.new(5,null); let v = List.new(2,List.new(3,v)); do v.print(); do v.dispose(); return; } } OK，掌握了Jack后我们下一步的工作是实现Jack的编译器。</summary></entry><entry><title type="html">从0到1构建计算机(7/10)–实现一个虚拟机</title><link href="/2020/02/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E6%9C%BA.html" rel="alternate" type="text/html" title="从0到1构建计算机(7/10)--实现一个虚拟机" /><published>2020-02-21T00:00:00+08:00</published><updated>2020-02-21T00:00:00+08:00</updated><id>/2020/02/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E6%9C%BA</id><content type="html" xml:base="/2020/02/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E6%9C%BA.html">&lt;p&gt;计算机工作的本质就是对内存中的数据进行操作，因此只需要具备两种能力即可：(1)对内存的读和写；(2)用对数据进行算数逻辑运算。此外，支持指令跳转能大大提高计算机的可编程能力。直观上看，Hack具备了以上三项能力，我们上一篇也举例了如何实现1+2+…+100。但Hack和我们常用的CPU具备几百条指令集的能力还相去甚远，例如支持四则运算，对栈的操作，指针寄存器的使用，支持函数调用，处理入参和回参等。如何解决这些问题呢？我们需要在简单的Hack之上，再构建一个更加复杂，能力更强的虚拟计算机，这个虚拟机向上提供了一套新的操作指令，即虚拟机的字节码（在Hack中这套字节码更接近我们常用的CPU指令集），其中每条虚拟机指令都是通过封装汇编层一系列的汇编指令来实现的，在本篇中我们会再一次看到在计算机科学中“封装”的强大力量。&lt;/p&gt;

&lt;p&gt;虚拟机可能有多种解释，我们要实现的虚拟机是一种程序虚拟机（类似于Java虚拟机），主要是用来支持运行平台无关的计算机程序。其他概念的虚拟机还有系统虚拟机，完全虚拟一个操作系统出来，例如VMWare，iOS模拟器等。&lt;/p&gt;

&lt;h3 id=&quot;一个c程序&quot;&gt;一个C程序&lt;/h3&gt;
&lt;p&gt;我们来写一个简单的C程序：add。然后思考一下，如何把这段程序翻译成Hack上的汇编语言呢？如果仅仅是翻译这一个程序，貌似是可行的，但如果想要直接翻译一个复杂的C程序则是相当困难的，所以我们需要对Hack再进行一些扩展。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们把上面的C程序在Mac上编译成可执行文件，然后看一下这个它在x86_64架构下的汇编代码。我们看到它的汇编代码并不复杂，它被编译成了两个函数，然后通过一些的push, pop, mov, add, call, return等指令完成。这些指令就是Hack的虚拟机需要参考和实现的。从这一点上来看，Hack的虚拟机更接近我们常用的CPU。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc44fal8vmj30zj0u0tbs.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;stack&quot;&gt;Stack&lt;/h3&gt;

&lt;p&gt;无论是x86_64架构下的汇编指令，还是我们需要实现的Hack虚拟机，都需要支持四种基本操作：&lt;strong&gt;算数逻辑操作，内存访问操作，程序流程控制，函数调用&lt;/strong&gt;。想要方便的实现这些操作，我们需要借助一种常用的数据结构：堆栈（stack）。&lt;strong&gt;经证明，通过堆栈操作，能够实现任何数学或逻辑表达式；任何程序，无论用什么语言编写，都能够被翻译成等价的堆栈机语言&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;push--pop&quot;&gt;Push &amp;amp; Pop&lt;/h3&gt;

&lt;p&gt;既然是栈的使用，那肯定少不了Push和Pop操作。SP（Stack Pointer）指针是这两项操作的关键，&lt;strong&gt;SP指针实时地指向栈顶&lt;/strong&gt;：Push操作把一个数（可以是内存中的某个数）压入栈顶，然后SP加1（如果栈从上向下生长就减1）；Pop操作把栈顶的数弹出（可以弹出到某个内存地址），然后SP减1。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc49n0apfxj31a60oqdgh.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;内存划分&quot;&gt;内存划分&lt;/h3&gt;

&lt;p&gt;内存划分是Hack虚拟机中另一个重要主题。Hack的内存由32K的16位字组成，其中前16K是通用内存，后16K是I/O设备的内存映像。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       0-15：16个虚拟寄存器(Hack寄存器不够用了)
     16-255：静态变量区
   256-2047：栈
 2048-16383：堆
16384-24575：I/O内存映像
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;0-15位内存和寄存器的映射关系如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;SP&quot;=&amp;gt;&quot;000000000000000&quot;, &quot;LCL&quot;=&amp;gt;&quot;000000000000001&quot;, &quot;ARG&quot;=&amp;gt;&quot;000000000000010&quot;, &quot;THIS&quot;=&amp;gt;&quot;000000000000011&quot;, &quot;THAT&quot;=&amp;gt;&quot;000000000000100&quot;, 
&quot;R0&quot;=&amp;gt;&quot;000000000000000&quot;, &quot;R1&quot;=&amp;gt;&quot;000000000000001&quot;, &quot;R2&quot;=&amp;gt;&quot;000000000000010&quot;, &quot;R3&quot;=&amp;gt;&quot;000000000000011&quot;, 
&quot;R4&quot;=&amp;gt;&quot;000000000000100&quot;, &quot;R5&quot;=&amp;gt;&quot;000000000000101&quot;, &quot;R6&quot;=&amp;gt;&quot;000000000000110&quot;, &quot;R7&quot;=&amp;gt;&quot;000000000000111&quot;, 
&quot;R8&quot;=&amp;gt;&quot;000000000001000&quot;, &quot;R9&quot;=&amp;gt;&quot;000000000001001&quot;, &quot;R10&quot;=&amp;gt;&quot;000000000001010&quot;, &quot;R11&quot;=&amp;gt;&quot;000000000001011&quot;, 
&quot;R12&quot;=&amp;gt;&quot;000000000001100&quot;, &quot;R13&quot;=&amp;gt;&quot;000000000001101&quot;, &quot;R14&quot;=&amp;gt;&quot;000000000001110&quot;, &quot;R15&quot;=&amp;gt;&quot;000000000001111&quot;,
&quot;SCREEN&quot;=&amp;gt;&quot;100000000000000&quot;, &quot;KBD&quot;=&amp;gt;&quot;110000000000000&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虚拟机操纵8个独立的&lt;strong&gt;虚拟内存段&lt;/strong&gt;。在这里虚拟内存是一个很重要的技巧，内存段都有各自的用途，在程序执行过程中，每个函数都可以通过固定的几个指针（R0-R15）来访问这些内存段，看上去每个内存段都是它们独享的（有些是共享的），而不必关心他们的物理地址在哪里，是否会和其他函数冲突等。这本质上也是一种封装，这种封装向上提供一种标准的内存访问方式，向下了实现虚拟内存和物理内存的映射和管理（类似于操作系统中进程地址空间的映射）。这大大降低了虚拟机使用者的难度，把复杂的工作交给了虚拟机本身。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc4bnrpe9fj30wf0u0djx.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;p&gt;我们来看一下代码和内存段的关系。一个类被编译成一个.VM文件，其中包含了若干个函数实现f1, f2, f3。temp和const段是进程级别共享的；static段是类级别共享的；argument、local、this、that、pointer是函数级别的独享的，每个函数都有自己的这5个内存段，但每个函数访问它们的方式却是一致的（即通过R1-R5指针）&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc4c6ry36pj30zq0u0q44.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;内存访问命令&quot;&gt;内存访问命令&lt;/h3&gt;

&lt;p&gt;所有的内存段访问都通过2条命令实现：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;push segement index 		将segement[index]的值压入堆栈&lt;/li&gt;
  &lt;li&gt;pop  segement index 		将栈顶元素弹出，然后存入segement[index]&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push locol 0 		#把locol段第一个位置的值压入堆栈
push constant 123 	#把常数123压入堆栈
pop static 1 		#把栈顶元素弹出，存入static的第二个位置
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc51adti2gj31000gumxq.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;实现&quot;&gt;实现&lt;/h4&gt;

&lt;p&gt;push和pop指令的作用就是在栈顶内存和段内存之间互相搬运数值。SP指针用于标识栈顶内存，segement基地址+偏移量用于标识段内存，然后通过一系列寄存器和内存操作（利用A寄存器定位内存地址，D寄存器暂存数值等操作）实现这两个命令。&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writePushPop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;#实现push, pop命令&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'C_PUSH'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'constant'&lt;/span&gt; 		&lt;span class=&quot;c1&quot;&gt;#push const&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pushConstant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'C_PUSH'&lt;/span&gt; 							
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passArgsAddressToA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#A=段地址+偏移地址&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 			&lt;span class=&quot;c1&quot;&gt;#段内存的值存到D&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pushDtoStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;#push D到栈顶，sp+1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'C_POP'&lt;/span&gt; 							
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passArgsAddressToA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#A=段地址+偏移地址&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStackTopToD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;#栈顶的值存到D&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 			&lt;span class=&quot;c1&quot;&gt;#pop D到段内存&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=M-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 			&lt;span class=&quot;c1&quot;&gt;#sp减1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
		&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;	
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pushConstant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 		&lt;span class=&quot;c1&quot;&gt;#实现简单的push const&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pushDtoStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pushDtoStack&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;#把D寄存器的值push到栈顶，sp+1&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=M+1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStackTopToD&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;#把栈顶的值存到D寄存器，sp不变&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@R13&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#先把A的值暂存到R13，后面在还原A寄存器（保存现场）&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#取出值放入D&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@R13&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#恢复A&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;passArgsAddressToA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;#把内存地址存到A&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;static&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@source_file_name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#文件名+index作为static的符号&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 		&lt;span class=&quot;c1&quot;&gt;#D=index偏移量&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;temp&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@R5&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A+D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#A=temp地址+偏移量&lt;/span&gt;
		&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;执行了&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pointer&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@THIS&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A+D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#A=THIS+偏移量&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M+D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#A=段内存指针指向的段基地址+偏移量&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;算数逻辑运算命令&quot;&gt;算数逻辑运算命令&lt;/h3&gt;

&lt;p&gt;我们还需要实现若干一元或二元的算数&amp;amp;逻辑运算命令，包括二元加减法，两个数的比较，与或非，取反操作。在这里我们没有实现浮点数操作，也没有实现乘除法（后面我们会在软件的层面实现乘除法）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc56ao98qxj30w00k2js2.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;我们以下面的伪命令为例，看下如何利用栈来进行算数逻辑运算。运算x+y时，是一种以后缀表达式形式的运算：先把x入栈，sp+1；然后把y入栈，sp+1，然后计算加法，把结果值存入当前x的位置，sp-2。一元运算则更简单，运算-x时：先把x入栈，sp=1，然后取反，把结果值存入当前x的位置，sp-1。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// d=(2-x)*(y+5)
push 2
push x
sub
push y
push 5
add
mult
pop d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc56iuqmzsj319g0qu3zg.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;实现-1&quot;&gt;实现&lt;/h4&gt;

&lt;p&gt;在实现上主要思路是利用D寄存器配合SP指针，例如x+y：把y赋值给D，然后SP指向x，然后D=D+M，最后把D再赋值给SP指向的内存。&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;arithmetic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'add'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;#D=y&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=D+M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#D=x+y&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;#sp重置&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'sub'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M-D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#D=x-y&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'neg'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=-D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#M=-D&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'eq'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JEQ&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'gt'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JGT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'lt'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JLT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'and'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=D&amp;amp;M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#D=x&amp;amp;y&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'or'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=D|M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#D=x|y&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'not'&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passYtoD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=!D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;passYtoD&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;#y赋值给D寄存器&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;#sp-1后指向y&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#D=y&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resetSP&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D+1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#SP指针重置&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 			&lt;span class=&quot;c1&quot;&gt;#xy大小比较。&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M-D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#D=x-y&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@branchLabel_&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@branchIndex&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#0(0x0000)代表false&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@mergeLabel_&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@mergeIndex&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0;JMP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(branchLabel_&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@branchIndex&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;#-1(0xFFFF)代表true&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(mergeLabel_&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@mergeIndex&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@branchIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@branchIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@mergeIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@mergeIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;程序流程控制命令&quot;&gt;程序流程控制命令&lt;/h3&gt;

&lt;p&gt;计算机默认的执行顺序是线性的，程序流程控制这一节我们需要实现跳转功能和分支功能，即以下三个指令：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	label：用于标识指令地址
   goto label：无条件跳转到指令地址
if_goto label：先弹出并判断栈顶值，非0时跳转，否则线性执行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc69u6g16cj30vo0pywfi.jpg&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;实现-2&quot;&gt;实现&lt;/h4&gt;
&lt;p&gt;这三条指令的实现非常简单。原因是这里label扮演了重要的功能，由于下层的汇编器支持把label识别成指令地址，所以这里我们就不必再关心需要跳转的具体地址，省去了很多工作。这里我们看到只要下层设计封装的好，就会大大降低上层的实现难度。&lt;/p&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeGoto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0;JMP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;#无条件跳转&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeIf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=A-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;#栈顶值存到D&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=M-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;   	&lt;span class=&quot;c1&quot;&gt;#指针减1&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D;JNE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;#D非0时跳转&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;函数调用命令&quot;&gt;函数调用命令&lt;/h3&gt;

&lt;p&gt;函数调用是Hack虚拟机实现最复杂的一节。程序的执行过程就是一系列函数的调用过程，每个函数执行若干指令，操作函数中的参数变量、本地变量、静态变量三种变量。如果程序只有一个函数，那么这个工作并不复杂，因为参数变量、本地变量、静态变量都是静态的，提前分配好的，直接去使用就行了；但是如果程序是由多个函数组成的，那么这些变量在栈上就是动态的（参数变量、本地变量是动态的，静态变量还是静态的），它们的个数，分配的位置都是在动态变化的，处理起来就非常复杂。Hack虚拟机中函数调用部分的任务就是&lt;strong&gt;把这种动态再转变成静态&lt;/strong&gt;：当函数被调用时，为它构建一个私有空间（frame），把它封闭在一个“与世隔绝的自我世界”（该世界只包括已经初始化的参数变量、本地变量和一个空的栈空间），然后该函数在这个私有空间内直接自己的命令。从该函数的角度来看，它不感知其他函数的存在，就好像程序只有一个函数一样，又变成了静态。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc6ahg2sl5j31540cm74h.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;这一节我们需要实现以下3个指令：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f n：下面是一段函数名为f的代码，该函数有n个参数
    call f m：调用函数f，且调用前已将m个参数压入栈
      return：返回到调用者
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;函数的调用也是通过栈实现的，调用一个函数的时候，虚拟机为函数分配一块新的内存（frame），函数结束时，则回收这块内存。函数调用每加深一层，frame增长一块，每return一层，frame缩减一块，因此无限递归的函数会消耗无限的frame，导致栈内存溢出。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc6dpovpr7j31100nojss.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;p&gt;一个函数的调用和返回过程大致如下如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.调用函数将参数传递给被调用函数
2.保存调用函数的当前状态
3.跳转至被调用函数
4.为被调用函数分配局部变量空间并初始化
5.执行被调用函数指令序列
6.被调用函数将回参传递给调用函数
7.恢复调用函数的状态
8.回收被调用函数使用的内存空间
9.返回到之前调用函数的下一条指令执行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在函数调用时，栈上的内存使用和寄存器状态如下图。调用者在把函数入参push到栈上后，argument指针指向第一个参数；然后把函数的返回指令地址入栈；然后保存调用者的local、argument、this、that指针；然后根据被调用者局部变量数量为其分配内存空间，并把Local指针指向第一个局部变量；最后把SP指针指向栈顶，栈顶后面的内存空间都是被调用者的工作区。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc6e1ow0z0j30sm15e0tn.jpg&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;

&lt;p&gt;被调用者执行完毕后，把返回值pop到第一个入参的位置（如果返回类型为void，就再丢弃这个返回值）；恢复调用者的各种寄存器指针；然后通过重置SP指针来回收被调用者的内存（并没有修改被调用者frame内存的数据，只是重置了栈顶的位置，后面它们将会被新的函数覆盖）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc6e1rab8xj31tq0su76b.jpg&quot; width=&quot;1000&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;实现-3&quot;&gt;实现&lt;/h4&gt;
&lt;h5 id=&quot;call指令&quot;&gt;call指令&lt;/h5&gt;

&lt;p&gt;实现call指令，首先需要push调用者的返回地址，返回地址用“符号名+index”的方式标识，index的目的是防止返回地址重名，每翻译一次call指令后index需要+1；然后保存几个寄存器的状态；然后更新ARG和LCL，其中ARG=SP-n-5（参考上面的内存分布图），LCL = SP；最后执行goto跳转指令。因为调用函数return后还要返回goto指令的下一条指令标继续执行，所以需要在最后补充一个返回地址label。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;call f n 伪代码
--------------------
push return-address 	//返回地址入栈
push LCL 		//保存寄存器指针
push ARG
push THIS
push THAT
ARG = SP-n-5 		//重置ARG，第一个入参的位置是当前SP指针减n再减5
LCL = SP 		//重置LCL，第一个局部变量的位置是当前SP的位置
goto f 			//跳转到f
(return-address) 	//label标识，return后返回这里执行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;writePushPop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C_PUSH&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;constant&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;callLabel&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@callIndex&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;saveSegment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;LCL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;saveSegment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ARG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;saveSegment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;THIS&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;saveSegment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;THAT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;resetARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;resetLCL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;callJump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;callLabel&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@callIndex&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@callIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@callIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 保存寄存器的值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;saveSegment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 	
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pushDtoStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# ARG设置为SP指针向前移动step步&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resetARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 		
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=D-A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@ARG&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 重置LCL，第一个局部变量的位置是当前SP的位置&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resetLCL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 			
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@LCL&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 跳转执行&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;callJump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returnLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 	
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0;JMP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returnLabel&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;function指令&quot;&gt;function指令&lt;/h5&gt;

&lt;p&gt;function f m 指令比较简单。m 代表函数 f 中有 m 个局部变量，所以只需要连续push m 次0即可：开辟了 m 个内存空间，并将其初始化为0（我们日常使用的高级语言中，不同类型的变量占的字节数可能不同。Hack进行了简化，所有基本类型的变量都占用一个字的内存）。&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funtionName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funtionName&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#首先用（funtionName）来标识函数地址&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_i&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;writePushPop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C_PUSH&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;constant&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;return指令&quot;&gt;return指令&lt;/h5&gt;

&lt;p&gt;return指令首先需要把返回值pop到argument 0，即调用者的栈顶；然后重置一系列寄存器指针；最后跳转到返回地址。这里比较复杂的地方是如何安排各个数值的恢复顺序，因为顺序不当可能导致一些值被破坏。例如途中LCL被恢复了，导致最后取不到return的地址，我在这里的解决方案是先把return地址寄存到一个通用寄存器，后面再取出来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return 伪代码
--------------------
pop argument 0 	//pop返回值到argument 0
SP = ARG + 1 	//重置SP指针
restore THAT 	//恢复寄存器指针
restore THIS
restore ARG
restore LCL
goto RET 	//跳转到返回地址
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeReturn&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;saveReturnAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;writePushPop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C_POP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;argument&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;restoreSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;restoreSegement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;THAT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;restoreSegement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;THIS&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;restoreSegement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ARG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;restoreSegement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;LCL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gotoReturnAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 暂存return地址到R14（最后取return地址时需要用LCL-5来定位，而途中LCL会被修改，所以需要先把return地址暂存起来，R13被getStackTopToD占用了）&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;saveReturnAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@5&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@LCL&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M-D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@R14&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 重置SP指针&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;restoreSP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@ARG&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M+1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@SP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 恢复寄存器指针&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;restoreSegement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;THAT&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;THIS&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ARG&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;LCL&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@LCL&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M-D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;M=D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# return到上一级函数继续执行&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gotoReturnAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@R14&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A=M&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 从R14取出缓存的return地址&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0;JMP&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;vi&quot;&gt;@sam_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;从中学到什么&quot;&gt;从中学到什么&lt;/h3&gt;

&lt;p&gt;通过本篇的实践，我们掌握了CPU在栈上的工作方式，尤其是了解了栈对函数调用的支持。这些指令和我们常用的CPU汇编指令更加接近（包括某些寄存器的作用），对我们进一步学习理解x86或ARM汇编指令，甚至C语言等高级语言会有很大帮助。&lt;/p&gt;

&lt;p&gt;我们看到了程序虚拟机的工作方式，它本质上是一个翻译机：向上提供一种新的语言接口，然后把虚拟机语言翻译成所在平台的计算机语言，因此我们也可以在其它平台上实现Hack虚拟机，只不过翻译的实现细节会发生改变。Hack虚拟机和Java虚拟机本质上相同的，Hack虚拟机是一个纯的静态翻译器，而Java虚拟机作为一个进程运行，是动态翻译的，此外Java虚拟机还有类加载器，内存回收等强大功能。&lt;/p&gt;

&lt;p&gt;我们也学到了一些重要的编程思想：如果在本层实现逻辑过于复杂，可以考虑把一些复杂的逻辑抽象出来，交给下层来实现，即把复杂的问题分层化。尽量让动态的，变化的，需要被编程的，面向程序员的部分变得标准和简单，把复杂的逻辑封装在静态的，底层的，不面向程序员的地方。目的是让开发者能把主要精力放在解决问题的算法之上，而不用考虑让人头疼的底层的实现细节。这是一个程序员的重要基本功。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc7ccatyh7j30z00sg45t.jpg&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;next&quot;&gt;NEXT&lt;/h3&gt;

&lt;p&gt;Hack虚拟机更加接近一个真实的计算机了，它可以支持一系列函数在虚拟机上的运算和互相调用。下一篇我们将设计一门简洁的面向对象语言，并实现它的编译器，然后我们终于可以使用高级语言在Hack上编写程序了。&lt;/p&gt;

&lt;p&gt;本篇完整实现放在了:&lt;a href=&quot;https://github.com/guosainpu/Nand2Tetris&quot;&gt;github&lt;/a&gt;&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">计算机工作的本质就是对内存中的数据进行操作，因此只需要具备两种能力即可：(1)对内存的读和写；(2)用对数据进行算数逻辑运算。此外，支持指令跳转能大大提高计算机的可编程能力。直观上看，Hack具备了以上三项能力，我们上一篇也举例了如何实现1+2+…+100。但Hack和我们常用的CPU具备几百条指令集的能力还相去甚远，例如支持四则运算，对栈的操作，指针寄存器的使用，支持函数调用，处理入参和回参等。如何解决这些问题呢？我们需要在简单的Hack之上，再构建一个更加复杂，能力更强的虚拟计算机，这个虚拟机向上提供了一套新的操作指令，即虚拟机的字节码（在Hack中这套字节码更接近我们常用的CPU指令集），其中每条虚拟机指令都是通过封装汇编层一系列的汇编指令来实现的，在本篇中我们会再一次看到在计算机科学中“封装”的强大力量。 虚拟机可能有多种解释，我们要实现的虚拟机是一种程序虚拟机（类似于Java虚拟机），主要是用来支持运行平台无关的计算机程序。其他概念的虚拟机还有系统虚拟机，完全虚拟一个操作系统出来，例如VMWare，iOS模拟器等。 一个C程序 我们来写一个简单的C程序：add。然后思考一下，如何把这段程序翻译成Hack上的汇编语言呢？如果仅仅是翻译这一个程序，貌似是可行的，但如果想要直接翻译一个复杂的C程序则是相当困难的，所以我们需要对Hack再进行一些扩展。 int add(int a, int b) { int result; result = a + b; return result; } int main(int argc, char *argv[]) { int a,b,result; a = 1; b = 2; result = add(a,b); return 0; } 我们把上面的C程序在Mac上编译成可执行文件，然后看一下这个它在x86_64架构下的汇编代码。我们看到它的汇编代码并不复杂，它被编译成了两个函数，然后通过一些的push, pop, mov, add, call, return等指令完成。这些指令就是Hack的虚拟机需要参考和实现的。从这一点上来看，Hack的虚拟机更接近我们常用的CPU。 Stack 无论是x86_64架构下的汇编指令，还是我们需要实现的Hack虚拟机，都需要支持四种基本操作：算数逻辑操作，内存访问操作，程序流程控制，函数调用。想要方便的实现这些操作，我们需要借助一种常用的数据结构：堆栈（stack）。经证明，通过堆栈操作，能够实现任何数学或逻辑表达式；任何程序，无论用什么语言编写，都能够被翻译成等价的堆栈机语言。 Push &amp;amp; Pop 既然是栈的使用，那肯定少不了Push和Pop操作。SP（Stack Pointer）指针是这两项操作的关键，SP指针实时地指向栈顶：Push操作把一个数（可以是内存中的某个数）压入栈顶，然后SP加1（如果栈从上向下生长就减1）；Pop操作把栈顶的数弹出（可以弹出到某个内存地址），然后SP减1。 内存划分 内存划分是Hack虚拟机中另一个重要主题。Hack的内存由32K的16位字组成，其中前16K是通用内存，后16K是I/O设备的内存映像。 0-15：16个虚拟寄存器(Hack寄存器不够用了) 16-255：静态变量区 256-2047：栈 2048-16383：堆 16384-24575：I/O内存映像 0-15位内存和寄存器的映射关系如下： &quot;SP&quot;=&amp;gt;&quot;000000000000000&quot;, &quot;LCL&quot;=&amp;gt;&quot;000000000000001&quot;, &quot;ARG&quot;=&amp;gt;&quot;000000000000010&quot;, &quot;THIS&quot;=&amp;gt;&quot;000000000000011&quot;, &quot;THAT&quot;=&amp;gt;&quot;000000000000100&quot;, &quot;R0&quot;=&amp;gt;&quot;000000000000000&quot;, &quot;R1&quot;=&amp;gt;&quot;000000000000001&quot;, &quot;R2&quot;=&amp;gt;&quot;000000000000010&quot;, &quot;R3&quot;=&amp;gt;&quot;000000000000011&quot;, &quot;R4&quot;=&amp;gt;&quot;000000000000100&quot;, &quot;R5&quot;=&amp;gt;&quot;000000000000101&quot;, &quot;R6&quot;=&amp;gt;&quot;000000000000110&quot;, &quot;R7&quot;=&amp;gt;&quot;000000000000111&quot;, &quot;R8&quot;=&amp;gt;&quot;000000000001000&quot;, &quot;R9&quot;=&amp;gt;&quot;000000000001001&quot;, &quot;R10&quot;=&amp;gt;&quot;000000000001010&quot;, &quot;R11&quot;=&amp;gt;&quot;000000000001011&quot;, &quot;R12&quot;=&amp;gt;&quot;000000000001100&quot;, &quot;R13&quot;=&amp;gt;&quot;000000000001101&quot;, &quot;R14&quot;=&amp;gt;&quot;000000000001110&quot;, &quot;R15&quot;=&amp;gt;&quot;000000000001111&quot;, &quot;SCREEN&quot;=&amp;gt;&quot;100000000000000&quot;, &quot;KBD&quot;=&amp;gt;&quot;110000000000000&quot; 虚拟机操纵8个独立的虚拟内存段。在这里虚拟内存是一个很重要的技巧，内存段都有各自的用途，在程序执行过程中，每个函数都可以通过固定的几个指针（R0-R15）来访问这些内存段，看上去每个内存段都是它们独享的（有些是共享的），而不必关心他们的物理地址在哪里，是否会和其他函数冲突等。这本质上也是一种封装，这种封装向上提供一种标准的内存访问方式，向下了实现虚拟内存和物理内存的映射和管理（类似于操作系统中进程地址空间的映射）。这大大降低了虚拟机使用者的难度，把复杂的工作交给了虚拟机本身。 我们来看一下代码和内存段的关系。一个类被编译成一个.VM文件，其中包含了若干个函数实现f1, f2, f3。temp和const段是进程级别共享的；static段是类级别共享的；argument、local、this、that、pointer是函数级别的独享的，每个函数都有自己的这5个内存段，但每个函数访问它们的方式却是一致的（即通过R1-R5指针） 内存访问命令 所有的内存段访问都通过2条命令实现： push segement index 将segement[index]的值压入堆栈 pop segement index 将栈顶元素弹出，然后存入segement[index] push locol 0 #把locol段第一个位置的值压入堆栈 push constant 123 #把常数123压入堆栈 pop static 1 #把栈顶元素弹出，存入static的第二个位置 实现 push和pop指令的作用就是在栈顶内存和段内存之间互相搬运数值。SP指针用于标识栈顶内存，segement基地址+偏移量用于标识段内存，然后通过一系列寄存器和内存操作（利用A寄存器定位内存地址，D寄存器暂存数值等操作）实现这两个命令。 def writePushPop(command, segment, index) #实现push, pop命令 asm_cmd = '' segment = @table[&quot;#{segment}&quot;] if command == 'C_PUSH' &amp;amp;&amp;amp; segment =='constant' #push const asm_cmd &amp;lt;&amp;lt; pushConstant(index) elsif command == 'C_PUSH' asm_cmd &amp;lt;&amp;lt; passArgsAddressToA(segment, index) #A=段地址+偏移地址 asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot; &amp;lt;&amp;lt; &quot;\n&quot; #段内存的值存到D asm_cmd &amp;lt;&amp;lt; pushDtoStack() #push D到栈顶，sp+1 elsif command == 'C_POP' asm_cmd &amp;lt;&amp;lt; passArgsAddressToA(segment, index) #A=段地址+偏移地址 asm_cmd &amp;lt;&amp;lt; getStackTopToD() #栈顶的值存到D asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; #pop D到段内存 asm_cmd &amp;lt;&amp;lt; &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=M-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; #sp减1 end if asm_cmd.length &amp;gt; 0 @sam_file.write(asm_cmd) end end def pushConstant(const) #实现简单的push const asm_cmd = &quot;@#{const}\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=A&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; pushDtoStack() return asm_cmd end def pushDtoStack #把D寄存器的值push到栈顶，sp+1 asm_cmd = &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=M+1&quot;&amp;lt;&amp;lt; &quot;\n&quot; return asm_cmd end def getStackTopToD #把栈顶的值存到D寄存器，sp不变 asm_cmd = &quot;D=A&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@R13&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; #先把A的值暂存到R13，后面在还原A寄存器（保存现场） asm_cmd &amp;lt;&amp;lt; &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; #取出值放入D asm_cmd &amp;lt;&amp;lt; &quot;@R13&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; #恢复A return asm_cmd end def passArgsAddressToA(segment, index) #把内存地址存到A asm_cmd = '' if segment == &quot;static&quot; asm_cmd &amp;lt;&amp;lt; &quot;@#{@source_file_name}.#{index}&quot;&amp;lt;&amp;lt; &quot;\n&quot; #文件名+index作为static的符号 return asm_cmd end asm_cmd &amp;lt;&amp;lt; &quot;@#{index}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=A&quot;&amp;lt;&amp;lt; &quot;\n&quot; #D=index偏移量 if segment == &quot;temp&quot; asm_cmd &amp;lt;&amp;lt; &quot;@R5&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=A+D&quot;&amp;lt;&amp;lt; &quot;\n&quot; #A=temp地址+偏移量 puts &quot;执行了#{segment}&quot; elsif segment == &quot;pointer&quot; asm_cmd &amp;lt;&amp;lt; &quot;@THIS&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=A+D&quot;&amp;lt;&amp;lt; &quot;\n&quot; #A=THIS+偏移量 else asm_cmd &amp;lt;&amp;lt; &quot;@#{segment}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M+D&quot;&amp;lt;&amp;lt; &quot;\n&quot; #A=段内存指针指向的段基地址+偏移量 end return asm_cmd end 算数逻辑运算命令 我们还需要实现若干一元或二元的算数&amp;amp;逻辑运算命令，包括二元加减法，两个数的比较，与或非，取反操作。在这里我们没有实现浮点数操作，也没有实现乘除法（后面我们会在软件的层面实现乘除法）。 我们以下面的伪命令为例，看下如何利用栈来进行算数逻辑运算。运算x+y时，是一种以后缀表达式形式的运算：先把x入栈，sp+1；然后把y入栈，sp+1，然后计算加法，把结果值存入当前x的位置，sp-2。一元运算则更简单，运算-x时：先把x入栈，sp=1，然后取反，把结果值存入当前x的位置，sp-1。 // d=(2-x)*(y+5) push 2 push x sub push y push 5 add mult pop d 实现 在实现上主要思路是利用D寄存器配合SP指针，例如x+y：把y赋值给D，然后SP指向x，然后D=D+M，最后把D再赋值给SP指向的内存。 def arithmetic(cmd) asm_cmd = &quot;&quot; if cmd == 'add' asm_cmd &amp;lt;&amp;lt; passYtoD() #D=y asm_cmd &amp;lt;&amp;lt; &quot;A=A-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=D+M&quot;&amp;lt;&amp;lt; &quot;\n&quot; #D=x+y asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; resetSP() #sp重置 elsif cmd == 'sub' asm_cmd &amp;lt;&amp;lt; passYtoD() asm_cmd &amp;lt;&amp;lt; &quot;A=A-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M-D&quot;&amp;lt;&amp;lt; &quot;\n&quot; #D=x-y asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; resetSP() elsif cmd == 'neg' asm_cmd &amp;lt;&amp;lt; passYtoD() asm_cmd &amp;lt;&amp;lt; &quot;M=-D&quot;&amp;lt;&amp;lt; &quot;\n&quot; #M=-D asm_cmd &amp;lt;&amp;lt; resetSP() elsif cmd == 'eq' asm_cmd &amp;lt;&amp;lt; passYtoD() asm_cmd &amp;lt;&amp;lt; compare(&quot;JEQ&quot;) asm_cmd &amp;lt;&amp;lt; resetSP() elsif cmd == 'gt' asm_cmd &amp;lt;&amp;lt; passYtoD() asm_cmd &amp;lt;&amp;lt; compare(&quot;JGT&quot;) asm_cmd &amp;lt;&amp;lt; resetSP() elsif cmd == 'lt' asm_cmd &amp;lt;&amp;lt; passYtoD() asm_cmd &amp;lt;&amp;lt; compare(&quot;JLT&quot;) asm_cmd &amp;lt;&amp;lt; resetSP() elsif cmd == 'and' asm_cmd &amp;lt;&amp;lt; passYtoD() asm_cmd &amp;lt;&amp;lt; &quot;A=A-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=D&amp;amp;M&quot;&amp;lt;&amp;lt; &quot;\n&quot; #D=x&amp;amp;y asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; resetSP() elsif cmd == 'or' asm_cmd &amp;lt;&amp;lt; passYtoD() asm_cmd &amp;lt;&amp;lt; &quot;A=A-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=D|M&quot;&amp;lt;&amp;lt; &quot;\n&quot; #D=x|y asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; resetSP() elsif cmd == 'not' asm_cmd &amp;lt;&amp;lt; passYtoD() asm_cmd &amp;lt;&amp;lt; &quot;M=!D&quot;&amp;lt;&amp;lt; &quot;\n&quot; end return asm_cmd end def passYtoD #y赋值给D寄存器 asm_cmd = &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=A-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; #sp-1后指向y asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; #D=y return asm_cmd end def resetSP asm_cmd = &quot;D=A&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D+1&quot;&amp;lt;&amp;lt; &quot;\n&quot; #SP指针重置 return asm_cmd end def compare(cmd) #xy大小比较。 asm_cmd = &quot;A=A-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M-D&quot;&amp;lt;&amp;lt; &quot;\n&quot; #D=x-y asm_cmd &amp;lt;&amp;lt; &quot;@branchLabel_#{@branchIndex}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D;#{cmd}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=0&quot;&amp;lt;&amp;lt; &quot;\n&quot; #0(0x0000)代表false asm_cmd &amp;lt;&amp;lt; &quot;@mergeLabel_#{@mergeIndex}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;0;JMP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;(branchLabel_#{@branchIndex})&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; #-1(0xFFFF)代表true asm_cmd &amp;lt;&amp;lt; &quot;(mergeLabel_#{@mergeIndex})&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=A-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; @branchIndex = @branchIndex + 1 @mergeIndex = @mergeIndex + 1 return asm_cmd end 程序流程控制命令 计算机默认的执行顺序是线性的，程序流程控制这一节我们需要实现跳转功能和分支功能，即以下三个指令： label：用于标识指令地址 goto label：无条件跳转到指令地址 if_goto label：先弹出并判断栈顶值，非0时跳转，否则线性执行 实现 这三条指令的实现非常简单。原因是这里label扮演了重要的功能，由于下层的汇编器支持把label识别成指令地址，所以这里我们就不必再关心需要跳转的具体地址，省去了很多工作。这里我们看到只要下层设计封装的好，就会大大降低上层的实现难度。 def writeLabel(label) asm_cmd = &quot;(#{label})&quot;&amp;lt;&amp;lt; &quot;\n&quot; @sam_file.write(asm_cmd) end def writeGoto(label) asm_cmd = &quot;@#{label}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;0;JMP&quot;&amp;lt;&amp;lt; &quot;\n&quot; #无条件跳转 @sam_file.write(asm_cmd) end def writeIf(label) asm_cmd = &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=A-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; #栈顶值存到D asm_cmd &amp;lt;&amp;lt; &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=M-1&quot;&amp;lt;&amp;lt; &quot;\n&quot; #指针减1 asm_cmd &amp;lt;&amp;lt; &quot;@#{label}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D;JNE&quot;&amp;lt;&amp;lt; &quot;\n&quot; #D非0时跳转 @sam_file.write(asm_cmd) end 函数调用命令 函数调用是Hack虚拟机实现最复杂的一节。程序的执行过程就是一系列函数的调用过程，每个函数执行若干指令，操作函数中的参数变量、本地变量、静态变量三种变量。如果程序只有一个函数，那么这个工作并不复杂，因为参数变量、本地变量、静态变量都是静态的，提前分配好的，直接去使用就行了；但是如果程序是由多个函数组成的，那么这些变量在栈上就是动态的（参数变量、本地变量是动态的，静态变量还是静态的），它们的个数，分配的位置都是在动态变化的，处理起来就非常复杂。Hack虚拟机中函数调用部分的任务就是把这种动态再转变成静态：当函数被调用时，为它构建一个私有空间（frame），把它封闭在一个“与世隔绝的自我世界”（该世界只包括已经初始化的参数变量、本地变量和一个空的栈空间），然后该函数在这个私有空间内直接自己的命令。从该函数的角度来看，它不感知其他函数的存在，就好像程序只有一个函数一样，又变成了静态。 这一节我们需要实现以下3个指令： function f n：下面是一段函数名为f的代码，该函数有n个参数 call f m：调用函数f，且调用前已将m个参数压入栈 return：返回到调用者 函数的调用也是通过栈实现的，调用一个函数的时候，虚拟机为函数分配一块新的内存（frame），函数结束时，则回收这块内存。函数调用每加深一层，frame增长一块，每return一层，frame缩减一块，因此无限递归的函数会消耗无限的frame，导致栈内存溢出。 一个函数的调用和返回过程大致如下如下： 1.调用函数将参数传递给被调用函数 2.保存调用函数的当前状态 3.跳转至被调用函数 4.为被调用函数分配局部变量空间并初始化 5.执行被调用函数指令序列 6.被调用函数将回参传递给调用函数 7.恢复调用函数的状态 8.回收被调用函数使用的内存空间 9.返回到之前调用函数的下一条指令执行 在函数调用时，栈上的内存使用和寄存器状态如下图。调用者在把函数入参push到栈上后，argument指针指向第一个参数；然后把函数的返回指令地址入栈；然后保存调用者的local、argument、this、that指针；然后根据被调用者局部变量数量为其分配内存空间，并把Local指针指向第一个局部变量；最后把SP指针指向栈顶，栈顶后面的内存空间都是被调用者的工作区。 被调用者执行完毕后，把返回值pop到第一个入参的位置（如果返回类型为void，就再丢弃这个返回值）；恢复调用者的各种寄存器指针；然后通过重置SP指针来回收被调用者的内存（并没有修改被调用者frame内存的数据，只是重置了栈顶的位置，后面它们将会被新的函数覆盖）。 实现 call指令 实现call指令，首先需要push调用者的返回地址，返回地址用“符号名+index”的方式标识，index的目的是防止返回地址重名，每翻译一次call指令后index需要+1；然后保存几个寄存器的状态；然后更新ARG和LCL，其中ARG=SP-n-5（参考上面的内存分布图），LCL = SP；最后执行goto跳转指令。因为调用函数return后还要返回goto指令的下一条指令标继续执行，所以需要在最后补充一个返回地址label。 call f n 伪代码 -------------------- push return-address //返回地址入栈 push LCL //保存寄存器指针 push ARG push THIS push THAT ARG = SP-n-5 //重置ARG，第一个入参的位置是当前SP指针减n再减5 LCL = SP //重置LCL，第一个局部变量的位置是当前SP的位置 goto f //跳转到f (return-address) //label标识，return后返回这里执行 def writeCall(functionName, numArgs) writePushPop(&quot;C_PUSH&quot;, &quot;constant&quot;, &quot;callLabel#{@callIndex}&quot;) saveSegment(&quot;LCL&quot;) saveSegment(&quot;ARG&quot;) saveSegment(&quot;THIS&quot;) saveSegment(&quot;THAT&quot;) resetARG(5+numArgs.to_i) resetLCL() callJump(functionName, &quot;callLabel#{@callIndex}&quot;) @callIndex = @callIndex + 1 end # 保存寄存器的值 def saveSegment(segment) asm_cmd = &quot;@#{segment}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; pushDtoStack() @sam_file.write(asm_cmd) end # ARG设置为SP指针向前移动step步 def resetARG(steps) asm_cmd = &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@#{steps}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=D-A&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@ARG&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; @sam_file.write(asm_cmd) end # 重置LCL，第一个局部变量的位置是当前SP的位置 def resetLCL() asm_cmd = &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@LCL&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; @sam_file.write(asm_cmd) end # 跳转执行 def callJump(functionName, returnLabel) asm_cmd = &quot;@#{functionName}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;0;JMP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;(#{returnLabel})&quot;&amp;lt;&amp;lt; &quot;\n&quot; @sam_file.write(asm_cmd) end function指令 function f m 指令比较简单。m 代表函数 f 中有 m 个局部变量，所以只需要连续push m 次0即可：开辟了 m 个内存空间，并将其初始化为0（我们日常使用的高级语言中，不同类型的变量占的字节数可能不同。Hack进行了简化，所有基本类型的变量都占用一个字的内存）。 def writeFunction(funtionName, numArgs) asm_cmd = &quot;(#{funtionName})&quot;&amp;lt;&amp;lt; &quot;\n&quot; #首先用（funtionName）来标识函数地址 @sam_file.write(asm_cmd) index = 0 while index &amp;lt; numArgs.to_i writePushPop(&quot;C_PUSH&quot;, &quot;constant&quot;, &quot;0&quot;) index = index + 1 end end return指令 return指令首先需要把返回值pop到argument 0，即调用者的栈顶；然后重置一系列寄存器指针；最后跳转到返回地址。这里比较复杂的地方是如何安排各个数值的恢复顺序，因为顺序不当可能导致一些值被破坏。例如途中LCL被恢复了，导致最后取不到return的地址，我在这里的解决方案是先把return地址寄存到一个通用寄存器，后面再取出来。 return 伪代码 -------------------- pop argument 0 //pop返回值到argument 0 SP = ARG + 1 //重置SP指针 restore THAT //恢复寄存器指针 restore THIS restore ARG restore LCL goto RET //跳转到返回地址 def writeReturn saveReturnAddress() writePushPop(&quot;C_POP&quot;, &quot;argument&quot;, &quot;0&quot;) restoreSP() restoreSegement(&quot;THAT&quot;) restoreSegement(&quot;THIS&quot;) restoreSegement(&quot;ARG&quot;) restoreSegement(&quot;LCL&quot;) gotoReturnAddress() end # 暂存return地址到R14（最后取return地址时需要用LCL-5来定位，而途中LCL会被修改，所以需要先把return地址暂存起来，R13被getStackTopToD占用了） def saveReturnAddress() asm_cmd = &quot;@5&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=A&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@LCL&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M-D&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@R14&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; @sam_file.write(asm_cmd) end # 重置SP指针 def restoreSP() asm_cmd = &quot;@ARG&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M+1&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@SP&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; @sam_file.write(asm_cmd) end # 恢复寄存器指针 def restoreSegement(segment) table = {&quot;THAT&quot;=&amp;gt;&quot;1&quot;, &quot;THIS&quot;=&amp;gt;&quot;2&quot;, &quot;ARG&quot;=&amp;gt;&quot;3&quot;, &quot;LCL&quot;=&amp;gt;&quot;4&quot;} asm_cmd = &quot;@#{table[segment]}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=A&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@LCL&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M-D&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;D=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;@#{segment}&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;M=D&quot;&amp;lt;&amp;lt; &quot;\n&quot; @sam_file.write(asm_cmd) end # return到上一级函数继续执行 def gotoReturnAddress() asm_cmd = &quot;@R14&quot;&amp;lt;&amp;lt; &quot;\n&quot; asm_cmd &amp;lt;&amp;lt; &quot;A=M&quot;&amp;lt;&amp;lt; &quot;\n&quot; # 从R14取出缓存的return地址 asm_cmd &amp;lt;&amp;lt; &quot;0;JMP&quot;&amp;lt;&amp;lt; &quot;\n&quot; @sam_file.write(asm_cmd) end 从中学到什么 通过本篇的实践，我们掌握了CPU在栈上的工作方式，尤其是了解了栈对函数调用的支持。这些指令和我们常用的CPU汇编指令更加接近（包括某些寄存器的作用），对我们进一步学习理解x86或ARM汇编指令，甚至C语言等高级语言会有很大帮助。 我们看到了程序虚拟机的工作方式，它本质上是一个翻译机：向上提供一种新的语言接口，然后把虚拟机语言翻译成所在平台的计算机语言，因此我们也可以在其它平台上实现Hack虚拟机，只不过翻译的实现细节会发生改变。Hack虚拟机和Java虚拟机本质上相同的，Hack虚拟机是一个纯的静态翻译器，而Java虚拟机作为一个进程运行，是动态翻译的，此外Java虚拟机还有类加载器，内存回收等强大功能。 我们也学到了一些重要的编程思想：如果在本层实现逻辑过于复杂，可以考虑把一些复杂的逻辑抽象出来，交给下层来实现，即把复杂的问题分层化。尽量让动态的，变化的，需要被编程的，面向程序员的部分变得标准和简单，把复杂的逻辑封装在静态的，底层的，不面向程序员的地方。目的是让开发者能把主要精力放在解决问题的算法之上，而不用考虑让人头疼的底层的实现细节。这是一个程序员的重要基本功。 NEXT Hack虚拟机更加接近一个真实的计算机了，它可以支持一系列函数在虚拟机上的运算和互相调用。下一篇我们将设计一门简洁的面向对象语言，并实现它的编译器，然后我们终于可以使用高级语言在Hack上编写程序了。 本篇完整实现放在了:github</summary></entry><entry><title type="html">从0到1构建计算机(6/10)–汇编语言与汇编器</title><link href="/2020/02/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%B1%87%E7%BC%96%E5%99%A8.html" rel="alternate" type="text/html" title="从0到1构建计算机(6/10)--汇编语言与汇编器" /><published>2020-02-19T00:00:00+08:00</published><updated>2020-02-19T00:00:00+08:00</updated><id>/2020/02/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%B1%87%E7%BC%96%E5%99%A8</id><content type="html" xml:base="/2020/02/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%B1%87%E7%BC%96%E5%99%A8.html">&lt;p&gt;前一篇我们完成了Hack平台的硬件部分，本篇开始我们进入到软件的部分。相比较而言，软件部分更加复杂，需要花更多时间来实现和调试。软件部分的第一层就是汇编语言和汇编器，本篇我们将定义Hack的汇编语言，并编写对应的汇编器&lt;/p&gt;

&lt;h3 id=&quot;汇编语言和汇编器&quot;&gt;汇编语言和汇编器&lt;/h3&gt;

&lt;p&gt;汇编语言是机器语言的符号表示，相比于机器语言，汇编语言更接近于自然语言，便于我们阅读和记忆。汇编语言和机器语言在表述上的一致性是非常高的，绝大多数情况下两种指令是一一对应的，例如：1000100111011000对应mov ax,bx，把机器指令拆成3段，其中前8位代表mov，中间4位代表寄存器ax，最后四位代表寄存器bx。此外，我们还可以在汇编语言中用引用一些符号，用于代表某些数值（例如内存地址，指令地址等），这可以把我们从处理这些繁琐的数值的工作中解放出来（例如我们用符号i来代表一块内存地址，然后不用去记忆地址具体的值是多少，分配在什么位置，是否和其他地址冲突等），提高代码的编写效率。&lt;/p&gt;

&lt;p&gt;汇编器负责把汇编语言翻译成机器语言。因为汇编语言和机器语言的高度一致性，所以实现汇编器是比较简单的。唯一的难点可能就在于上面所提到的如何把一些符号和它们所对应的数值联系起来，即符号解析(symbol resolution)的过程。&lt;/p&gt;

&lt;h3 id=&quot;hack的汇编语言设计&quot;&gt;Hack的汇编语言设计&lt;/h3&gt;

&lt;p&gt;想要设计一门汇编语言，那么必须要参考它的机器语言。Hack的机器指令集过于简单，只有A、C两种命令，所以相应的它的汇编语言也很简单😂。&lt;/p&gt;

&lt;h4 id=&quot;a指令&quot;&gt;A指令&lt;/h4&gt;
&lt;p&gt;我们copy一些上一篇文章的内容：A指令，即Address指令。它的功能很简单，就是把一个数值传送到CPU中的A寄存器即可，多数情况下这个数字后续会当做地址使用，用于定位内存中的存储单元。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh0rj8yj6j30we0480sn.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;我们定义A指令的汇编指令格式是：&lt;strong&gt;@value&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;value可以是一个立即数。这种格式是两种语言的天然映射。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@3  //把数字3传送到A寄存器
@5  //把数字5传送到A寄存器
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;value也可以是一个符号（变量名）&lt;/p&gt;

&lt;p&gt;我们支持把符号当做数值代入，这更像我们在高级语言中编码的方式。例如@number，它的含义是：把变量number的首地址传送到A寄存器，number的首地址可能是1000或者2000，我们并不去关心它。如果不支持@+符号这种命令，我们该怎么编写Hack的A汇编指令呢？我们可能需要先梳理出该程序需要几个变量，例如i，j，k，然后画一个表格，安排一下i，j，k的地址，并保证他们不互相冲突，然后用@+立即数的方式编写，每次遇到需要传入变量地址的时候，去检查下表格，填入变量对应的数值。在复杂的程序中，这可能是相当繁琐且容器出错的，所以把他交给汇编器去做是一个明智的选择。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@number  //把变量number对应的数值（变量地址）传送到A寄存器
@END     //把标签END对应的数值（指令地址）传送到A寄存器
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;到目前为止，这好像是我们第一次使用某种技巧（借助一些数据结构和算法），来把一个问题解决地更快更好&lt;/strong&gt;，这可能就是编程中最有意思也最有挑战的地方吧。&lt;/p&gt;

&lt;h4 id=&quot;c指令&quot;&gt;C指令&lt;/h4&gt;

&lt;p&gt;C指令较为复杂，分成4部分。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一位是标志位：为1时就代表该指令是C指令&lt;/li&gt;
  &lt;li&gt;3-10位是comp位：：这几位的排列用于表示执行不同的元素&amp;amp;逻辑运算&lt;/li&gt;
  &lt;li&gt;11——13位是dest位：指示需要把计算出的数据传送到哪里（寄存器或内存）&lt;/li&gt;
  &lt;li&gt;14-16位是jump位：指示CPU执行跳转指令的条件&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh0v8yf1cj311604st8o.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;我们定义C指令的汇编指令格式是：&lt;strong&gt;dest=comp ; jump&lt;/strong&gt;。其中”dest=”，或”; jump”可以被省略，所以还可以演化出另外两种更常用的指令：”dest=comp”和”comp ; jump”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;计算后赋值指令：dest=comp&lt;/p&gt;

&lt;p&gt;下图我们可以看到dest，comp，jump各自的操作和code的对应方式。例如comp中0000010对代表算D+A的和，然后从out输出；dest中010代表把comp计算的赋给寄存器D；那么D=D+A，这句汇编指令就代表：进行D+A的计算操作，然后把结果传送到寄存器D。D=D+A对应的机器指令是：111(0000010)(010)(000)（后三位000代表跳转指令为null，即不跳转）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;计算后跳转指令：comp ; jump&lt;/p&gt;

&lt;p&gt;jump中001代表判断comp输出的值，如果&amp;gt;0，则进行指令跳转操作。那么D ; JGT，这句汇编指令就代表：进行D的计算操作（即简单的把D输出），然后判断如果值&amp;gt;0，则进行指令跳转操作。D ; JGT对应的机器指令是：111(0001100)(000)(001)。（倒数后三位000代表赋值指令为null，即不需赋值）&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc2zbfy0mmj30uq0kgt9m.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;&lt;em&gt;需要注意的是：无论是要进行指令跳转操作，还是对内存的数据进行读或写，都需要先调用A指令，把目标地址写入A寄存器&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;符号与符号表&quot;&gt;符号与符号表&lt;/h4&gt;

&lt;p&gt;Hack汇编语言中涉及3中符号：预定义符号、标签符号、变量符号&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;预定义符号：预定义符号绑定了内存中的一些地址值，在编写汇编语言时起到辅助作用。例如SP, lCL, ARG等用于辅助函数调用栈的实现；R0-R15可以被当做扩展的寄存器使用；SCREEN, KBD代表屏幕和键盘的内存区域首地址。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc316bfi83j30im0cmmxe.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;标签符号：标签符号绑定了指令的地址值，用于跳转指令。用（大写字母符号）声明，独占一行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;变量符号：变量符号绑定了变量的地址值。每遇到新的变量，则连续地在内存空间为其分配地址（变量地址从内存中16地址开始）。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc31216n0qj30ss19yq65.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;

&lt;p&gt;符号表是一个字典结构，key是符号本身，value可以是和该符号相关的若干信息，在这里符号表的value就是符号代表的内存地址的值。在使用符号表的时候，往往需要先构建符号表（符号表可能会被动态地修改），然后在处理程序数据的时候，通过查找符号表来获取符号相关的信息。符号表是一个重要的数据结构，在汇编器、编译器、链接器中都扮演了重要的角色。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc31ywvwbaj30u80lwq3z.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;举例&quot;&gt;举例&lt;/h4&gt;

&lt;p&gt;这里我们举一个例子，把一个C语言风格的代码，转化为Hack上的汇编语言实现。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc32onh098j31390u0t9w.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;

&lt;p&gt;实现Hack的汇编器相对比较简单，主要方法是逐行的分析汇编指令，判断指令类型和组成成分，然后生成对应的机器指令。唯一的难点在于对符号的处理，而实现的技巧在于对符号表的运用。&lt;/p&gt;

&lt;p&gt;汇编器实现：（完整实现放在:&lt;a href=&quot;https://github.com/guosainpu/Nand2Tetris&quot;&gt;github&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SymbolTable&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# void add_entry(entry)      新增一个符号&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# bool contains(symbol)      是否包含符号&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string get_address(symbol) 获取符号的值&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ......&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parser&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# bool hasMoreCommand        是否还有下一条指令&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# void advance               指令游标前进&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string commandType         当前指令的类型&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string symbol              当前指令的符号&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string dest                当前指令dest部分的符号&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string comp                当前指令comp部分的符号&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string jump                当前指令jump部分的符号&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ......&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Code&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string dest(mnemonic)      根据符号获取dest的机器码&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string comp(mnemonic)      根据符号获取comp的机器码&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# string jump(mnemonic)      根据符号获取jump的机器码&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ......&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# main&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ARGV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hack_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.hack&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;symbol_table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SymbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;vg&quot;&gt;$command_line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#第一次遍历源文件，构建符号表（初始化所有标签符号的值，因为标签符号可以先使用后声明，所以需要先遍历一遍；变量符号可以边生成机器代码时边初始化，因为变量符号是先声明后使用）&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;generate symbol table:&quot;&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hasMoreCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;advance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;command_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;commandType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;L_COMMAND&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbol_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;symbol_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;completeBinary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$command_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))})&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;vg&quot;&gt;$command_line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;generate code:&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#第二次遍历源文件，把汇编代码汇编成机器代码&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;vg&quot;&gt;$variabel_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#变量从地址16开始连续分配&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hack_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hack_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;w&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hasMoreCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;advance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;command_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;commandType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A_COMMAND&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;address_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;address_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completeBinary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbol_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#如果符号表已经包含符号，则直接取出符号的值&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;address_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbol_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;address_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completeBinary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$variabel_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#如果符号表不包含符号，则把符号加入到符号表，并把下一个变量地址+1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;symbol_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_symbol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
            &lt;span class=&quot;vg&quot;&gt;$variabel_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;C_COMMAND&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;111&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dest_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;comp_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;comp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;comp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;jump_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;jump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;jump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comp_value&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest_value&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;L_COMMAND&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;next&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unknow command type&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hack_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;completeBinary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binary_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binary_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binary_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binary_string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!~&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/\D/&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们用不到200行的代码就实现了一个汇编器，是不是很简单？&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;汇编语言是人操作计算机工作最直接的方式，它描述了计算机最终执行的指令序列。学习汇编语言能让我们充分获得底层编程的体验，理解计算机运行的机理，这能让我在学习理解上层知识的时候更加准确。Hack的汇编指令只具备了最必要的功能，和我们常用的动辄几百条的汇编指令集有很大差距，但这并不妨碍Hack成为一个完整的计算机。下一篇我们会基于Hack的汇编指令扩展出一个虚拟机，这个虚拟机的指令集更接近我们常用的CPU的指令集。&lt;/p&gt;

&lt;p&gt;推荐王爽的《汇编语言》，这本书不仅能高效地指导大家学习汇编语言，同时也是一本用于指导如何学习的书，字里行间蕴含了王爽老师自己对如何学习，如何教学的理解。相比较于很多苍白的翻译书籍，这本本土书籍更加优秀。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">前一篇我们完成了Hack平台的硬件部分，本篇开始我们进入到软件的部分。相比较而言，软件部分更加复杂，需要花更多时间来实现和调试。软件部分的第一层就是汇编语言和汇编器，本篇我们将定义Hack的汇编语言，并编写对应的汇编器 汇编语言和汇编器 汇编语言是机器语言的符号表示，相比于机器语言，汇编语言更接近于自然语言，便于我们阅读和记忆。汇编语言和机器语言在表述上的一致性是非常高的，绝大多数情况下两种指令是一一对应的，例如：1000100111011000对应mov ax,bx，把机器指令拆成3段，其中前8位代表mov，中间4位代表寄存器ax，最后四位代表寄存器bx。此外，我们还可以在汇编语言中用引用一些符号，用于代表某些数值（例如内存地址，指令地址等），这可以把我们从处理这些繁琐的数值的工作中解放出来（例如我们用符号i来代表一块内存地址，然后不用去记忆地址具体的值是多少，分配在什么位置，是否和其他地址冲突等），提高代码的编写效率。 汇编器负责把汇编语言翻译成机器语言。因为汇编语言和机器语言的高度一致性，所以实现汇编器是比较简单的。唯一的难点可能就在于上面所提到的如何把一些符号和它们所对应的数值联系起来，即符号解析(symbol resolution)的过程。 Hack的汇编语言设计 想要设计一门汇编语言，那么必须要参考它的机器语言。Hack的机器指令集过于简单，只有A、C两种命令，所以相应的它的汇编语言也很简单😂。 A指令 我们copy一些上一篇文章的内容：A指令，即Address指令。它的功能很简单，就是把一个数值传送到CPU中的A寄存器即可，多数情况下这个数字后续会当做地址使用，用于定位内存中的存储单元。 我们定义A指令的汇编指令格式是：@value。 1.value可以是一个立即数。这种格式是两种语言的天然映射。 @3 //把数字3传送到A寄存器 @5 //把数字5传送到A寄存器 2.value也可以是一个符号（变量名） 我们支持把符号当做数值代入，这更像我们在高级语言中编码的方式。例如@number，它的含义是：把变量number的首地址传送到A寄存器，number的首地址可能是1000或者2000，我们并不去关心它。如果不支持@+符号这种命令，我们该怎么编写Hack的A汇编指令呢？我们可能需要先梳理出该程序需要几个变量，例如i，j，k，然后画一个表格，安排一下i，j，k的地址，并保证他们不互相冲突，然后用@+立即数的方式编写，每次遇到需要传入变量地址的时候，去检查下表格，填入变量对应的数值。在复杂的程序中，这可能是相当繁琐且容器出错的，所以把他交给汇编器去做是一个明智的选择。 @number //把变量number对应的数值（变量地址）传送到A寄存器 @END //把标签END对应的数值（指令地址）传送到A寄存器 到目前为止，这好像是我们第一次使用某种技巧（借助一些数据结构和算法），来把一个问题解决地更快更好，这可能就是编程中最有意思也最有挑战的地方吧。 C指令 C指令较为复杂，分成4部分。 第一位是标志位：为1时就代表该指令是C指令 3-10位是comp位：：这几位的排列用于表示执行不同的元素&amp;amp;逻辑运算 11——13位是dest位：指示需要把计算出的数据传送到哪里（寄存器或内存） 14-16位是jump位：指示CPU执行跳转指令的条件 我们定义C指令的汇编指令格式是：dest=comp ; jump。其中”dest=”，或”; jump”可以被省略，所以还可以演化出另外两种更常用的指令：”dest=comp”和”comp ; jump”。 1.计算后赋值指令：dest=comp 下图我们可以看到dest，comp，jump各自的操作和code的对应方式。例如comp中0000010对代表算D+A的和，然后从out输出；dest中010代表把comp计算的赋给寄存器D；那么D=D+A，这句汇编指令就代表：进行D+A的计算操作，然后把结果传送到寄存器D。D=D+A对应的机器指令是：111(0000010)(010)(000)（后三位000代表跳转指令为null，即不跳转） 2.计算后跳转指令：comp ; jump jump中001代表判断comp输出的值，如果&amp;gt;0，则进行指令跳转操作。那么D ; JGT，这句汇编指令就代表：进行D的计算操作（即简单的把D输出），然后判断如果值&amp;gt;0，则进行指令跳转操作。D ; JGT对应的机器指令是：111(0001100)(000)(001)。（倒数后三位000代表赋值指令为null，即不需赋值） 需要注意的是：无论是要进行指令跳转操作，还是对内存的数据进行读或写，都需要先调用A指令，把目标地址写入A寄存器 符号与符号表 Hack汇编语言中涉及3中符号：预定义符号、标签符号、变量符号 1.预定义符号：预定义符号绑定了内存中的一些地址值，在编写汇编语言时起到辅助作用。例如SP, lCL, ARG等用于辅助函数调用栈的实现；R0-R15可以被当做扩展的寄存器使用；SCREEN, KBD代表屏幕和键盘的内存区域首地址。 2.标签符号：标签符号绑定了指令的地址值，用于跳转指令。用（大写字母符号）声明，独占一行。 3.变量符号：变量符号绑定了变量的地址值。每遇到新的变量，则连续地在内存空间为其分配地址（变量地址从内存中16地址开始）。 符号表是一个字典结构，key是符号本身，value可以是和该符号相关的若干信息，在这里符号表的value就是符号代表的内存地址的值。在使用符号表的时候，往往需要先构建符号表（符号表可能会被动态地修改），然后在处理程序数据的时候，通过查找符号表来获取符号相关的信息。符号表是一个重要的数据结构，在汇编器、编译器、链接器中都扮演了重要的角色。 举例 这里我们举一个例子，把一个C语言风格的代码，转化为Hack上的汇编语言实现。 实现 实现Hack的汇编器相对比较简单，主要方法是逐行的分析汇编指令，判断指令类型和组成成分，然后生成对应的机器指令。唯一的难点在于对符号的处理，而实现的技巧在于对符号表的运用。 汇编器实现：（完整实现放在:github） class SymbolTable # void add_entry(entry) 新增一个符号 # bool contains(symbol) 是否包含符号 # string get_address(symbol) 获取符号的值 # ...... end class Parser # bool hasMoreCommand 是否还有下一条指令 # void advance 指令游标前进 # string commandType 当前指令的类型 # string symbol 当前指令的符号 # string dest 当前指令dest部分的符号 # string comp 当前指令comp部分的符号 # string jump 当前指令jump部分的符号 # ...... end class Code # string dest(mnemonic) 根据符号获取dest的机器码 # string comp(mnemonic) 根据符号获取comp的机器码 # string jump(mnemonic) 根据符号获取jump的机器码 # ...... end # main file_name = ARGV[0] hack_name = file_name.split(&quot;.&quot;)[0] + &quot;.hack&quot; parser=Parser.new(File.read(file_name)) code = Code.new() symbol_table = SymbolTable.new(); $command_line = 0 #第一次遍历源文件，构建符号表（初始化所有标签符号的值，因为标签符号可以先使用后声明，所以需要先遍历一遍；变量符号可以边生成机器代码时边初始化，因为变量符号是先声明后使用） puts &quot;generate symbol table:&quot; while parser.hasMoreCommand() parser.advance() command_type = parser.commandType() command_symbol = parser.symbol() if command_type == &quot;L_COMMAND&quot; if !symbol_table.contains(command_symbol) symbol_table.add_entry({command_symbol=&amp;gt;completeBinary(($command_line).to_s(2))}) end else $command_line += 1 end end puts &quot;generate code:&quot; #第二次遍历源文件，把汇编代码汇编成机器代码 parser.reset() $variabel_address = 16 #变量从地址16开始连续分配 hack_file = File.new(hack_name, &quot;w&quot;) while parser.hasMoreCommand() new_command = &quot;&quot; parser.advance() command_type = parser.commandType() command_symbol = parser.symbol() if command_type == &quot;A_COMMAND&quot; new_command &amp;lt;&amp;lt; &quot;0&quot; address_value = &quot;&quot; if is_number(command_symbol) address_value = completeBinary(command_symbol.to_i.to_s(2)) elsif symbol_table.contains(command_symbol) #如果符号表已经包含符号，则直接取出符号的值 address_value = symbol_table.get_address(command_symbol) else address_value = completeBinary($variabel_address.to_s(2)) #如果符号表不包含符号，则把符号加入到符号表，并把下一个变量地址+1 symbol_table.add_entry({command_symbol=&amp;gt;address_value}) $variabel_address += 1 end new_command &amp;lt;&amp;lt; address_value elsif command_type == &quot;C_COMMAND&quot; new_command &amp;lt;&amp;lt; &quot;111&quot; dest_value = code.dest(parser.dest()) comp_value = code.comp(parser.comp()) jump_value = code.jump(parser.jump()) new_command &amp;lt;&amp;lt; comp_value new_command &amp;lt;&amp;lt; dest_value new_command &amp;lt;&amp;lt; jump_value elsif command_type == &quot;L_COMMAND&quot; next else new_command &amp;lt;&amp;lt; &quot;unknow command type&quot; end new_command &amp;lt;&amp;lt; &quot;\n&quot; hack_file.write(new_command) end def completeBinary(binary_string) while binary_string.length &amp;lt; 15 binary_string.insert(0,&quot;0&quot;) end return binary_string end def is_number(string) return string !~ /\D/ end 我们用不到200行的代码就实现了一个汇编器，是不是很简单？ 总结 汇编语言是人操作计算机工作最直接的方式，它描述了计算机最终执行的指令序列。学习汇编语言能让我们充分获得底层编程的体验，理解计算机运行的机理，这能让我在学习理解上层知识的时候更加准确。Hack的汇编指令只具备了最必要的功能，和我们常用的动辄几百条的汇编指令集有很大差距，但这并不妨碍Hack成为一个完整的计算机。下一篇我们会基于Hack的汇编指令扩展出一个虚拟机，这个虚拟机的指令集更接近我们常用的CPU的指令集。 推荐王爽的《汇编语言》，这本书不仅能高效地指导大家学习汇编语言，同时也是一本用于指导如何学习的书，字里行间蕴含了王爽老师自己对如何学习，如何教学的理解。相比较于很多苍白的翻译书籍，这本本土书籍更加优秀。</summary></entry><entry><title type="html">从0到1构建计算机(5/10)–实现hack：计算机架构、内存、CPU和指令集</title><link href="/2020/02/01/hack-CPU%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8C%87%E4%BB%A4%E9%9B%86.html" rel="alternate" type="text/html" title="从0到1构建计算机(5/10)--实现hack：计算机架构、内存、CPU和指令集" /><published>2020-02-01T00:00:00+08:00</published><updated>2020-02-01T00:00:00+08:00</updated><id>/2020/02/01/hack%20CPU%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8C%87%E4%BB%A4%E9%9B%86</id><content type="html" xml:base="/2020/02/01/hack-CPU%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8C%87%E4%BB%A4%E9%9B%86.html">&lt;p&gt;经过前两篇我们已经实现了所有的组合逻辑芯片和时序芯片，具备了实现hack计算机的基础，本篇是项目硬件部分的最后一篇，我们将在本篇定义hack能够执行的操作，即hack的指令集；实现hack的内存、CPU，然后将它们组合起来形成完整的计算机硬件架构。&lt;/p&gt;

&lt;h3 id=&quot;计算机架构&quot;&gt;计算机架构&lt;/h3&gt;

&lt;p&gt;hack是基于经典的冯·诺伊曼体系架构，它的关键组成部分是将中央处理单元和存储器，通过存储器中存储的程序指令控制中央处理器的执行，即存储程序计算机。它主要有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;以运算单元为中心&lt;/li&gt;
  &lt;li&gt;采用存储程序原理&lt;/li&gt;
  &lt;li&gt;存储器是按地址访问、线性编址的空间&lt;/li&gt;
  &lt;li&gt;控制流由指令流产生&lt;/li&gt;
  &lt;li&gt;指令由操作码和地址码组成&lt;/li&gt;
  &lt;li&gt;数据以二进制编码&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbgwoausqdj31b00p20t8.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;指令集机器语言&quot;&gt;指令集（机器语言）&lt;/h3&gt;
&lt;p&gt;我们可以从两个角度来理解CPU，一个是从机器语言的角度，一个是从物理实现的角度。&lt;strong&gt;机器语言是CPU的功能抽象，物理实现是CPU的具体实现，同时机器语言还是计算机系统硬件层和软件层的接口。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想要实现CPU，我们首先要定义CPU能执行哪些操作，然后把这些操作抽象为CPU的指令集。CPU的指令集就是一系列的操作约定，它们以格式化的指令，描述了如何用CPU来操作内存。我们已x86的指令集为例，x86的指令集非常复杂，有几百条指令，包括数据传输指令、算数运算指令、逻辑运算指令、位移指令、字符串操作指令、处理器控制指令、控制转移指令等&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh0f43rzqj312h0u0wk4.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;我们会抛弃诸多复杂的指令，只实现一个CPU所需的最必须的功能，以方便实现，但更重要的是方便我们理解计算机系统硬件设计运行的最基本原理。我们可以梳理出最必须的4点功能：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从内存中读取某地址的数据（包括指令数据），传送到CPU&lt;/li&gt;
  &lt;li&gt;CPU进行基本的算数&amp;amp;逻辑运算&lt;/li&gt;
  &lt;li&gt;CPU把数据写入内存或寄存器&lt;/li&gt;
  &lt;li&gt;CPU跳转到某地址执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实现时，我们只需设计两条指令就可以满足上面的4点功能，你没听错，只需要两条。再介绍这两条指令之前，我们先介绍下CPU中需要用到的2个寄存器，A寄存器：用于暂存一个立即数（通常是将要用到的内存地址的值）；D寄存器：用于暂存计算过程中的中间数据。回顾一下前两篇的内容，我们实现的芯片的最大字长都16位，所以我们的指令也是16位的。&lt;/p&gt;

&lt;h4 id=&quot;a指令&quot;&gt;A指令&lt;/h4&gt;
&lt;p&gt;A指令，即Address指令。它的功能很简单，就是把一个数值传送到CPU中的A寄存器即可，多数情况下这个数字后续会当做地址使用，用于定位内存中的存储单元。我们来看一下A指令的格式，A指令把16位数据分成两部分：第一位是标志位，为0时就代表该指令是A指令，剩下的15位就是需要传入A寄存器的数值。可以看到，A指令实现了上面4点功能的第一点。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh0rj8yj6j30we0480sn.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;c指令&quot;&gt;C指令&lt;/h4&gt;
&lt;p&gt;C指令较为复杂，分成4部分。A指令实现了上面4点功能的后三点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一位是标志位：为1时就代表该指令是C指令&lt;/li&gt;
  &lt;li&gt;3-10位是comp位：：这几位的排列用于表示执行不同的元素&amp;amp;逻辑运算&lt;/li&gt;
  &lt;li&gt;11——13位是dest位：指示需要把计算出的数据传送到哪里（寄存器或内存）&lt;/li&gt;
  &lt;li&gt;14-16位是jump位：指示CPU执行跳转指令的条件&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh0v8yf1cj311604st8o.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;comp位，copm位主要作用于CPU中的ALU，指示ALU来进行一些算数运算和逻辑运算，操作数就是A寄存器，D寄存器，或者由A寄存器中的地址指向的内存单元中的数据。操作列表如下：&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh153x9nkj30w20rawf4.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;通过comp位的指示ALU计算出的数值，再传送到由dest位指示的存储单元，这个存储单元是A寄存器，D寄存器，或者由A寄存器中的地址指向的内存单元，或者是他们的组合。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh18hc1zaj31040d2ab1.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;大多数情况下，CPU是顺序执行的，但也需要进行跳转执行。jump的执行逻辑是，根据comp位输出的数据，用jump位判断是否需要跳转，如果需要，则跳转到A寄存器中地址的指令，否则按顺序执行下一条指令。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh1e9lupsj30vg0e8mxu.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;一些符号&quot;&gt;一些符号&lt;/h4&gt;
&lt;p&gt;同时，我们提前介绍一些预定义的符号，符号的作用是便于我们后续编写hack的汇编语言。所需的符号类型如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;预定义符号：有汇编语言中特殊含义的符号&lt;/li&gt;
  &lt;li&gt;虚拟寄存器：代表一些虚拟寄存器中的地址&lt;/li&gt;
  &lt;li&gt;预定义指针：指向一些特定的内存&lt;/li&gt;
  &lt;li&gt;I/O指针：指向内存中I/O的其实地址&lt;/li&gt;
  &lt;li&gt;标签符号：用于表示指令的位置（方便编写跳转逻辑）&lt;/li&gt;
  &lt;li&gt;变量符号：方便在汇编代码中声明变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内存&quot;&gt;内存&lt;/h3&gt;
&lt;p&gt;我们在时序芯片里已经实现了RAM芯片，所以实现内存的工作已经基本完成。本篇主要是对内存的使用、组合和划分。内存按照功能划分，主要分为数据内存和指令内存两部分，正常时情况数据内存和指令内存是在一块大内存下划分的，是操作系统帮开发者分配管理的，这里我们为了更方便的实现，把hack的内存拆成量块：一块数据内存Memory，一块ROM，ROM专门用于存储程序，在程序运行期间不支持写入操作。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh3erthk6j312e0o2mxq.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;同时把Memory划分为3部分：RAM（16K），用于存储数据；Screen（8K）内存映射到显示器；Keyboard（16bit）内存映射到键盘。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh2ausrj0j30uo0lu0tf.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：Memory&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CHIP Memory {
    IN in[16], load, address[15];
    OUT out[16];

    PARTS:
    DMux4Way(in=true, sel[0..1]=address[13..14], a=a, b=b, c=c, d=d);

    Or(a=a, b=b, out=outa);

    And(a=outa, b=load, out=load0);
    And(a=c, b=load, out=load1);

    RAM16K(in=in, load=load0, address[0..13]=address[0..13], out=R0);
    Screen(in=in, load=load1, address[0..12]=address[0..12], out=R1);
    Keyboard(out=R2);

    Mux4Way16(a=R0, b=R0, c=R1, d=R2, sel[0..1]=address[13..14], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;
&lt;p&gt;定义完指令集，我们接着需要做的就是按照指令功能实现CPU。hack的CPU主要由以下四部分组成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ALU：主要用于执行算数&amp;amp;逻辑运算&lt;/li&gt;
  &lt;li&gt;寄存器：A寄存器、D寄存器&lt;/li&gt;
  &lt;li&gt;PC：程序计数器，保存下一条指令地址&lt;/li&gt;
  &lt;li&gt;控制逻辑：解析指令类型，选择寄存器，更新PC等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CPU的电路示意图如下(完整电路图比较难画，先不画了）&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh319ez5ij31800rct9n.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：CPU&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
    // 指令类型解析
    And(a=instruction[15], b=true, out=ins15);          // ins15指令标志位
    Not(in=instruction[15], out=ins15Not);       // ins15Not:指令标志位取反

    // A指令和A寄存器
    Mux16(a=instruction, b=ALUOut, sel=instruction[5], out=ARSel);
    Mux16(a=instruction, b=ARSel, sel=ins15, out=ARIn);
    Or(a=ins15Not, b=instruction[5], out=ARLoad);
    ARegister(in=ARIn, load=ARLoad, out=AROut);

    // D寄存器
    And(a=ins15, b=instruction[4], out=DRLoad);
    DRegister(in=ALUOut, load=DRLoad, out=DROut);

    // C指令类型区分：计算A还是计算M
    Mux16(a=AROut, b=inM, sel=instruction[12], out=AMOut);

    // ALU逻辑
    ALU(x=DROut, y=AMOut, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], out=ALUOut, zr=ALUzr, ng=ALUng);

    // outM &amp;amp; writeM &amp;amp; addressM
    And16(a=true, b=ALUOut, out=outM);
    And(a=ins15, b=instruction[3], out=writeM);
    And16(a=true, b=AROut, out[0..14]=addressM[0..14]);

    // jump逻辑
    And(a=ALUng, b=instruction[2], out=j1Out);
    And(a=ALUzr, b=instruction[1], out=j2Out);
    Or(a=ALUng, b=ALUzr, out=po);
    Not(in=po, out=ALUpo);
    And(a=ALUpo, b=instruction[0], out=j3Out);
    Or8Way(in[0]=j1Out, in[1]=j2Out, in[2]=j3Out, in[3..7]=false, out=jump);
    And(a=ins15, b=jump, out=jumpOut);

    // PC
    PC(in=AROut, load=jumpOut, inc=true, reset=reset, out[0..14]=pc[0..14]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;combination&quot;&gt;COMBINATION&lt;/h3&gt;

&lt;p&gt;最后我们按照整体架构图，把CPU、ROM、RAM连接起来即可。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh27xo7nej31bg0ok0tw.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * The HACK computer, including CPU, ROM and RAM.
 * When reset is 0, the program stored in the computer's ROM executes.
 * When reset is 1, the execution of the program restarts. 
 * Thus, to start a program's execution, reset must be pushed &quot;up&quot; (1)
 * and &quot;down&quot; (0). From this point onward the user is at the mercy of 
 * the software. In particular, depending on the program's code, the 
 * screen may show some output and the user may be able to interact 
 * with the computer via the keyboard.
 */

CHIP Computer {

    IN reset;

    PARTS:
    CPU(inM=memoryOut, instruction=ROMOut, reset=reset, outM=outM, writeM=writeM, addressM=addressM, pc=pc);
    ROM32K(address=pc, out=ROMOut);
    Memory(in=outM, load=writeM, address=addressM, out=memoryOut);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;至此，我们就完了hack硬件部分的所有工作。我们基于两个基本们：Nand和DFF，一步步实现了诸多芯片，最终实现了整个硬件架构。hack虽小，五脏俱全，我们只保留了计算机架构中最核心的部分，&lt;strong&gt;减少了我们的工作量，更重要的是方便我们拨开众多复杂的技术细节，清楚的了解到计算机体系最核心的设计思想&lt;/strong&gt;。完成了hack的硬件系统和指令集的定义，我们就可以编写一个用0101写的hello world程序了，但这貌似有些痛苦，所以我们会在下一篇定义hack的汇编语言，并编写汇编器。😀&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh3i0sxnoj310s0u03zp.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">经过前两篇我们已经实现了所有的组合逻辑芯片和时序芯片，具备了实现hack计算机的基础，本篇是项目硬件部分的最后一篇，我们将在本篇定义hack能够执行的操作，即hack的指令集；实现hack的内存、CPU，然后将它们组合起来形成完整的计算机硬件架构。 计算机架构 hack是基于经典的冯·诺伊曼体系架构，它的关键组成部分是将中央处理单元和存储器，通过存储器中存储的程序指令控制中央处理器的执行，即存储程序计算机。它主要有以下几个特点： 以运算单元为中心 采用存储程序原理 存储器是按地址访问、线性编址的空间 控制流由指令流产生 指令由操作码和地址码组成 数据以二进制编码 指令集（机器语言） 我们可以从两个角度来理解CPU，一个是从机器语言的角度，一个是从物理实现的角度。机器语言是CPU的功能抽象，物理实现是CPU的具体实现，同时机器语言还是计算机系统硬件层和软件层的接口。 想要实现CPU，我们首先要定义CPU能执行哪些操作，然后把这些操作抽象为CPU的指令集。CPU的指令集就是一系列的操作约定，它们以格式化的指令，描述了如何用CPU来操作内存。我们已x86的指令集为例，x86的指令集非常复杂，有几百条指令，包括数据传输指令、算数运算指令、逻辑运算指令、位移指令、字符串操作指令、处理器控制指令、控制转移指令等 我们会抛弃诸多复杂的指令，只实现一个CPU所需的最必须的功能，以方便实现，但更重要的是方便我们理解计算机系统硬件设计运行的最基本原理。我们可以梳理出最必须的4点功能： 从内存中读取某地址的数据（包括指令数据），传送到CPU CPU进行基本的算数&amp;amp;逻辑运算 CPU把数据写入内存或寄存器 CPU跳转到某地址执行 在实现时，我们只需设计两条指令就可以满足上面的4点功能，你没听错，只需要两条。再介绍这两条指令之前，我们先介绍下CPU中需要用到的2个寄存器，A寄存器：用于暂存一个立即数（通常是将要用到的内存地址的值）；D寄存器：用于暂存计算过程中的中间数据。回顾一下前两篇的内容，我们实现的芯片的最大字长都16位，所以我们的指令也是16位的。 A指令 A指令，即Address指令。它的功能很简单，就是把一个数值传送到CPU中的A寄存器即可，多数情况下这个数字后续会当做地址使用，用于定位内存中的存储单元。我们来看一下A指令的格式，A指令把16位数据分成两部分：第一位是标志位，为0时就代表该指令是A指令，剩下的15位就是需要传入A寄存器的数值。可以看到，A指令实现了上面4点功能的第一点。 C指令 C指令较为复杂，分成4部分。A指令实现了上面4点功能的后三点 第一位是标志位：为1时就代表该指令是C指令 3-10位是comp位：：这几位的排列用于表示执行不同的元素&amp;amp;逻辑运算 11——13位是dest位：指示需要把计算出的数据传送到哪里（寄存器或内存） 14-16位是jump位：指示CPU执行跳转指令的条件 comp位，copm位主要作用于CPU中的ALU，指示ALU来进行一些算数运算和逻辑运算，操作数就是A寄存器，D寄存器，或者由A寄存器中的地址指向的内存单元中的数据。操作列表如下： 通过comp位的指示ALU计算出的数值，再传送到由dest位指示的存储单元，这个存储单元是A寄存器，D寄存器，或者由A寄存器中的地址指向的内存单元，或者是他们的组合。 大多数情况下，CPU是顺序执行的，但也需要进行跳转执行。jump的执行逻辑是，根据comp位输出的数据，用jump位判断是否需要跳转，如果需要，则跳转到A寄存器中地址的指令，否则按顺序执行下一条指令。 一些符号 同时，我们提前介绍一些预定义的符号，符号的作用是便于我们后续编写hack的汇编语言。所需的符号类型如下： 预定义符号：有汇编语言中特殊含义的符号 虚拟寄存器：代表一些虚拟寄存器中的地址 预定义指针：指向一些特定的内存 I/O指针：指向内存中I/O的其实地址 标签符号：用于表示指令的位置（方便编写跳转逻辑） 变量符号：方便在汇编代码中声明变量 内存 我们在时序芯片里已经实现了RAM芯片，所以实现内存的工作已经基本完成。本篇主要是对内存的使用、组合和划分。内存按照功能划分，主要分为数据内存和指令内存两部分，正常时情况数据内存和指令内存是在一块大内存下划分的，是操作系统帮开发者分配管理的，这里我们为了更方便的实现，把hack的内存拆成量块：一块数据内存Memory，一块ROM，ROM专门用于存储程序，在程序运行期间不支持写入操作。 同时把Memory划分为3部分：RAM（16K），用于存储数据；Screen（8K）内存映射到显示器；Keyboard（16bit）内存映射到键盘。 HDL实现：Memory CHIP Memory { IN in[16], load, address[15]; OUT out[16]; PARTS: DMux4Way(in=true, sel[0..1]=address[13..14], a=a, b=b, c=c, d=d); Or(a=a, b=b, out=outa); And(a=outa, b=load, out=load0); And(a=c, b=load, out=load1); RAM16K(in=in, load=load0, address[0..13]=address[0..13], out=R0); Screen(in=in, load=load1, address[0..12]=address[0..12], out=R1); Keyboard(out=R2); Mux4Way16(a=R0, b=R0, c=R1, d=R2, sel[0..1]=address[13..14], out=out); } CPU 定义完指令集，我们接着需要做的就是按照指令功能实现CPU。hack的CPU主要由以下四部分组成： ALU：主要用于执行算数&amp;amp;逻辑运算 寄存器：A寄存器、D寄存器 PC：程序计数器，保存下一条指令地址 控制逻辑：解析指令类型，选择寄存器，更新PC等 CPU的电路示意图如下(完整电路图比较难画，先不画了） HDL实现：CPU CHIP CPU { IN inM[16], // M value input (M = contents of RAM[A]) instruction[16], // Instruction for execution reset; // Signals whether to re-start the current // program (reset==1) or continue executing // the current program (reset==0). OUT outM[16], // M value output writeM, // Write to M? addressM[15], // Address in data memory (of M) pc[15]; // address of next instruction PARTS: // 指令类型解析 And(a=instruction[15], b=true, out=ins15); // ins15指令标志位 Not(in=instruction[15], out=ins15Not); // ins15Not:指令标志位取反 // A指令和A寄存器 Mux16(a=instruction, b=ALUOut, sel=instruction[5], out=ARSel); Mux16(a=instruction, b=ARSel, sel=ins15, out=ARIn); Or(a=ins15Not, b=instruction[5], out=ARLoad); ARegister(in=ARIn, load=ARLoad, out=AROut); // D寄存器 And(a=ins15, b=instruction[4], out=DRLoad); DRegister(in=ALUOut, load=DRLoad, out=DROut); // C指令类型区分：计算A还是计算M Mux16(a=AROut, b=inM, sel=instruction[12], out=AMOut); // ALU逻辑 ALU(x=DROut, y=AMOut, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], out=ALUOut, zr=ALUzr, ng=ALUng); // outM &amp;amp; writeM &amp;amp; addressM And16(a=true, b=ALUOut, out=outM); And(a=ins15, b=instruction[3], out=writeM); And16(a=true, b=AROut, out[0..14]=addressM[0..14]); // jump逻辑 And(a=ALUng, b=instruction[2], out=j1Out); And(a=ALUzr, b=instruction[1], out=j2Out); Or(a=ALUng, b=ALUzr, out=po); Not(in=po, out=ALUpo); And(a=ALUpo, b=instruction[0], out=j3Out); Or8Way(in[0]=j1Out, in[1]=j2Out, in[2]=j3Out, in[3..7]=false, out=jump); And(a=ins15, b=jump, out=jumpOut); // PC PC(in=AROut, load=jumpOut, inc=true, reset=reset, out[0..14]=pc[0..14]); } COMBINATION 最后我们按照整体架构图，把CPU、ROM、RAM连接起来即可。 HDL实现 /** * The HACK computer, including CPU, ROM and RAM. * When reset is 0, the program stored in the computer's ROM executes. * When reset is 1, the execution of the program restarts. * Thus, to start a program's execution, reset must be pushed &quot;up&quot; (1) * and &quot;down&quot; (0). From this point onward the user is at the mercy of * the software. In particular, depending on the program's code, the * screen may show some output and the user may be able to interact * with the computer via the keyboard. */ CHIP Computer { IN reset; PARTS: CPU(inM=memoryOut, instruction=ROMOut, reset=reset, outM=outM, writeM=writeM, addressM=addressM, pc=pc); ROM32K(address=pc, out=ROMOut); Memory(in=outM, load=writeM, address=addressM, out=memoryOut); } 总结 至此，我们就完了hack硬件部分的所有工作。我们基于两个基本们：Nand和DFF，一步步实现了诸多芯片，最终实现了整个硬件架构。hack虽小，五脏俱全，我们只保留了计算机架构中最核心的部分，减少了我们的工作量，更重要的是方便我们拨开众多复杂的技术细节，清楚的了解到计算机体系最核心的设计思想。完成了hack的硬件系统和指令集的定义，我们就可以编写一个用0101写的hello world程序了，但这貌似有些痛苦，所以我们会在下一篇定义hack的汇编语言，并编写汇编器。😀</summary></entry><entry><title type="html">从0到1构建计算机(4/10)–时序逻辑芯片：时序门、寄存器、RAM、计数器</title><link href="/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E6%97%B6%E5%BA%8F%E9%97%A8-%E5%AF%84%E5%AD%98%E5%99%A8-RAM-%E8%AE%A1%E6%95%B0%E5%99%A8.html" rel="alternate" type="text/html" title="从0到1构建计算机(4/10)--时序逻辑芯片：时序门、寄存器、RAM、计数器" /><published>2020-01-29T00:00:00+08:00</published><updated>2020-01-29T00:00:00+08:00</updated><id>/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87:%E6%97%B6%E5%BA%8F%E9%97%A8%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81RAM%E3%80%81%E8%AE%A1%E6%95%B0%E5%99%A8</id><content type="html" xml:base="/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E6%97%B6%E5%BA%8F%E9%97%A8-%E5%AF%84%E5%AD%98%E5%99%A8-RAM-%E8%AE%A1%E6%95%B0%E5%99%A8.html">&lt;p&gt;上一篇我们实现了一系列组合逻辑芯片和CPU的运算大脑：ALU，但是组合逻辑芯片是一个实时系统，只要输入值改变了输出值也马上跟着改变，上一秒辛苦计算出来的值，下一秒就消失不见了，因此我们需要一个具备”记忆功能”的原件，用于存储数据。这就是我们本篇要介绍的：时序逻辑芯片。&lt;/p&gt;

&lt;h3 id=&quot;反馈电路时钟系统d触发器&quot;&gt;反馈电路、时钟系统、D触发器&lt;/h3&gt;

&lt;p&gt;组合逻辑芯片之所以无法记住上一次计算的值，是因为电流信息的流向是单向的，它总是向前流动，导致我们无法两次踏入同一条河流。要解决这个问题也很简单，我们引一条导线让数据回流，形成一个环路即可（即形成反馈）。下图就是用OR门加上一路环路构成的一位存储器，但他的缺点是只能记忆一次1的输入，后续无论输入如何改变，输出总是为1。如果想要实现功能更强大的记忆芯片就需要更复杂的电路设计，但仍然是基于门的输出再重新作为输入的原理。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdrumxqvgj30l60740sl.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;提到”记忆”就不能不涉及到”时间”，计算机中的时间是基于震荡时钟系统的，震荡时钟提供连续的交变信号（高低电平）从而形成离散的时间周期。时钟周期是计算机系统中各元器件能整齐划一，协调同步的工作的基础。当一个时钟周期到来时，计算机的各个元器件必须抓紧在本次周期内完成自己的任务，然后停下来安静等待下一个周期的来临（这也是为什么时钟频率通常被当做衡量计算机性能的重要指标，因为频率越高，单位时间内计算机完成的工作步骤就越多）。例如只有当时钟上升沿到来时，各时序芯片才会瞬间改变状态，其余时间保持状态锁定。如果把CPU、内存、输入输出设备比作乐团中各个乐器的乐手，那么时钟系统就是计算机乐团的乐队指挥。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeiyf35ixj313e02edft.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;在搭建hack的时候，我们一共用到了两个基本芯片（即不用自己实现的芯片），一个是上一篇用于搭建组合逻辑芯片系统的Nand，另外一个就是本片用于搭建时序逻辑芯片的DFF（data Flip-Flop：D触发器）。DFF的结构由R-S锁存器派生而来。（DFF的实现相对复杂，如果对锁存器和DFF感兴趣，可以参考《编码的奥秘》Charles Petzold）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0yzm52nxj317y0iy753.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;边沿触发的D型触发器&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;DFF包含1bit的输入和1bit的输出，另外DFF有一个时钟输入（图中的小三角代表时钟输入），DFF根据数据输入位和时钟输入位的输入实现了out(t)=in(t-1)，即DFF简单的将前一个时间周期的输入值作为当前时间周期的输出值。这是DFF具备记忆功能的表现，也是我们后续实现16bit寄存器，16K、64K、256K等RAM的基础。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbek01supqj30dq05kaa4.jpg&quot; width=&quot;250&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;1位寄存器和16位寄存器&quot;&gt;1位寄存器和16位寄存器&lt;/h3&gt;
&lt;p&gt;有了DFF的记忆功能，我们接下来先实现最简单1bit寄存器和16bit寄存器。1bit寄存器的接口包括：in输入管脚，负责传输输入数据；load管脚，load管脚是控制位，只有当load为1的时候，才会存储in的输入数据；out管脚输出当前存储的值。接口如下所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbec5aygpzj311i08y3yr.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;1bit芯片很好实现，主要是实现load位的控制功能即可，根据芯片描述可以把芯片设计为：load为1时选择输入in的数据，load为0时选择输入上一次寄存器保存的数据。这种选择功能正好是上一篇我们实现的Multiplexor芯片（后面在实现RAM的时候，Multiplexor在地址选择中的作用体现得更加明显）。1bit寄存器内部实现如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbece9ixdnj30gc0ceaa5.jpg&quot; width=&quot;400&quot; /&gt;&lt;/center&gt;

&lt;p&gt;然后我们用硬件描述语言（HDL）实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 1-bit register:
 * If load[t] == 1 then out[t+1] = in[t]
 *                 else out does not change (out[t+1] = out[t])
 */

CHIP Bit {
    IN in, load;
    OUT out;

    PARTS:
    Mux(a=outBack, b=in, sel=load, out=dffIn);
    DFF(in=dffIn, out=out, out=outBack);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有1bit寄存器，16bit寄存器可以看做是16个1bit寄存器的组合：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbecp634wwj30h80amdfw.jpg&quot; width=&quot;400&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：16bit寄存器&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16-bit register:
 * If load[t] == 1 then out[t+1] = in[t]
 * else out does not change
 */

CHIP Register {
    IN in[16], load;
    OUT out[16];

    PARTS:
    Mux(a=outBack0, b=in[0], sel=load, out=dffIn0);
    DFF(in=dffIn0, out=out[0], out=outBack0);

    Mux(a=outBack1, b=in[1], sel=load, out=dffIn1);
    DFF(in=dffIn1, out=out[1], out=outBack1);

    Mux(a=outBack2, b=in[2], sel=load, out=dffIn2);
    DFF(in=dffIn2, out=out[2], out=outBack2);

    Mux(a=outBack3, b=in[3], sel=load, out=dffIn3);
    DFF(in=dffIn3, out=out[3], out=outBack3);

    Mux(a=outBack4, b=in[4], sel=load, out=dffIn4);
    DFF(in=dffIn4, out=out[4], out=outBack4);

    Mux(a=outBack5, b=in[5], sel=load, out=dffIn5);
    DFF(in=dffIn5, out=out[5], out=outBack5);

    // ...6到15
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ram&quot;&gt;RAM&lt;/h3&gt;
&lt;p&gt;接着我们来实现计算机中另一个非常重要的组成部分：RAM。刚才看到，16bit寄存器可以由16个1bit的寄存器组合而成，同理一个mKB的RAM，可以由n个16位寄存器组合而成，16位寄存器就是RAM中的基本存储单元，寄存器的宽度（此处是16位）就是RAM”字”（WORD）的宽度。我们都知道，需要通过地址来访问RAM，RAM中每个寄存器都绑定到一个唯一地址。下图是RAM的接口设计，RAM有三种输入：数据输入，地址输入和加载位。地址指定了当前周期RAM中哪一个寄存器被访问，当进行读操作时（load=0），RAM立即输出被选中的寄存器的值，当进行写操作时（load=1），被选中的寄存器被赋予新的值，从下个周期开始RAM将开始发出新的值。输入和输出的数据宽度就是RAM”字”的宽度。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbedozihymj30ki0lsjro.jpg&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;

&lt;p&gt;接下来我们要实现RAM8，RAM64，RAM512，RAM4K，RAM16K几种内存容量的RAM。RAMn中的n即代表RAM中有n个寄存器。例如RAM16K中有16K个16位寄存器，那么他的内存容量就是16K*(16/2)byte=32Kbyte。想要实现一个RAMn芯片，我们需要在RAMn芯片中集成n个寄存器，外加一些列控制逻辑（处理load）和地址选择逻辑，那么涉及到选择逻辑自然少不了Multiplexor和DMultiplexor。那么下面我们以RAM8为例讲一下我自己的实现方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;RAM8中有8个寄存器&lt;/li&gt;
  &lt;li&gt;8个寄存器有8个地址，所以我们的地址位需要2^n=8, n=3位&lt;/li&gt;
  &lt;li&gt;DMux用于解析写入时的地址，用3位sel分离出需要写入的那一路，再和load做与操作后作为寄存器的load位输入，最终通过load位来决定哪一个寄存器被写入In。&lt;/li&gt;
  &lt;li&gt;Mux用于解析读取时的地址，用3位sel在8个寄存器中选择想要读取的那一路数据&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbef8oh05tj31ca0qywfd.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：RAM8&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 8 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel=address, a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    Register(in=in, load=load0, out=R0);
    Register(in=in, load=load1, out=R1);
    Register(in=in, load=load2, out=R2);
    Register(in=in, load=load3, out=R3);
    Register(in=in, load=load4, out=R4);
    Register(in=in, load=load5, out=R5);
    Register(in=in, load=load6, out=R6);
    Register(in=in, load=load7, out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel=address, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了RAM8，我们就可以利用8个RAM8的组合实现RAM64，以此类推实现后面容量更大的RAM。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实现RAM64的技巧是对地址位的拆分，RAM64需要6个地址位，把6个地址为拆分为3+3&lt;/li&gt;
  &lt;li&gt;和实现RAM8的时候类似，需要引入一组Mux和DMux，这组选择芯片使用6位地址中的高三位，通过高3位把地址初步划分为8个地址段，每个地址段的容量即RAM8中寄存器的数量&lt;/li&gt;
  &lt;li&gt;每个RAM8使用6位地址中的低三位，然后从中定位到目标地址寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeg2r9r8oj30wu0loaab.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：RAM64&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 64 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM64 {
    IN in[16], load, address[6];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    RAM8(in=in, load=load0, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R0);
    RAM8(in=in, load=load1, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R1);
    RAM8(in=in, load=load2, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R2);
    RAM8(in=in, load=load3, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R3);
    RAM8(in=in, load=load4, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R4);
    RAM8(in=in, load=load5, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R5);
    RAM8(in=in, load=load6, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R6);
    RAM8(in=in, load=load7, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HDL实现：RAM4K&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 4K registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM4K {
    IN in[16], load, address[12];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel[0..2]=address[9..11], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    RAM512(in=in, load=load0, address[0..8]=address[0..8], out=R0);
    RAM512(in=in, load=load1, address[0..8]=address[0..8], out=R1);
    RAM512(in=in, load=load2, address[0..8]=address[0..8], out=R2);
    RAM512(in=in, load=load3, address[0..8]=address[0..8], out=R3);
    RAM512(in=in, load=load4, address[0..8]=address[0..8], out=R4);
    RAM512(in=in, load=load5, address[0..8]=address[0..8], out=R5);
    RAM512(in=in, load=load6, address[0..8]=address[0..8], out=R6);
    RAM512(in=in, load=load7, address[0..8]=address[0..8], out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0..2]=address[9..11], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;至此，我们了解了RAM中内存访问的方式。在RAM中的存储单元可以通过解析地址信号来进行随机的访问，而不会受限于存储单元的位置，访问任何位置的存储单元的速度都是相等的，例如访问内存中一个数组中任意下标的数据的速度都是相等的。这也是Random Access Memory概念的由来。&lt;/p&gt;

&lt;h3 id=&quot;计数器&quot;&gt;计数器&lt;/h3&gt;
&lt;p&gt;计数器也是CPU中一个重要的原件，主要用来存储将要执行指令的内存地址。在大多数情况下，计数器每个周期简单的进行+1操作，这时计算机能够获取下一条地址，这和CPU顺序执行指令的模式相符，同时CPU也支持直接跳转到编号为n的指令去执行，因此计数器要支持将其值设置为n的能力。下面我们来看一下计数器的接口设计：计数器芯片有2个附加控制位reset和inc，当inc=1时，计数器在每个时钟周期自加1，其输出值为out(t)=out(t-1)+1；如果想要将计数器置为0，就将reset置为1。如果想要将计数器设置为某个值，则将load置为1，并将数值从in输入。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeis1709vj30l007it8p.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;下图是我对计数器的实现逻辑&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reset，inc，load用一个Or8way输出，只要其中有一个为1，那么register的load为就为1，register的值会被更新&lt;/li&gt;
  &lt;li&gt;3个Mux串联用于选择自增1、in的输入值、重置0这三种操作&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbejy994vbj317g0ra3z0.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：计数器&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * A 16-bit counter with load and reset control bits.
 * if      (reset[t] == 1) out[t+1] = 0
 * else if (load[t] == 1)  out[t+1] = in[t]
 * else if (inc[t] == 1)   out[t+1] = out[t] + 1  (integer addition)
 * else                    out[t+1] = out[t]
 */

CHIP PC {
    IN in[16],load,inc,reset;
    OUT out[16];

    PARTS:
    Or8Way(in[0]=inc, in[1]=reset, in[2]=load, in[3..7]=false, out=ReLoad);

    Mux16(a=outBack, b=outPlus, sel=inc, out=loadIN);
    Mux16(a=loadIN, b=in, sel=load, out=resetIN);
    Mux16(a=resetIN, b=false, sel=reset, out=ReIn);

    Register(in=ReIn, load=ReLoad, out=out, out=outBack);
    Inc16(in=outBack, out=outPlus);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们以下图为例，看一下计数器是如何在时钟系统下变化数值的。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdrw718d4j31be0hiaat.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;至此，我们实现了hack CPU所需的所有芯片。组合逻辑芯片主要负责算数运算、逻辑运算、选择逻辑，并且通过适当的组合可以用来实现指令解析和某些功能控制；时序芯片主要负责存储数据。下一篇我们会用这些芯片搭建一个简单但实用的CPU。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">上一篇我们实现了一系列组合逻辑芯片和CPU的运算大脑：ALU，但是组合逻辑芯片是一个实时系统，只要输入值改变了输出值也马上跟着改变，上一秒辛苦计算出来的值，下一秒就消失不见了，因此我们需要一个具备”记忆功能”的原件，用于存储数据。这就是我们本篇要介绍的：时序逻辑芯片。 反馈电路、时钟系统、D触发器 组合逻辑芯片之所以无法记住上一次计算的值，是因为电流信息的流向是单向的，它总是向前流动，导致我们无法两次踏入同一条河流。要解决这个问题也很简单，我们引一条导线让数据回流，形成一个环路即可（即形成反馈）。下图就是用OR门加上一路环路构成的一位存储器，但他的缺点是只能记忆一次1的输入，后续无论输入如何改变，输出总是为1。如果想要实现功能更强大的记忆芯片就需要更复杂的电路设计，但仍然是基于门的输出再重新作为输入的原理。 提到”记忆”就不能不涉及到”时间”，计算机中的时间是基于震荡时钟系统的，震荡时钟提供连续的交变信号（高低电平）从而形成离散的时间周期。时钟周期是计算机系统中各元器件能整齐划一，协调同步的工作的基础。当一个时钟周期到来时，计算机的各个元器件必须抓紧在本次周期内完成自己的任务，然后停下来安静等待下一个周期的来临（这也是为什么时钟频率通常被当做衡量计算机性能的重要指标，因为频率越高，单位时间内计算机完成的工作步骤就越多）。例如只有当时钟上升沿到来时，各时序芯片才会瞬间改变状态，其余时间保持状态锁定。如果把CPU、内存、输入输出设备比作乐团中各个乐器的乐手，那么时钟系统就是计算机乐团的乐队指挥。 在搭建hack的时候，我们一共用到了两个基本芯片（即不用自己实现的芯片），一个是上一篇用于搭建组合逻辑芯片系统的Nand，另外一个就是本片用于搭建时序逻辑芯片的DFF（data Flip-Flop：D触发器）。DFF的结构由R-S锁存器派生而来。（DFF的实现相对复杂，如果对锁存器和DFF感兴趣，可以参考《编码的奥秘》Charles Petzold）。 边沿触发的D型触发器 DFF包含1bit的输入和1bit的输出，另外DFF有一个时钟输入（图中的小三角代表时钟输入），DFF根据数据输入位和时钟输入位的输入实现了out(t)=in(t-1)，即DFF简单的将前一个时间周期的输入值作为当前时间周期的输出值。这是DFF具备记忆功能的表现，也是我们后续实现16bit寄存器，16K、64K、256K等RAM的基础。 1位寄存器和16位寄存器 有了DFF的记忆功能，我们接下来先实现最简单1bit寄存器和16bit寄存器。1bit寄存器的接口包括：in输入管脚，负责传输输入数据；load管脚，load管脚是控制位，只有当load为1的时候，才会存储in的输入数据；out管脚输出当前存储的值。接口如下所示： 1bit芯片很好实现，主要是实现load位的控制功能即可，根据芯片描述可以把芯片设计为：load为1时选择输入in的数据，load为0时选择输入上一次寄存器保存的数据。这种选择功能正好是上一篇我们实现的Multiplexor芯片（后面在实现RAM的时候，Multiplexor在地址选择中的作用体现得更加明显）。1bit寄存器内部实现如下： 然后我们用硬件描述语言（HDL）实现： /** * 1-bit register: * If load[t] == 1 then out[t+1] = in[t] * else out does not change (out[t+1] = out[t]) */ CHIP Bit { IN in, load; OUT out; PARTS: Mux(a=outBack, b=in, sel=load, out=dffIn); DFF(in=dffIn, out=out, out=outBack); } 有1bit寄存器，16bit寄存器可以看做是16个1bit寄存器的组合： HDL实现：16bit寄存器 /** * 16-bit register: * If load[t] == 1 then out[t+1] = in[t] * else out does not change */ CHIP Register { IN in[16], load; OUT out[16]; PARTS: Mux(a=outBack0, b=in[0], sel=load, out=dffIn0); DFF(in=dffIn0, out=out[0], out=outBack0); Mux(a=outBack1, b=in[1], sel=load, out=dffIn1); DFF(in=dffIn1, out=out[1], out=outBack1); Mux(a=outBack2, b=in[2], sel=load, out=dffIn2); DFF(in=dffIn2, out=out[2], out=outBack2); Mux(a=outBack3, b=in[3], sel=load, out=dffIn3); DFF(in=dffIn3, out=out[3], out=outBack3); Mux(a=outBack4, b=in[4], sel=load, out=dffIn4); DFF(in=dffIn4, out=out[4], out=outBack4); Mux(a=outBack5, b=in[5], sel=load, out=dffIn5); DFF(in=dffIn5, out=out[5], out=outBack5); // ...6到15 } RAM 接着我们来实现计算机中另一个非常重要的组成部分：RAM。刚才看到，16bit寄存器可以由16个1bit的寄存器组合而成，同理一个mKB的RAM，可以由n个16位寄存器组合而成，16位寄存器就是RAM中的基本存储单元，寄存器的宽度（此处是16位）就是RAM”字”（WORD）的宽度。我们都知道，需要通过地址来访问RAM，RAM中每个寄存器都绑定到一个唯一地址。下图是RAM的接口设计，RAM有三种输入：数据输入，地址输入和加载位。地址指定了当前周期RAM中哪一个寄存器被访问，当进行读操作时（load=0），RAM立即输出被选中的寄存器的值，当进行写操作时（load=1），被选中的寄存器被赋予新的值，从下个周期开始RAM将开始发出新的值。输入和输出的数据宽度就是RAM”字”的宽度。 接下来我们要实现RAM8，RAM64，RAM512，RAM4K，RAM16K几种内存容量的RAM。RAMn中的n即代表RAM中有n个寄存器。例如RAM16K中有16K个16位寄存器，那么他的内存容量就是16K*(16/2)byte=32Kbyte。想要实现一个RAMn芯片，我们需要在RAMn芯片中集成n个寄存器，外加一些列控制逻辑（处理load）和地址选择逻辑，那么涉及到选择逻辑自然少不了Multiplexor和DMultiplexor。那么下面我们以RAM8为例讲一下我自己的实现方式： RAM8中有8个寄存器 8个寄存器有8个地址，所以我们的地址位需要2^n=8, n=3位 DMux用于解析写入时的地址，用3位sel分离出需要写入的那一路，再和load做与操作后作为寄存器的load位输入，最终通过load位来决定哪一个寄存器被写入In。 Mux用于解析读取时的地址，用3位sel在8个寄存器中选择想要读取的那一路数据 HDL实现：RAM8 /** * Memory of 8 registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM8 { IN in[16], load, address[3]; OUT out[16]; PARTS: DMux8Way(in=true, sel=address, a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); Register(in=in, load=load0, out=R0); Register(in=in, load=load1, out=R1); Register(in=in, load=load2, out=R2); Register(in=in, load=load3, out=R3); Register(in=in, load=load4, out=R4); Register(in=in, load=load5, out=R5); Register(in=in, load=load6, out=R6); Register(in=in, load=load7, out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel=address, out=out); } 有了RAM8，我们就可以利用8个RAM8的组合实现RAM64，以此类推实现后面容量更大的RAM。 实现RAM64的技巧是对地址位的拆分，RAM64需要6个地址位，把6个地址为拆分为3+3 和实现RAM8的时候类似，需要引入一组Mux和DMux，这组选择芯片使用6位地址中的高三位，通过高3位把地址初步划分为8个地址段，每个地址段的容量即RAM8中寄存器的数量 每个RAM8使用6位地址中的低三位，然后从中定位到目标地址寄存器 HDL实现：RAM64 /** * Memory of 64 registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM64 { IN in[16], load, address[6]; OUT out[16]; PARTS: DMux8Way(in=true, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); RAM8(in=in, load=load0, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R0); RAM8(in=in, load=load1, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R1); RAM8(in=in, load=load2, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R2); RAM8(in=in, load=load3, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R3); RAM8(in=in, load=load4, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R4); RAM8(in=in, load=load5, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R5); RAM8(in=in, load=load6, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R6); RAM8(in=in, load=load7, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], out=out); } HDL实现：RAM4K /** * Memory of 4K registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM4K { IN in[16], load, address[12]; OUT out[16]; PARTS: DMux8Way(in=true, sel[0..2]=address[9..11], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); RAM512(in=in, load=load0, address[0..8]=address[0..8], out=R0); RAM512(in=in, load=load1, address[0..8]=address[0..8], out=R1); RAM512(in=in, load=load2, address[0..8]=address[0..8], out=R2); RAM512(in=in, load=load3, address[0..8]=address[0..8], out=R3); RAM512(in=in, load=load4, address[0..8]=address[0..8], out=R4); RAM512(in=in, load=load5, address[0..8]=address[0..8], out=R5); RAM512(in=in, load=load6, address[0..8]=address[0..8], out=R6); RAM512(in=in, load=load7, address[0..8]=address[0..8], out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0..2]=address[9..11], out=out); } 至此，我们了解了RAM中内存访问的方式。在RAM中的存储单元可以通过解析地址信号来进行随机的访问，而不会受限于存储单元的位置，访问任何位置的存储单元的速度都是相等的，例如访问内存中一个数组中任意下标的数据的速度都是相等的。这也是Random Access Memory概念的由来。 计数器 计数器也是CPU中一个重要的原件，主要用来存储将要执行指令的内存地址。在大多数情况下，计数器每个周期简单的进行+1操作，这时计算机能够获取下一条地址，这和CPU顺序执行指令的模式相符，同时CPU也支持直接跳转到编号为n的指令去执行，因此计数器要支持将其值设置为n的能力。下面我们来看一下计数器的接口设计：计数器芯片有2个附加控制位reset和inc，当inc=1时，计数器在每个时钟周期自加1，其输出值为out(t)=out(t-1)+1；如果想要将计数器置为0，就将reset置为1。如果想要将计数器设置为某个值，则将load置为1，并将数值从in输入。 下图是我对计数器的实现逻辑 reset，inc，load用一个Or8way输出，只要其中有一个为1，那么register的load为就为1，register的值会被更新 3个Mux串联用于选择自增1、in的输入值、重置0这三种操作 HDL实现：计数器 /** * A 16-bit counter with load and reset control bits. * if (reset[t] == 1) out[t+1] = 0 * else if (load[t] == 1) out[t+1] = in[t] * else if (inc[t] == 1) out[t+1] = out[t] + 1 (integer addition) * else out[t+1] = out[t] */ CHIP PC { IN in[16],load,inc,reset; OUT out[16]; PARTS: Or8Way(in[0]=inc, in[1]=reset, in[2]=load, in[3..7]=false, out=ReLoad); Mux16(a=outBack, b=outPlus, sel=inc, out=loadIN); Mux16(a=loadIN, b=in, sel=load, out=resetIN); Mux16(a=resetIN, b=false, sel=reset, out=ReIn); Register(in=ReIn, load=ReLoad, out=out, out=outBack); Inc16(in=outBack, out=outPlus); } 我们以下图为例，看一下计数器是如何在时钟系统下变化数值的。 总结 至此，我们实现了hack CPU所需的所有芯片。组合逻辑芯片主要负责算数运算、逻辑运算、选择逻辑，并且通过适当的组合可以用来实现指令解析和某些功能控制；时序芯片主要负责存储数据。下一篇我们会用这些芯片搭建一个简单但实用的CPU。</summary></entry><entry><title type="html">从0到1构建计算机(3/10)–组合逻辑芯片：逻辑门、加法器、ALU</title><link href="/2019/12/16/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E9%80%BB%E8%BE%91%E9%97%A8-%E5%8A%A0%E6%B3%95%E5%99%A8-ALU.html" rel="alternate" type="text/html" title="从0到1构建计算机(3/10)--组合逻辑芯片：逻辑门、加法器、ALU" /><published>2019-12-16T00:00:00+08:00</published><updated>2019-12-16T00:00:00+08:00</updated><id>/2019/12/16/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87:%E9%80%BB%E8%BE%91%E9%97%A8%E3%80%81%E5%8A%A0%E6%B3%95%E5%99%A8%E3%80%81ALU</id><content type="html" xml:base="/2019/12/16/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E9%80%BB%E8%BE%91%E9%97%A8-%E5%8A%A0%E6%B3%95%E5%99%A8-ALU.html">&lt;p&gt;上篇说到：通过使用Nand门，我们可以实现任何逻辑门，进而实现可以一个CPU。后面我们就会搭建一个麻雀虽小但五脏俱全的计算机平台：hack。本篇我们开始第一步，实现搭建hack所需的一组芯片：组合逻辑芯片&lt;/p&gt;

&lt;h3 id=&quot;组合逻辑芯片&quot;&gt;组合逻辑芯片&lt;/h3&gt;

&lt;p&gt;一个最基本的CPU主要由两类芯片组成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;组合逻辑芯片（Combinational Chips）：与、或、非门，加法器，ALU芯片等。这些芯片主要负责逻辑计算&lt;/li&gt;
  &lt;li&gt;时序芯片（Sequential Chips）：寄存器，计数器，RAM等。这些芯片主要负责暂存数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组合逻辑芯片（下面简称逻辑芯片）可以类比为一个布尔函数，它仅负责处理逻辑运算：输出结果仅依赖于其输入变量的排列组合。逻辑芯片是没有记忆能力的，它们不能维持自身的状态，当逻辑芯片的输入值改变的时候，它们的输出值也会实时地改变。&lt;/p&gt;

&lt;p&gt;hack所需要的逻辑芯片有以下四种：基本逻辑门、多通道逻辑门、加法器、ALU（算数逻辑单元）。&lt;/p&gt;

&lt;h3 id=&quot;基本逻辑门&quot;&gt;基本逻辑门&lt;/h3&gt;
&lt;p&gt;基本逻辑门是一些简单的布尔函数的实现，我们需要的基本逻辑门如下，有1位和多位（16位）之分。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1g9yzjn8lngj30qe0mgwew.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;我们所有组合逻辑芯片都是基于Nand实现的，下面是Nand的真值表：只有当两个输入都为1时输出为0，其余输出为1反，然后输出。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga16e7ws5tj30b007s3yd.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Nand真值表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;首先我们用Nand实现一个Not。Not很简单，对其输入取反，然后输出。下面是我自己的实现方式：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga21uf1wocj30s609e3yh.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Not电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：硬件描述语言实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Not HDL实现
 * Not gate:
 * out = not in
 */

CHIP Not {
    IN in;
    OUT out;

    PARTS:
    Nand(a=in, b=in, out=out); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们继续用刚刚实现的Not和Nand组合使用，再实现一个And。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga221fwwf3j310m08mgll.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;And电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * And gate: 
 * out = 1 if (a == 1 and b == 1)
 *       0 otherwise
 */

CHIP And {
    IN a, b;
    OUT out;

    PARTS:
    Nand(a=a, b=b, out=nandOut);
    Not(in=nandOut, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多位基本逻辑门是1位基本逻辑门的简单组合，以16位And为例，用16个1位And组合成16位And.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16-bit bitwise And:
 * for i = 0..15: out[i] = (a[i] and b[i])
 */

CHIP And16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    And(a=a[0], b=b[0], out=out[0]);
    And(a=a[1], b=b[1], out=out[1]);
    And(a=a[2], b=b[2], out=out[2]);
    And(a=a[3], b=b[3], out=out[3]);
    And(a=a[4], b=b[4], out=out[4]);
    And(a=a[5], b=b[5], out=out[5]);
    And(a=a[6], b=b[6], out=out[6]);
    And(a=a[7], b=b[7], out=out[7]);
    And(a=a[8], b=b[8], out=out[8]);
    And(a=a[9], b=b[9], out=out[9]);
    And(a=a[10], b=b[10], out=out[10]);
    And(a=a[11], b=b[11], out=out[11]);
    And(a=a[12], b=b[12], out=out[12]);
    And(a=a[13], b=b[13], out=out[13]);
    And(a=a[14], b=b[14], out=out[14]);
    And(a=a[15], b=b[15], out=out[15]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;以此类推，我们可以一步步实现其他所有基本逻辑门。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;加法器&quot;&gt;加法器&lt;/h3&gt;
&lt;p&gt;有了上面实现的这些基本逻辑门，我们就可以实现CPU中一个非常重要的基本芯片：加法器。实现加法器的顺序是：半加器-&amp;gt;全加器-&amp;gt;16位加法器&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cyn6tzgj30va0d8glt.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;第一步：实现一个半加器，半加器负责计算两个一位二进制相加，输出sum和carry（进位）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xb8b2xej30sc09m74d.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;半加器&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;虽然半加器看上去跳出了布尔运算，升级到的小学数学，但其仍然可以用真值表表示，所以也就可以用基本逻辑门实现，我们用一个Xor和And就可以实现半加器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2c9rhu5bj30sa0ge3yo.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;半加器电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 半加器
 * Computes the sum of two bits.
 */

CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b 
        carry;  // Left bit of a + b

    PARTS:
    Xor(a=a, b=b, out=sum);
    And(a=a, b=b, out=carry);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;半加器只能计算两个一位二进制数相加，接着我们在输入端再加入一个进位管脚（代表低位做加法时进过来的进位），就成为了一个全加器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xom01j9j30u80de0sv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;全加器&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cemdwywj318g0gu0t1.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;全加器电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 全加器
 * Computes the sum of three bits.
 */

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, carry=carryA, sum=sumA);
    HalfAdder(a=sumA, b=c, carry=carryB, sum=sum);
    Or(a=carryA, b=carryB, out=carry);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后我们利用全加器实现16位加法器，有了16位加法器，我们就可以进行2个不大于2^16的整数的加法了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xrljwy9j30te06sdfv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;16位加法器&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16位加法器
 * Adds two 16-bit values.
 * The most significant carry bit is ignored.
 */

CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=ca0);
    FullAdder(a=a[1], b=b[1], c=ca0, sum=out[1], carry=ca1);
    FullAdder(a=a[2], b=b[2], c=ca1, sum=out[2], carry=ca2);
    FullAdder(a=a[3], b=b[3], c=ca2, sum=out[3], carry=ca3);
    FullAdder(a=a[4], b=b[4], c=ca3, sum=out[4], carry=ca4);
    FullAdder(a=a[5], b=b[5], c=ca4, sum=out[5], carry=ca5);
    FullAdder(a=a[6], b=b[6], c=ca5, sum=out[6], carry=ca6);
    FullAdder(a=a[7], b=b[7], c=ca6, sum=out[7], carry=ca7);
    FullAdder(a=a[8], b=b[8], c=ca7, sum=out[8], carry=ca8);
    FullAdder(a=a[9], b=b[9], c=ca8, sum=out[9], carry=ca9);
    FullAdder(a=a[10], b=b[10], c=ca9, sum=out[10], carry=ca10);
    FullAdder(a=a[11], b=b[11], c=ca10, sum=out[11], carry=ca11);
    FullAdder(a=a[12], b=b[12], c=ca11, sum=out[12], carry=ca12);
    FullAdder(a=a[13], b=b[13], c=ca12, sum=out[13], carry=ca13);
    FullAdder(a=a[14], b=b[14], c=ca13, sum=out[14], carry=ca14);
    FullAdder(a=a[15], b=b[15], c=ca14, sum=out[15], carry=ignorCa); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了加法器，我们再实现一个累加器，它对输入数据进行加1，然后输出。累加器是后面CPU中程序计数器的重要部分。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 累加器
 * 16-bit incrementer:
 * out = in + 1 (arithmetic addition)
 */

CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Add16(a=in, b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=false, b[5]=false, b[6]=false, b[7]=false, b[8]=false, b[9]=false, b[10]=false, b[11]=false, b[12]=false, b[13]=false, b[14]=false, b[15]=false, out=out);
}     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;多通道逻辑门&quot;&gt;多通道逻辑门&lt;/h3&gt;
&lt;p&gt;我们看到基本逻辑门负责计算布尔运算，但其只能根据输入计算出输出，缺少控制能力。下面我们介绍的多通道逻辑门则在逻辑控制方面扮演了重要角色，因为多通道逻辑门具有&lt;strong&gt;选择功能&lt;/strong&gt;。多通道逻辑门在CPU和RAM中起到了重要作用。多通道逻辑门分为以下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Multiplexor:&lt;/strong&gt; 有多路输入，一路输出，选择输入中的一路作为输出&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DMultiplexor:&lt;/strong&gt; 有一路输入，多路输出，在输出路中选择一路降输入值输出&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cyl836uj30v60meaaw.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y8t42i3j30p60dq0sv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Multiplexor&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&amp;lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y9h0fixj30me08mjrd.jpg&quot; width=&quot;600&amp;gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;DMultiplexor&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;这里我们实现一个2路1位的Mux。a，b是两路1位信号输入，sel是选择位。如果sel == 0，out管脚输出a的值，否则输出b的值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1zhhi4a2j30rm0kuq36.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;2路1位Mux电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
 * 2路1位Mux
 * Multiplexor:
 * out = a if sel == 0
 *       b otherwise
 */

CHIP Mux {
    IN a, b, sel;
    OUT out;

    PARTS:
    Not(in= sel, out=NotSel);
    And(a=a, b=NotSel, out=AndAOut);
    And(a=b, b=sel, out=AndBOut);
    Or(a=AndAOut, b=AndBOut, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然除了2路选择器，还有4路、8路、16路等多路选择器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yd61q3mj30ze09at8v.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;多路Mux&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;下面是4路16位选择器的一种实现方式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 4-way 16-bit multiplexor:
 * out = a if sel == 00
 *       b if sel == 01
 *       c if sel == 10
 *       d if sel == 11
 */

CHIP Mux4Way16 {
    IN a[16], b[16], c[16], d[16], sel[2];
    OUT out[16];

    PARTS:
    Mux16(a=a, b=b, sel=sel[0], out=outA);
    Mux16(a=c, b=d, sel=sel[0], out=outB);
    Mux16(a=outA, b=outB, sel=sel[1], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;alu&quot;&gt;ALU&lt;/h3&gt;
&lt;p&gt;有了多通道逻辑门，我们就可以进一步实现一个更为复杂的芯片：ALU。ALU是CPU的三大基本模块之一（ALU、寄存器、程序计数器）。基本逻辑门只能计算一种布尔逻辑，而ALU可以通过改变控制位输入变量的组合（zx,nz,zy,ny,f,no），可以控制实现多种计算逻辑。这类似于一个CPU可以执行指令集中的众多指令一样（当然这其中就依赖于ALU）。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cylk4d8j30uo05i3yg.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yf3rz82j30pi0i0dg1.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;ALU&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yf94f4ej314x0u0jsn.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;ALU真值表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;下面我们就用上面实现的芯片来实现一下ALU（由于比较复杂，就先不画电路图了）。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * The ALU (Arithmetic Logic Unit).
 * Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&amp;amp;y, x|y on two 16-bit inputs, 
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * In addition, the ALU computes two 1-bit outputs:
 * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;
 * if the ALU output &amp;lt; 0, ng is set to 1; otherwise ng is set to 0.
 */

// Implementation: the ALU logic manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) set x = 0        // 16-bit constant
// if (nx == 1) set x = !x       // bitwise not
// if (zy == 1) set y = 0        // 16-bit constant
// if (ny == 1) set y = !y       // bitwise not
// if (f == 1)  set out = x + y  // integer 2's complement addition
// if (f == 0)  set out = x &amp;amp; y  // bitwise and
// if (no == 1) set out = !out   // bitwise not
// if (out == 0) set zr = 1
// if (out &amp;lt; 0) set ng = 1

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute out = x + y (if 1) or x &amp;amp; y (if 0)
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out &amp;lt; 0),  0 otherwise

    PARTS:
    Mux16(a=x, b=false, sel=zx, out=zSelX);
    Not16(in=zSelX, out=notZSelx);
    Mux16(a=zSelX, b=notZSelx, sel=nx, out=outX);

    Mux16(a=y, b=false, sel=zy, out=zSelY);
    Not16(in=zSelY, out=notZSelY);
    Mux16(a=zSelY, b=notZSelY, sel=ny, out=outY);

    Add16(a=outX, b=outY, out=outAdd); // X+Y
    And16(a=outX, b=outY, out=outAnd); // X&amp;amp;Y

    Mux16(a=outAnd, b=outAdd, sel=f, out=outF);
    Not16(in=outF, out=notF);

    Mux16(a=outF, b=notF, sel=no, out=out, out[0..7]=outZrA, out[8..15]=outZrB, out[15]=outMSB);

    Or8Way(in=outZrA, out=zrL);
    Or8Way(in=outZrB, out=zrH);
    Or(a=zrL, b=zrH, out=notZr);
    Not(in=notZr, out=zr);

    And(a=true, b=outMSB, out=ng);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;补码&quot;&gt;补码&lt;/h3&gt;
&lt;p&gt;最后我们再来谈一下补码，上面我们提到的加法器都没有考虑正负符号的问题，如果引入符号，那么电路会变得更加复杂。通过使用补码可以很好的规避这个问题，因为补码有一个很重要的特性：&lt;strong&gt;任何两个用补码表示的有符号数的加法和正数的加法完全相同&lt;/strong&gt;，例如用正数加法操作（-2）+（-3），所得的结果正好是（-5）的补码；补码的减法可以用加法来代替实现，例如x-y == x+(-y)。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">上篇说到：通过使用Nand门，我们可以实现任何逻辑门，进而实现可以一个CPU。后面我们就会搭建一个麻雀虽小但五脏俱全的计算机平台：hack。本篇我们开始第一步，实现搭建hack所需的一组芯片：组合逻辑芯片 组合逻辑芯片 一个最基本的CPU主要由两类芯片组成： 组合逻辑芯片（Combinational Chips）：与、或、非门，加法器，ALU芯片等。这些芯片主要负责逻辑计算 时序芯片（Sequential Chips）：寄存器，计数器，RAM等。这些芯片主要负责暂存数据 组合逻辑芯片（下面简称逻辑芯片）可以类比为一个布尔函数，它仅负责处理逻辑运算：输出结果仅依赖于其输入变量的排列组合。逻辑芯片是没有记忆能力的，它们不能维持自身的状态，当逻辑芯片的输入值改变的时候，它们的输出值也会实时地改变。 hack所需要的逻辑芯片有以下四种：基本逻辑门、多通道逻辑门、加法器、ALU（算数逻辑单元）。 基本逻辑门 基本逻辑门是一些简单的布尔函数的实现，我们需要的基本逻辑门如下，有1位和多位（16位）之分。 芯片列表 我们所有组合逻辑芯片都是基于Nand实现的，下面是Nand的真值表：只有当两个输入都为1时输出为0，其余输出为1反，然后输出。 Nand真值表 首先我们用Nand实现一个Not。Not很简单，对其输入取反，然后输出。下面是我自己的实现方式： Not电路图 HDL实现：硬件描述语言实现。 /** * Not HDL实现 * Not gate: * out = not in */ CHIP Not { IN in; OUT out; PARTS: Nand(a=in, b=in, out=out); } 然后我们继续用刚刚实现的Not和Nand组合使用，再实现一个And。 And电路图 /** * And gate: * out = 1 if (a == 1 and b == 1) * 0 otherwise */ CHIP And { IN a, b; OUT out; PARTS: Nand(a=a, b=b, out=nandOut); Not(in=nandOut, out=out); } 多位基本逻辑门是1位基本逻辑门的简单组合，以16位And为例，用16个1位And组合成16位And. /** * 16-bit bitwise And: * for i = 0..15: out[i] = (a[i] and b[i]) */ CHIP And16 { IN a[16], b[16]; OUT out[16]; PARTS: And(a=a[0], b=b[0], out=out[0]); And(a=a[1], b=b[1], out=out[1]); And(a=a[2], b=b[2], out=out[2]); And(a=a[3], b=b[3], out=out[3]); And(a=a[4], b=b[4], out=out[4]); And(a=a[5], b=b[5], out=out[5]); And(a=a[6], b=b[6], out=out[6]); And(a=a[7], b=b[7], out=out[7]); And(a=a[8], b=b[8], out=out[8]); And(a=a[9], b=b[9], out=out[9]); And(a=a[10], b=b[10], out=out[10]); And(a=a[11], b=b[11], out=out[11]); And(a=a[12], b=b[12], out=out[12]); And(a=a[13], b=b[13], out=out[13]); And(a=a[14], b=b[14], out=out[14]); And(a=a[15], b=b[15], out=out[15]); } 以此类推，我们可以一步步实现其他所有基本逻辑门。 加法器 有了上面实现的这些基本逻辑门，我们就可以实现CPU中一个非常重要的基本芯片：加法器。实现加法器的顺序是：半加器-&amp;gt;全加器-&amp;gt;16位加法器 芯片列表 第一步：实现一个半加器，半加器负责计算两个一位二进制相加，输出sum和carry（进位）。 半加器 虽然半加器看上去跳出了布尔运算，升级到的小学数学，但其仍然可以用真值表表示，所以也就可以用基本逻辑门实现，我们用一个Xor和And就可以实现半加器。 半加器电路图 /** * 半加器 * Computes the sum of two bits. */ CHIP HalfAdder { IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry); } 半加器只能计算两个一位二进制数相加，接着我们在输入端再加入一个进位管脚（代表低位做加法时进过来的进位），就成为了一个全加器。 全加器 全加器电路图 /** * 全加器 * Computes the sum of three bits. */ CHIP FullAdder { IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, carry=carryA, sum=sumA); HalfAdder(a=sumA, b=c, carry=carryB, sum=sum); Or(a=carryA, b=carryB, out=carry); } 最后我们利用全加器实现16位加法器，有了16位加法器，我们就可以进行2个不大于2^16的整数的加法了。 16位加法器 /** * 16位加法器 * Adds two 16-bit values. * The most significant carry bit is ignored. */ CHIP Add16 { IN a[16], b[16]; OUT out[16]; PARTS: FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=ca0); FullAdder(a=a[1], b=b[1], c=ca0, sum=out[1], carry=ca1); FullAdder(a=a[2], b=b[2], c=ca1, sum=out[2], carry=ca2); FullAdder(a=a[3], b=b[3], c=ca2, sum=out[3], carry=ca3); FullAdder(a=a[4], b=b[4], c=ca3, sum=out[4], carry=ca4); FullAdder(a=a[5], b=b[5], c=ca4, sum=out[5], carry=ca5); FullAdder(a=a[6], b=b[6], c=ca5, sum=out[6], carry=ca6); FullAdder(a=a[7], b=b[7], c=ca6, sum=out[7], carry=ca7); FullAdder(a=a[8], b=b[8], c=ca7, sum=out[8], carry=ca8); FullAdder(a=a[9], b=b[9], c=ca8, sum=out[9], carry=ca9); FullAdder(a=a[10], b=b[10], c=ca9, sum=out[10], carry=ca10); FullAdder(a=a[11], b=b[11], c=ca10, sum=out[11], carry=ca11); FullAdder(a=a[12], b=b[12], c=ca11, sum=out[12], carry=ca12); FullAdder(a=a[13], b=b[13], c=ca12, sum=out[13], carry=ca13); FullAdder(a=a[14], b=b[14], c=ca13, sum=out[14], carry=ca14); FullAdder(a=a[15], b=b[15], c=ca14, sum=out[15], carry=ignorCa); } 有了加法器，我们再实现一个累加器，它对输入数据进行加1，然后输出。累加器是后面CPU中程序计数器的重要部分。 /** * 累加器 * 16-bit incrementer: * out = in + 1 (arithmetic addition) */ CHIP Inc16 { IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=false, b[5]=false, b[6]=false, b[7]=false, b[8]=false, b[9]=false, b[10]=false, b[11]=false, b[12]=false, b[13]=false, b[14]=false, b[15]=false, out=out); } 多通道逻辑门 我们看到基本逻辑门负责计算布尔运算，但其只能根据输入计算出输出，缺少控制能力。下面我们介绍的多通道逻辑门则在逻辑控制方面扮演了重要角色，因为多通道逻辑门具有选择功能。多通道逻辑门在CPU和RAM中起到了重要作用。多通道逻辑门分为以下两种： Multiplexor: 有多路输入，一路输出，选择输入中的一路作为输出 DMultiplexor: 有一路输入，多路输出，在输出路中选择一路降输入值输出 芯片列表 Multiplexor &amp;lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y9h0fixj30me08mjrd.jpg&quot; width=&quot;600&amp;gt; DMultiplexor 这里我们实现一个2路1位的Mux。a，b是两路1位信号输入，sel是选择位。如果sel == 0，out管脚输出a的值，否则输出b的值。 2路1位Mux电路图 /** * 2路1位Mux * Multiplexor: * out = a if sel == 0 * b otherwise */ CHIP Mux { IN a, b, sel; OUT out; PARTS: Not(in= sel, out=NotSel); And(a=a, b=NotSel, out=AndAOut); And(a=b, b=sel, out=AndBOut); Or(a=AndAOut, b=AndBOut, out=out); } 当然除了2路选择器，还有4路、8路、16路等多路选择器。 多路Mux 下面是4路16位选择器的一种实现方式 /** * 4-way 16-bit multiplexor: * out = a if sel == 00 * b if sel == 01 * c if sel == 10 * d if sel == 11 */ CHIP Mux4Way16 { IN a[16], b[16], c[16], d[16], sel[2]; OUT out[16]; PARTS: Mux16(a=a, b=b, sel=sel[0], out=outA); Mux16(a=c, b=d, sel=sel[0], out=outB); Mux16(a=outA, b=outB, sel=sel[1], out=out); } ALU 有了多通道逻辑门，我们就可以进一步实现一个更为复杂的芯片：ALU。ALU是CPU的三大基本模块之一（ALU、寄存器、程序计数器）。基本逻辑门只能计算一种布尔逻辑，而ALU可以通过改变控制位输入变量的组合（zx,nz,zy,ny,f,no），可以控制实现多种计算逻辑。这类似于一个CPU可以执行指令集中的众多指令一样（当然这其中就依赖于ALU）。 芯片列表 ALU ALU真值表 下面我们就用上面实现的芯片来实现一下ALU（由于比较复杂，就先不画电路图了）。 /** * The ALU (Arithmetic Logic Unit). * Computes one of the following functions: * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y, * x+1, y+1, x-1, y-1, x&amp;amp;y, x|y on two 16-bit inputs, * according to 6 input bits denoted zx,nx,zy,ny,f,no. * In addition, the ALU computes two 1-bit outputs: * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0; * if the ALU output &amp;lt; 0, ng is set to 1; otherwise ng is set to 0. */ // Implementation: the ALU logic manipulates the x and y inputs // and operates on the resulting values, as follows: // if (zx == 1) set x = 0 // 16-bit constant // if (nx == 1) set x = !x // bitwise not // if (zy == 1) set y = 0 // 16-bit constant // if (ny == 1) set y = !y // bitwise not // if (f == 1) set out = x + y // integer 2's complement addition // if (f == 0) set out = x &amp;amp; y // bitwise and // if (no == 1) set out = !out // bitwise not // if (out == 0) set zr = 1 // if (out &amp;lt; 0) set ng = 1 CHIP ALU { IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp;amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &amp;lt; 0), 0 otherwise PARTS: Mux16(a=x, b=false, sel=zx, out=zSelX); Not16(in=zSelX, out=notZSelx); Mux16(a=zSelX, b=notZSelx, sel=nx, out=outX); Mux16(a=y, b=false, sel=zy, out=zSelY); Not16(in=zSelY, out=notZSelY); Mux16(a=zSelY, b=notZSelY, sel=ny, out=outY); Add16(a=outX, b=outY, out=outAdd); // X+Y And16(a=outX, b=outY, out=outAnd); // X&amp;amp;Y Mux16(a=outAnd, b=outAdd, sel=f, out=outF); Not16(in=outF, out=notF); Mux16(a=outF, b=notF, sel=no, out=out, out[0..7]=outZrA, out[8..15]=outZrB, out[15]=outMSB); Or8Way(in=outZrA, out=zrL); Or8Way(in=outZrB, out=zrH); Or(a=zrL, b=zrH, out=notZr); Not(in=notZr, out=zr); And(a=true, b=outMSB, out=ng); } 补码 最后我们再来谈一下补码，上面我们提到的加法器都没有考虑正负符号的问题，如果引入符号，那么电路会变得更加复杂。通过使用补码可以很好的规避这个问题，因为补码有一个很重要的特性：任何两个用补码表示的有符号数的加法和正数的加法完全相同，例如用正数加法操作（-2）+（-3），所得的结果正好是（-5）的补码；补码的减法可以用加法来代替实现，例如x-y == x+(-y)。</summary></entry><entry><title type="html">从0到1构建计算机(2/10)–与非门实现CPU的数理基础</title><link href="/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80.html" rel="alternate" type="text/html" title="从0到1构建计算机(2/10)--与非门实现CPU的数理基础" /><published>2019-10-17T00:00:00+08:00</published><updated>2019-10-17T00:00:00+08:00</updated><id>/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80.html">&lt;h3 id=&quot;cpu和布尔函数&quot;&gt;CPU和布尔函数&lt;/h3&gt;

&lt;p&gt;CPU本质上是一个函数计算器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;信号通过输入管脚输入，对应着函数的入参&lt;/li&gt;
  &lt;li&gt;CPU的内部电路是函数的黑盒实现&lt;/li&gt;
  &lt;li&gt;信号通过输出管脚输出，对应着函数的出参&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdjx10y6yj31gu0och04.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;8086 CPU&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;大家有没有思考过现代计算机为什么是基于二进制的🤔？事实上，在计算机的发展历程中确实出现过其他进制的计算机，例如10进制，3进制（现在计算机也是一步步演化过来了，其某些核心设计思想甚至来源于织布机，有兴趣的同学可以翻翻计算机发展史，有助于加深对计算机原理的理解）。我认为现代计算机基于二进制的原因主要有两个：一方面是基于二进制，在物理实现上会更加容易，例如电路设计更加简单，0和1的表示也更加稳定（高低电平）；另一方面，既然CPU是函数的实现，那么就需要有完备的数学理论做支撑，其中布尔代数正好完美契合了现代计算机只能执行非常简单的算数逻辑运算集但却能够以超高速方式运行的特点。英国数学家布尔在1854年创立了布尔代数学科，布尔代数本身十分简单，但却为百年之后出现的二进制计算机提供了重要的数学方法和理论基础。&lt;/p&gt;

&lt;h3 id=&quot;布尔函数&quot;&gt;布尔函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;布尔函数：&lt;/strong&gt;布尔函数处理布尔数值(它的输入输出都是二进制数值)。布尔函数在数字计算机的芯片设计中扮演基础角色，也在密码学中扮演关键角色。&lt;/p&gt;

&lt;p&gt;布尔函数的两种表示方法：&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;真值表：&lt;/strong&gt;枚举出函数所有输入变量的组合，然后写出每一种组合对应的函数输出值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921635xlzj30d00d2wed.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;真值表&lt;/figcaption&gt;&lt;/center&gt;
&lt;p&gt;2.&lt;strong&gt;布尔表达式：&lt;/strong&gt;使用布尔操作符（And，Or，Not等）表达，上面的真值表可以用此表达式表示：&lt;/p&gt;
&lt;center&gt;f(x, y, z) = (x And y) Or (Not(x) And z)&lt;/center&gt;

&lt;h3 id=&quot;布尔函数和门&quot;&gt;布尔函数和门&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;门（gate）&lt;/strong&gt;是用来实现布尔函数的物理设备，例如与门，或门，非门，与非门等。门是基本的电子元器件，复杂的门电路就构成了CPU&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921661g24j30u004at8o.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;门有输入管脚和输出管脚，对应着布尔函数的入参和出参；门电路的具体实现方式则对应着布尔函数的运算规则。复杂的布尔函数就对应的复杂的门电路&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g92165tk1lj311g0d63yy.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;布尔函数是门电路的数学表达，门电路是布尔函数的物理实现。&lt;strong&gt;一个复杂的CPU物理实现对应着一个复杂的布尔函数设计，可以说CPU的实现是建立在布尔函数之上的。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;用与非门实现cpu的数理基础&quot;&gt;用与非门实现CPU的数理基础&lt;/h3&gt;

&lt;p&gt;布尔函数的一些数学结论：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;任何一个布尔函数，无论多复杂，都可以只用三种布尔操作符And，Or，Not完全表达。&lt;/li&gt;
  &lt;li&gt;And，Or，Not运算都可以只用Nand（与非）一种运算来代替实现，或者只用Nor（或非）一种运算来代替实现。&lt;/li&gt;
  &lt;li&gt;由1、2可得：仅使用Nand运算，就能够构建任何布尔函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;以上证明方法可以自行Google&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;有了上面的数理基础做支撑，我们可以得出结论：&lt;strong&gt;一旦我们在物理上实现了Nand（与非门），我们就能够实现任何门电路，进而实现一个CPU。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;用软件实现硬件&quot;&gt;用软件实现硬件&lt;/h3&gt;

&lt;p&gt;今天，硬件设计者们也不再亲手制作硬件了，而是用软件来实现设计：通过编写硬件描述语言（HDL）来描述芯片结构，并能通过测试用例来验证设计。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921650gf9j313r0u077e.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;好了，下面就让我们用Nand来实现一个CPU吧~&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">CPU和布尔函数 CPU本质上是一个函数计算器： 信号通过输入管脚输入，对应着函数的入参 CPU的内部电路是函数的黑盒实现 信号通过输出管脚输出，对应着函数的出参 8086 CPU 大家有没有思考过现代计算机为什么是基于二进制的🤔？事实上，在计算机的发展历程中确实出现过其他进制的计算机，例如10进制，3进制（现在计算机也是一步步演化过来了，其某些核心设计思想甚至来源于织布机，有兴趣的同学可以翻翻计算机发展史，有助于加深对计算机原理的理解）。我认为现代计算机基于二进制的原因主要有两个：一方面是基于二进制，在物理实现上会更加容易，例如电路设计更加简单，0和1的表示也更加稳定（高低电平）；另一方面，既然CPU是函数的实现，那么就需要有完备的数学理论做支撑，其中布尔代数正好完美契合了现代计算机只能执行非常简单的算数逻辑运算集但却能够以超高速方式运行的特点。英国数学家布尔在1854年创立了布尔代数学科，布尔代数本身十分简单，但却为百年之后出现的二进制计算机提供了重要的数学方法和理论基础。 布尔函数 布尔函数：布尔函数处理布尔数值(它的输入输出都是二进制数值)。布尔函数在数字计算机的芯片设计中扮演基础角色，也在密码学中扮演关键角色。 布尔函数的两种表示方法： 1.真值表：枚举出函数所有输入变量的组合，然后写出每一种组合对应的函数输出值。 真值表 2.布尔表达式：使用布尔操作符（And，Or，Not等）表达，上面的真值表可以用此表达式表示： f(x, y, z) = (x And y) Or (Not(x) And z) 布尔函数和门 门（gate）是用来实现布尔函数的物理设备，例如与门，或门，非门，与非门等。门是基本的电子元器件，复杂的门电路就构成了CPU 门有输入管脚和输出管脚，对应着布尔函数的入参和出参；门电路的具体实现方式则对应着布尔函数的运算规则。复杂的布尔函数就对应的复杂的门电路 布尔函数是门电路的数学表达，门电路是布尔函数的物理实现。一个复杂的CPU物理实现对应着一个复杂的布尔函数设计，可以说CPU的实现是建立在布尔函数之上的。 用与非门实现CPU的数理基础 布尔函数的一些数学结论： 任何一个布尔函数，无论多复杂，都可以只用三种布尔操作符And，Or，Not完全表达。 And，Or，Not运算都可以只用Nand（与非）一种运算来代替实现，或者只用Nor（或非）一种运算来代替实现。 由1、2可得：仅使用Nand运算，就能够构建任何布尔函数。 以上证明方法可以自行Google 有了上面的数理基础做支撑，我们可以得出结论：一旦我们在物理上实现了Nand（与非门），我们就能够实现任何门电路，进而实现一个CPU。 用软件实现硬件 今天，硬件设计者们也不再亲手制作硬件了，而是用软件来实现设计：通过编写硬件描述语言（HDL）来描述芯片结构，并能通过测试用例来验证设计。 好了，下面就让我们用Nand来实现一个CPU吧~</summary></entry><entry><title type="html">从0到1构建计算机(1/10)–从与非门到俄罗斯方块</title><link href="/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html" rel="alternate" type="text/html" title="从0到1构建计算机(1/10)--从与非门到俄罗斯方块" /><published>2019-10-16T00:00:00+08:00</published><updated>2019-10-16T00:00:00+08:00</updated><id>/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97</id><content type="html" xml:base="/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html">&lt;p&gt;&lt;img src=&quot;/post_image/nand_start/adam_god_nand.png&quot; alt=&quot;adam_god_nand&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mark!!! 开始学习课程：&lt;a href=&quot;https://www.nand2tetris.org/&quot;&gt;From Nand To Tetris&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本课程将从0到1地构建一个计算机，自底向上地一步步实现各种基本逻辑门、ALU、寄存器、RAM、CPU；定义机器语言、汇编语言，实现汇编器；定义高级语言，实现编译器；实现一套最简单的操作系统；最后编写一个小游戏并把它运行在这个完全由自己构建的计算机之上。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc0kvqha75j31140mcgn0.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;现代计算机是非常复杂的，复杂性之一就在于计算机一层层的封装架构（同时工业级的计算机每一层的实现也是非常复杂的），封装导致我们往往只能够看到冰山一角，至于水面下的实现原理，特色社会主义下的程序员在996的工作制之下，往往只能靠推测理解，或者通过学习一些零散的技术资料来形成一个不太完整，甚至理解有一些偏差的知识体系（我经常会陷入对某个知识点的理解是不是正确的无限自我怀疑之中）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0mo58x1fj30nq0w6467.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;

&lt;p&gt;我们把将要构建的这个计算机命名为Hack，Hack是一个麻雀虽小，但五脏俱全的冯·诺依曼架构的现代计算机。Hack极其精简，它只保留了计算机最基本的功能，一方面降低了我们的实现成本，更重要的是它把我们从计算机科学中众多复杂的实现细节中解脱出来，瞄准计算机工作的原理和本质。我们在构建Hack的同时，也加深了自己对计算机理解的准确性和系统性。&lt;/p&gt;

&lt;p&gt;还有一篇类似课程：&lt;a href=&quot;https://www.youtube.com/watch?v=WqrNphu6HaU&amp;amp;list=PLdYq_l3Bzf1elCyzIfx2JgHfSMTsWbnfg&amp;amp;index=1&quot;&gt;计算机科学速成课&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;😀😀😀&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">Mark!!! 开始学习课程：From Nand To Tetris 本课程将从0到1地构建一个计算机，自底向上地一步步实现各种基本逻辑门、ALU、寄存器、RAM、CPU；定义机器语言、汇编语言，实现汇编器；定义高级语言，实现编译器；实现一套最简单的操作系统；最后编写一个小游戏并把它运行在这个完全由自己构建的计算机之上。 现代计算机是非常复杂的，复杂性之一就在于计算机一层层的封装架构（同时工业级的计算机每一层的实现也是非常复杂的），封装导致我们往往只能够看到冰山一角，至于水面下的实现原理，特色社会主义下的程序员在996的工作制之下，往往只能靠推测理解，或者通过学习一些零散的技术资料来形成一个不太完整，甚至理解有一些偏差的知识体系（我经常会陷入对某个知识点的理解是不是正确的无限自我怀疑之中）。 我们把将要构建的这个计算机命名为Hack，Hack是一个麻雀虽小，但五脏俱全的冯·诺依曼架构的现代计算机。Hack极其精简，它只保留了计算机最基本的功能，一方面降低了我们的实现成本，更重要的是它把我们从计算机科学中众多复杂的实现细节中解脱出来，瞄准计算机工作的原理和本质。我们在构建Hack的同时，也加深了自己对计算机理解的准确性和系统性。 还有一篇类似课程：计算机科学速成课 😀😀😀</summary></entry></feed>