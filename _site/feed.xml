<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-02-19T17:39:08+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">一只草履虫</title><subtitle>Your Site Description
</subtitle><author><name>Your Name</name></author><entry><title type="html">从0到1构建计算机(6/10)–汇编语言与汇编器</title><link href="http://localhost:4000/2020/02/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%B1%87%E7%BC%96%E5%99%A8.html" rel="alternate" type="text/html" title="从0到1构建计算机(6/10)--汇编语言与汇编器" /><published>2020-02-19T00:00:00+08:00</published><updated>2020-02-19T00:00:00+08:00</updated><id>http://localhost:4000/2020/02/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%B1%87%E7%BC%96%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/2020/02/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%B1%87%E7%BC%96%E5%99%A8.html"></content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html"></summary></entry><entry><title type="html">技术书单</title><link href="http://localhost:4000/2020/02/18/%E4%B9%A6%E5%8D%95.html" rel="alternate" type="text/html" title="技术书单" /><published>2020-02-18T00:00:00+08:00</published><updated>2020-02-18T00:00:00+08:00</updated><id>http://localhost:4000/2020/02/18/%E4%B9%A6%E5%8D%95</id><content type="html" xml:base="http://localhost:4000/2020/02/18/%E4%B9%A6%E5%8D%95.html">&lt;p&gt;计算机基础：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 编码的奥秘（Charles Petzold）
* 计算机系统要素：从零开始构建现代计算机 (Noam Nisan &amp;amp; shimon Schocken)
* 程序员的自我修养--链接、装载与库 (俞甲子等)
* 深入理解计算机系统 (Randal E. Bryant)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;iOS：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* runtime技术博客 (刘小壮)
* 深入解析MacOS&amp;amp;iOS操作系统 (jonatan levin)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Your Name</name></author><category term="书单" /><category term="计算机基础" /><summary type="html">计算机基础： * 编码的奥秘（Charles Petzold） * 计算机系统要素：从零开始构建现代计算机 (Noam Nisan &amp;amp; shimon Schocken) * 程序员的自我修养--链接、装载与库 (俞甲子等) * 深入理解计算机系统 (Randal E. Bryant) iOS： * runtime技术博客 (刘小壮) * 深入解析MacOS&amp;amp;iOS操作系统 (jonatan levin)</summary></entry><entry><title type="html">从0到1构建计算机(5/10)–实现hack：计算机架构、内存、CPU和指令集</title><link href="http://localhost:4000/2020/02/01/hack-CPU%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8C%87%E4%BB%A4%E9%9B%86.html" rel="alternate" type="text/html" title="从0到1构建计算机(5/10)--实现hack：计算机架构、内存、CPU和指令集" /><published>2020-02-01T00:00:00+08:00</published><updated>2020-02-01T00:00:00+08:00</updated><id>http://localhost:4000/2020/02/01/hack%20CPU%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8C%87%E4%BB%A4%E9%9B%86</id><content type="html" xml:base="http://localhost:4000/2020/02/01/hack-CPU%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8C%87%E4%BB%A4%E9%9B%86.html">&lt;p&gt;经过前两篇我们已经实现了所有的组合逻辑芯片和时序芯片，具备了实现hack计算机的基础，本篇是项目硬件部分的最后一篇，我们将在本篇定义hack能够执行的操作，即hack的指令集；实现hack的内存、CPU，然后将它们组合起来形成完整的计算机硬件架构。&lt;/p&gt;

&lt;h3 id=&quot;计算机架构&quot;&gt;计算机架构&lt;/h3&gt;

&lt;p&gt;hack是基于经典的冯·诺伊曼体系架构，它的关键组成部分是将中央处理单元和存储器，通过存储器中存储的程序指令控制中央处理器的执行，即存储程序计算机。它主要有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;以运算单元为中心&lt;/li&gt;
  &lt;li&gt;采用存储程序原理&lt;/li&gt;
  &lt;li&gt;存储器是按地址访问、线性编址的空间&lt;/li&gt;
  &lt;li&gt;控制流由指令流产生&lt;/li&gt;
  &lt;li&gt;指令由操作码和地址码组成&lt;/li&gt;
  &lt;li&gt;数据以二进制编码&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbgwoausqdj31b00p20t8.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;指令集机器语言&quot;&gt;指令集（机器语言）&lt;/h3&gt;
&lt;p&gt;我们可以从两个角度来理解CPU，一个是从机器语言的角度，一个是从物理实现的角度。&lt;strong&gt;机器语言是CPU的功能抽象，物理实现是CPU的具体实现，同时机器语言还是计算机系统硬件层和软件层的接口。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想要实现CPU，我们首先要定义CPU能执行哪些操作，然后把这些操作抽象为CPU的指令集。CPU的指令集就是一系列的操作约定，它们以格式化的指令，描述了如何用CPU来操作内存。我们已x86的指令集为例，x86的指令集非常复杂，有几百条指令，包括数据传输指令、算数运算指令、逻辑运算指令、位移指令、字符串操作指令、处理器控制指令、控制转移指令等&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh0f43rzqj312h0u0wk4.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;我们会抛弃诸多复杂的指令，只实现一个CPU所需的最必须的功能，以方便实现，但更重要的是方便我们理解计算机系统硬件设计运行的最基本原理。我们可以梳理出最必须的4点功能：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从内存中读取某地址的数据（包括指令数据），传送到CPU&lt;/li&gt;
  &lt;li&gt;CPU进行基本的算数&amp;amp;逻辑运算&lt;/li&gt;
  &lt;li&gt;CPU把数据写入内存或寄存器&lt;/li&gt;
  &lt;li&gt;CPU跳转到某地址执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实现时，我们只需设计两条指令就可以满足上面的4点功能，你没听错，只需要两条。再介绍这两条指令之前，我们先介绍下CPU中需要用到的2个寄存器，A寄存器：用于暂存一个立即数（通常是将要用到的内存地址的值）；D寄存器：用于暂存计算过程中的中间数据。回顾一下前两篇的内容，我们实现的芯片的最大字长都16位，所以我们的指令也是16位的。&lt;/p&gt;

&lt;h4 id=&quot;a指令&quot;&gt;A指令&lt;/h4&gt;
&lt;p&gt;A指令，即Address指令。它的功能很简单，就是把一个数值传送到CPU中的A寄存器即可，多数情况下这个数字后续会当做地址使用，用于定位内存中的存储单元。我们来看一下A指令的格式，A指令把16位数据分成两部分：第一位是标志位，为0时就代表该指令是A指令，剩下的15位就是需要传入A寄存器的数值。可以看到，A指令实现了上面4点功能的第一点。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh0rj8yj6j30we0480sn.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;c指令&quot;&gt;C指令&lt;/h4&gt;
&lt;p&gt;C指令较为复杂，分成4部分。A指令实现了上面4点功能的后三点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一位是标志位：为1时就代表该指令是C指令&lt;/li&gt;
  &lt;li&gt;3-10位是comp位：：这几位的排列用于表示执行不同的元素&amp;amp;逻辑运算&lt;/li&gt;
  &lt;li&gt;11——13位是dest位：指示需要把计算出的数据传送到哪里（寄存器或内存）&lt;/li&gt;
  &lt;li&gt;14-16位是jump位：指示CPU执行跳转指令的条件&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh0v8yf1cj311604st8o.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;comp位，copm位主要作用于CPU中的ALU，指示ALU来进行一些算数运算和逻辑运算，操作数就是A寄存器，D寄存器，或者由A寄存器中的地址指向的内存单元中的数据。操作列表如下：&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh153x9nkj30w20rawf4.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;通过comp位的指示ALU计算出的数值，再传送到由dest位指示的存储单元，这个存储单元是A寄存器，D寄存器，或者由A寄存器中的地址指向的内存单元，或者是他们的组合。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh18hc1zaj31040d2ab1.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;大多数情况下，CPU是顺序执行的，但也需要进行跳转执行。jump的执行逻辑是，根据comp位输出的数据，用jump位判断是否需要跳转，如果需要，则跳转到A寄存器中地址的指令，否则按顺序执行下一条指令。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh1e9lupsj30vg0e8mxu.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;一些符号&quot;&gt;一些符号&lt;/h4&gt;
&lt;p&gt;同时，我们提前介绍一些预定义的符号，符号的作用是便于我们后续编写hack的汇编语言。所需的符号类型如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;预定义符号：有汇编语言中特殊含义的符号&lt;/li&gt;
  &lt;li&gt;虚拟寄存器：代表一些虚拟寄存器中的地址&lt;/li&gt;
  &lt;li&gt;预定义指针：指向一些特定的内存&lt;/li&gt;
  &lt;li&gt;I/O指针：指向内存中I/O的其实地址&lt;/li&gt;
  &lt;li&gt;标签符号：用于表示指令的位置（方便编写跳转逻辑）&lt;/li&gt;
  &lt;li&gt;变量符号：方便在汇编代码中声明变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内存&quot;&gt;内存&lt;/h3&gt;
&lt;p&gt;我们在时序芯片里已经实现了RAM芯片，所以实现内存的工作已经基本完成。本篇主要是对内存的使用、组合和划分。内存按照功能划分，主要分为数据内存和指令内存两部分，正常时情况数据内存和指令内存是在一块大内存下划分的，是操作系统帮开发者分配管理的，这里我们为了更方便的实现，把hack的内存拆成量块：一块数据内存Memory，一块ROM，ROM专门用于存储程序，在程序运行期间不支持写入操作。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh3erthk6j312e0o2mxq.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;同时把Memory划分为3部分：RAM（16K），用于存储数据；Screen（8K）内存映射到显示器；Keyboard（16bit）内存映射到键盘。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh2ausrj0j30uo0lu0tf.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：Memory&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CHIP Memory {
    IN in[16], load, address[15];
    OUT out[16];

    PARTS:
    DMux4Way(in=true, sel[0..1]=address[13..14], a=a, b=b, c=c, d=d);

    Or(a=a, b=b, out=outa);

    And(a=outa, b=load, out=load0);
    And(a=c, b=load, out=load1);

    RAM16K(in=in, load=load0, address[0..13]=address[0..13], out=R0);
    Screen(in=in, load=load1, address[0..12]=address[0..12], out=R1);
    Keyboard(out=R2);

    Mux4Way16(a=R0, b=R0, c=R1, d=R2, sel[0..1]=address[13..14], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;
&lt;p&gt;定义完指令集，我们接着需要做的就是按照指令功能实现CPU。hack的CPU主要由以下四部分组成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ALU：主要用于执行算数&amp;amp;逻辑运算&lt;/li&gt;
  &lt;li&gt;寄存器：A寄存器、D寄存器&lt;/li&gt;
  &lt;li&gt;PC：程序计数器，保存下一条指令地址&lt;/li&gt;
  &lt;li&gt;控制逻辑：解析指令类型，选择寄存器，更新PC等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CPU的电路示意图如下(完整电路图比较难画，先不画了）&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh319ez5ij31800rct9n.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：CPU&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
    // 指令类型解析
    And(a=instruction[15], b=true, out=ins15);          // ins15指令标志位
    Not(in=instruction[15], out=ins15Not);       // ins15Not:指令标志位取反

    // A指令和A寄存器
    Mux16(a=instruction, b=ALUOut, sel=instruction[5], out=ARSel);
    Mux16(a=instruction, b=ARSel, sel=ins15, out=ARIn);
    Or(a=ins15Not, b=instruction[5], out=ARLoad);
    ARegister(in=ARIn, load=ARLoad, out=AROut);

    // D寄存器
    And(a=ins15, b=instruction[4], out=DRLoad);
    DRegister(in=ALUOut, load=DRLoad, out=DROut);

    // C指令类型区分：计算A还是计算M
    Mux16(a=AROut, b=inM, sel=instruction[12], out=AMOut);

    // ALU逻辑
    ALU(x=DROut, y=AMOut, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], out=ALUOut, zr=ALUzr, ng=ALUng);

    // outM &amp;amp; writeM &amp;amp; addressM
    And16(a=true, b=ALUOut, out=outM);
    And(a=ins15, b=instruction[3], out=writeM);
    And16(a=true, b=AROut, out[0..14]=addressM[0..14]);

    // jump逻辑
    And(a=ALUng, b=instruction[2], out=j1Out);
    And(a=ALUzr, b=instruction[1], out=j2Out);
    Or(a=ALUng, b=ALUzr, out=po);
    Not(in=po, out=ALUpo);
    And(a=ALUpo, b=instruction[0], out=j3Out);
    Or8Way(in[0]=j1Out, in[1]=j2Out, in[2]=j3Out, in[3..7]=false, out=jump);
    And(a=ins15, b=jump, out=jumpOut);

    // PC
    PC(in=AROut, load=jumpOut, inc=true, reset=reset, out[0..14]=pc[0..14]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;combination&quot;&gt;COMBINATION&lt;/h3&gt;

&lt;p&gt;最后我们按照整体架构图，把CPU、ROM、RAM连接起来即可。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh27xo7nej31bg0ok0tw.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * The HACK computer, including CPU, ROM and RAM.
 * When reset is 0, the program stored in the computer's ROM executes.
 * When reset is 1, the execution of the program restarts. 
 * Thus, to start a program's execution, reset must be pushed &quot;up&quot; (1)
 * and &quot;down&quot; (0). From this point onward the user is at the mercy of 
 * the software. In particular, depending on the program's code, the 
 * screen may show some output and the user may be able to interact 
 * with the computer via the keyboard.
 */

CHIP Computer {

    IN reset;

    PARTS:
    CPU(inM=memoryOut, instruction=ROMOut, reset=reset, outM=outM, writeM=writeM, addressM=addressM, pc=pc);
    ROM32K(address=pc, out=ROMOut);
    Memory(in=outM, load=writeM, address=addressM, out=memoryOut);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;至此，我们就完了hack硬件部分的所有工作。我们基于两个基本们：Nand和DFF，一步步实现了诸多芯片，最终实现了整个硬件架构。hack虽小，五脏俱全，我们只保留了计算机架构中最核心的部分，&lt;strong&gt;减少了我们的工作量，更重要的是方便我们拨开众多复杂的技术细节，清楚的了解到计算机体系最核心的设计思想&lt;/strong&gt;。完成了hack的硬件系统和指令集的定义，我们就可以编写一个用0101写的hello world程序了，但这貌似有些痛苦，所以我们会在下一篇定义hack的汇编语言，并编写汇编器。😀&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbh3i0sxnoj310s0u03zp.jpg&quot; width=&quot;700&quot; /&gt;&lt;/center&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">经过前两篇我们已经实现了所有的组合逻辑芯片和时序芯片，具备了实现hack计算机的基础，本篇是项目硬件部分的最后一篇，我们将在本篇定义hack能够执行的操作，即hack的指令集；实现hack的内存、CPU，然后将它们组合起来形成完整的计算机硬件架构。 计算机架构 hack是基于经典的冯·诺伊曼体系架构，它的关键组成部分是将中央处理单元和存储器，通过存储器中存储的程序指令控制中央处理器的执行，即存储程序计算机。它主要有以下几个特点： 以运算单元为中心 采用存储程序原理 存储器是按地址访问、线性编址的空间 控制流由指令流产生 指令由操作码和地址码组成 数据以二进制编码 指令集（机器语言） 我们可以从两个角度来理解CPU，一个是从机器语言的角度，一个是从物理实现的角度。机器语言是CPU的功能抽象，物理实现是CPU的具体实现，同时机器语言还是计算机系统硬件层和软件层的接口。 想要实现CPU，我们首先要定义CPU能执行哪些操作，然后把这些操作抽象为CPU的指令集。CPU的指令集就是一系列的操作约定，它们以格式化的指令，描述了如何用CPU来操作内存。我们已x86的指令集为例，x86的指令集非常复杂，有几百条指令，包括数据传输指令、算数运算指令、逻辑运算指令、位移指令、字符串操作指令、处理器控制指令、控制转移指令等 我们会抛弃诸多复杂的指令，只实现一个CPU所需的最必须的功能，以方便实现，但更重要的是方便我们理解计算机系统硬件设计运行的最基本原理。我们可以梳理出最必须的4点功能： 从内存中读取某地址的数据（包括指令数据），传送到CPU CPU进行基本的算数&amp;amp;逻辑运算 CPU把数据写入内存或寄存器 CPU跳转到某地址执行 在实现时，我们只需设计两条指令就可以满足上面的4点功能，你没听错，只需要两条。再介绍这两条指令之前，我们先介绍下CPU中需要用到的2个寄存器，A寄存器：用于暂存一个立即数（通常是将要用到的内存地址的值）；D寄存器：用于暂存计算过程中的中间数据。回顾一下前两篇的内容，我们实现的芯片的最大字长都16位，所以我们的指令也是16位的。 A指令 A指令，即Address指令。它的功能很简单，就是把一个数值传送到CPU中的A寄存器即可，多数情况下这个数字后续会当做地址使用，用于定位内存中的存储单元。我们来看一下A指令的格式，A指令把16位数据分成两部分：第一位是标志位，为0时就代表该指令是A指令，剩下的15位就是需要传入A寄存器的数值。可以看到，A指令实现了上面4点功能的第一点。 C指令 C指令较为复杂，分成4部分。A指令实现了上面4点功能的后三点 第一位是标志位：为1时就代表该指令是C指令 3-10位是comp位：：这几位的排列用于表示执行不同的元素&amp;amp;逻辑运算 11——13位是dest位：指示需要把计算出的数据传送到哪里（寄存器或内存） 14-16位是jump位：指示CPU执行跳转指令的条件 comp位，copm位主要作用于CPU中的ALU，指示ALU来进行一些算数运算和逻辑运算，操作数就是A寄存器，D寄存器，或者由A寄存器中的地址指向的内存单元中的数据。操作列表如下： 通过comp位的指示ALU计算出的数值，再传送到由dest位指示的存储单元，这个存储单元是A寄存器，D寄存器，或者由A寄存器中的地址指向的内存单元，或者是他们的组合。 大多数情况下，CPU是顺序执行的，但也需要进行跳转执行。jump的执行逻辑是，根据comp位输出的数据，用jump位判断是否需要跳转，如果需要，则跳转到A寄存器中地址的指令，否则按顺序执行下一条指令。 一些符号 同时，我们提前介绍一些预定义的符号，符号的作用是便于我们后续编写hack的汇编语言。所需的符号类型如下： 预定义符号：有汇编语言中特殊含义的符号 虚拟寄存器：代表一些虚拟寄存器中的地址 预定义指针：指向一些特定的内存 I/O指针：指向内存中I/O的其实地址 标签符号：用于表示指令的位置（方便编写跳转逻辑） 变量符号：方便在汇编代码中声明变量 内存 我们在时序芯片里已经实现了RAM芯片，所以实现内存的工作已经基本完成。本篇主要是对内存的使用、组合和划分。内存按照功能划分，主要分为数据内存和指令内存两部分，正常时情况数据内存和指令内存是在一块大内存下划分的，是操作系统帮开发者分配管理的，这里我们为了更方便的实现，把hack的内存拆成量块：一块数据内存Memory，一块ROM，ROM专门用于存储程序，在程序运行期间不支持写入操作。 同时把Memory划分为3部分：RAM（16K），用于存储数据；Screen（8K）内存映射到显示器；Keyboard（16bit）内存映射到键盘。 HDL实现：Memory CHIP Memory { IN in[16], load, address[15]; OUT out[16]; PARTS: DMux4Way(in=true, sel[0..1]=address[13..14], a=a, b=b, c=c, d=d); Or(a=a, b=b, out=outa); And(a=outa, b=load, out=load0); And(a=c, b=load, out=load1); RAM16K(in=in, load=load0, address[0..13]=address[0..13], out=R0); Screen(in=in, load=load1, address[0..12]=address[0..12], out=R1); Keyboard(out=R2); Mux4Way16(a=R0, b=R0, c=R1, d=R2, sel[0..1]=address[13..14], out=out); } CPU 定义完指令集，我们接着需要做的就是按照指令功能实现CPU。hack的CPU主要由以下四部分组成： ALU：主要用于执行算数&amp;amp;逻辑运算 寄存器：A寄存器、D寄存器 PC：程序计数器，保存下一条指令地址 控制逻辑：解析指令类型，选择寄存器，更新PC等 CPU的电路示意图如下(完整电路图比较难画，先不画了） HDL实现：CPU CHIP CPU { IN inM[16], // M value input (M = contents of RAM[A]) instruction[16], // Instruction for execution reset; // Signals whether to re-start the current // program (reset==1) or continue executing // the current program (reset==0). OUT outM[16], // M value output writeM, // Write to M? addressM[15], // Address in data memory (of M) pc[15]; // address of next instruction PARTS: // 指令类型解析 And(a=instruction[15], b=true, out=ins15); // ins15指令标志位 Not(in=instruction[15], out=ins15Not); // ins15Not:指令标志位取反 // A指令和A寄存器 Mux16(a=instruction, b=ALUOut, sel=instruction[5], out=ARSel); Mux16(a=instruction, b=ARSel, sel=ins15, out=ARIn); Or(a=ins15Not, b=instruction[5], out=ARLoad); ARegister(in=ARIn, load=ARLoad, out=AROut); // D寄存器 And(a=ins15, b=instruction[4], out=DRLoad); DRegister(in=ALUOut, load=DRLoad, out=DROut); // C指令类型区分：计算A还是计算M Mux16(a=AROut, b=inM, sel=instruction[12], out=AMOut); // ALU逻辑 ALU(x=DROut, y=AMOut, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], out=ALUOut, zr=ALUzr, ng=ALUng); // outM &amp;amp; writeM &amp;amp; addressM And16(a=true, b=ALUOut, out=outM); And(a=ins15, b=instruction[3], out=writeM); And16(a=true, b=AROut, out[0..14]=addressM[0..14]); // jump逻辑 And(a=ALUng, b=instruction[2], out=j1Out); And(a=ALUzr, b=instruction[1], out=j2Out); Or(a=ALUng, b=ALUzr, out=po); Not(in=po, out=ALUpo); And(a=ALUpo, b=instruction[0], out=j3Out); Or8Way(in[0]=j1Out, in[1]=j2Out, in[2]=j3Out, in[3..7]=false, out=jump); And(a=ins15, b=jump, out=jumpOut); // PC PC(in=AROut, load=jumpOut, inc=true, reset=reset, out[0..14]=pc[0..14]); } COMBINATION 最后我们按照整体架构图，把CPU、ROM、RAM连接起来即可。 HDL实现 /** * The HACK computer, including CPU, ROM and RAM. * When reset is 0, the program stored in the computer's ROM executes. * When reset is 1, the execution of the program restarts. * Thus, to start a program's execution, reset must be pushed &quot;up&quot; (1) * and &quot;down&quot; (0). From this point onward the user is at the mercy of * the software. In particular, depending on the program's code, the * screen may show some output and the user may be able to interact * with the computer via the keyboard. */ CHIP Computer { IN reset; PARTS: CPU(inM=memoryOut, instruction=ROMOut, reset=reset, outM=outM, writeM=writeM, addressM=addressM, pc=pc); ROM32K(address=pc, out=ROMOut); Memory(in=outM, load=writeM, address=addressM, out=memoryOut); } 总结 至此，我们就完了hack硬件部分的所有工作。我们基于两个基本们：Nand和DFF，一步步实现了诸多芯片，最终实现了整个硬件架构。hack虽小，五脏俱全，我们只保留了计算机架构中最核心的部分，减少了我们的工作量，更重要的是方便我们拨开众多复杂的技术细节，清楚的了解到计算机体系最核心的设计思想。完成了hack的硬件系统和指令集的定义，我们就可以编写一个用0101写的hello world程序了，但这貌似有些痛苦，所以我们会在下一篇定义hack的汇编语言，并编写汇编器。😀</summary></entry><entry><title type="html">从0到1构建计算机(4/10)–时序逻辑芯片：时序门、寄存器、RAM、计数器</title><link href="http://localhost:4000/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E6%97%B6%E5%BA%8F%E9%97%A8-%E5%AF%84%E5%AD%98%E5%99%A8-RAM-%E8%AE%A1%E6%95%B0%E5%99%A8.html" rel="alternate" type="text/html" title="从0到1构建计算机(4/10)--时序逻辑芯片：时序门、寄存器、RAM、计数器" /><published>2020-01-29T00:00:00+08:00</published><updated>2020-01-29T00:00:00+08:00</updated><id>http://localhost:4000/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87:%E6%97%B6%E5%BA%8F%E9%97%A8%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81RAM%E3%80%81%E8%AE%A1%E6%95%B0%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/2020/01/29/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E6%97%B6%E5%BA%8F%E9%97%A8-%E5%AF%84%E5%AD%98%E5%99%A8-RAM-%E8%AE%A1%E6%95%B0%E5%99%A8.html">&lt;p&gt;上一篇我们实现了一系列组合逻辑芯片和CPU的运算大脑：ALU，但是组合逻辑芯片是一个实时系统，只要输入值改变了输出值也马上跟着改变，上一秒辛苦计算出来的值，下一秒就消失不见了，因此我们需要一个具备”记忆功能”的原件，用于存储数据。这就是我们本篇要介绍的：时序逻辑芯片。&lt;/p&gt;

&lt;h3 id=&quot;反馈电路时钟系统d触发器&quot;&gt;反馈电路、时钟系统、D触发器&lt;/h3&gt;

&lt;p&gt;组合逻辑芯片之所以无法记住上一次计算的值，是因为电流信息的流向是单向的，它总是向前流动，导致我们无法两次踏入同一条河流。要解决这个问题也很简单，我们引一条导线让数据回流，形成一个环路即可（即形成反馈）。下图就是用OR门加上一路环路构成的一位存储器，但他的缺点是只能记忆一次1的输入，后续无论输入如何改变，输出总是为1。如果想要实现功能更强大的记忆芯片就需要更复杂的电路设计，但仍然是基于门的输出再重新作为输入的原理。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdrumxqvgj30l60740sl.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;提到”记忆”就不能不涉及到”时间”，计算机中的时间是基于震荡时钟系统的，震荡时钟提供连续的交变信号（高低电平）从而形成离散的时间周期。时钟周期是计算机系统中各元器件能整齐划一，协调同步的工作的基础。当一个时钟周期到来时，计算机的各个元器件必须抓紧在本次周期内完成自己的任务，然后停下来安静等待下一个周期的来临（这也是为什么时钟频率通常被当做衡量计算机性能的重要指标，因为频率越高，单位时间内计算机完成的工作步骤就越多）。例如只有当时钟上升沿到来时，各时序芯片才会瞬间改变状态，其余时间保持状态锁定。如果把CPU、内存、输入输出设备比作乐团中各个乐器的乐手，那么时钟系统就是计算机乐团的乐队指挥。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeiyf35ixj313e02edft.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;在搭建hack的时候，我们一共用到了两个基本芯片（即不用自己实现的芯片），一个是上一篇用于搭建组合逻辑芯片系统的Nand，另外一个就是本片用于搭建时序逻辑芯片的DFF（data Flip-Flop：D触发器）。DFF的结构由R-S锁存器派生而来。（DFF的实现相对复杂，如果对锁存器和DFF感兴趣，可以参考《编码的奥秘》Charles Petzold）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0yzm52nxj317y0iy753.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;边沿触发的D型触发器&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;DFF包含1bit的输入和1bit的输出，另外DFF有一个时钟输入（图中的小三角代表时钟输入），DFF根据数据输入位和时钟输入位的输入实现了out(t)=in(t-1)，即DFF简单的将前一个时间周期的输入值作为当前时间周期的输出值。这是DFF具备记忆功能的表现，也是我们后续实现16bit寄存器，16K、64K、256K等RAM的基础。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbek01supqj30dq05kaa4.jpg&quot; width=&quot;250&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;1位寄存器和16位寄存器&quot;&gt;1位寄存器和16位寄存器&lt;/h3&gt;
&lt;p&gt;有了DFF的记忆功能，我们接下来先实现最简单1bit寄存器和16bit寄存器。1bit寄存器的接口包括：in输入管脚，负责传输输入数据；load管脚，load管脚是控制位，只有当load为1的时候，才会存储in的输入数据；out管脚输出当前存储的值。接口如下所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbec5aygpzj311i08y3yr.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;1bit芯片很好实现，主要是实现load位的控制功能即可，根据芯片描述可以把芯片设计为：load为1时选择输入in的数据，load为0时选择输入上一次寄存器保存的数据。这种选择功能正好是上一篇我们实现的Multiplexor芯片（后面在实现RAM的时候，Multiplexor在地址选择中的作用体现得更加明显）。1bit寄存器内部实现如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbece9ixdnj30gc0ceaa5.jpg&quot; width=&quot;400&quot; /&gt;&lt;/center&gt;

&lt;p&gt;然后我们用硬件描述语言（HDL）实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 1-bit register:
 * If load[t] == 1 then out[t+1] = in[t]
 *                 else out does not change (out[t+1] = out[t])
 */

CHIP Bit {
    IN in, load;
    OUT out;

    PARTS:
    Mux(a=outBack, b=in, sel=load, out=dffIn);
    DFF(in=dffIn, out=out, out=outBack);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有1bit寄存器，16bit寄存器可以看做是16个1bit寄存器的组合：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbecp634wwj30h80amdfw.jpg&quot; width=&quot;400&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：16bit寄存器&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16-bit register:
 * If load[t] == 1 then out[t+1] = in[t]
 * else out does not change
 */

CHIP Register {
    IN in[16], load;
    OUT out[16];

    PARTS:
    Mux(a=outBack0, b=in[0], sel=load, out=dffIn0);
    DFF(in=dffIn0, out=out[0], out=outBack0);

    Mux(a=outBack1, b=in[1], sel=load, out=dffIn1);
    DFF(in=dffIn1, out=out[1], out=outBack1);

    Mux(a=outBack2, b=in[2], sel=load, out=dffIn2);
    DFF(in=dffIn2, out=out[2], out=outBack2);

    Mux(a=outBack3, b=in[3], sel=load, out=dffIn3);
    DFF(in=dffIn3, out=out[3], out=outBack3);

    Mux(a=outBack4, b=in[4], sel=load, out=dffIn4);
    DFF(in=dffIn4, out=out[4], out=outBack4);

    Mux(a=outBack5, b=in[5], sel=load, out=dffIn5);
    DFF(in=dffIn5, out=out[5], out=outBack5);

    // ...6到15
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ram&quot;&gt;RAM&lt;/h3&gt;
&lt;p&gt;接着我们来实现计算机中另一个非常重要的组成部分：RAM。刚才看到，16bit寄存器可以由16个1bit的寄存器组合而成，同理一个mKB的RAM，可以由n个16位寄存器组合而成，16位寄存器就是RAM中的基本存储单元，寄存器的宽度（此处是16位）就是RAM”字”（WORD）的宽度。我们都知道，需要通过地址来访问RAM，RAM中每个寄存器都绑定到一个唯一地址。下图是RAM的接口设计，RAM有三种输入：数据输入，地址输入和加载位。地址指定了当前周期RAM中哪一个寄存器被访问，当进行读操作时（load=0），RAM立即输出被选中的寄存器的值，当进行写操作时（load=1），被选中的寄存器被赋予新的值，从下个周期开始RAM将开始发出新的值。输入和输出的数据宽度就是RAM”字”的宽度。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbedozihymj30ki0lsjro.jpg&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;

&lt;p&gt;接下来我们要实现RAM8，RAM64，RAM512，RAM4K，RAM16K几种内存容量的RAM。RAMn中的n即代表RAM中有n个寄存器。例如RAM16K中有16K个16位寄存器，那么他的内存容量就是16K*(16/2)byte=32Kbyte。想要实现一个RAMn芯片，我们需要在RAMn芯片中集成n个寄存器，外加一些列控制逻辑（处理load）和地址选择逻辑，那么涉及到选择逻辑自然少不了Multiplexor和DMultiplexor。那么下面我们以RAM8为例讲一下我自己的实现方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;RAM8中有8个寄存器&lt;/li&gt;
  &lt;li&gt;8个寄存器有8个地址，所以我们的地址位需要2^n=8, n=3位&lt;/li&gt;
  &lt;li&gt;DMux用于解析写入时的地址，用3位sel分离出需要写入的那一路，再和load做与操作后作为寄存器的load位输入，最终通过load位来决定哪一个寄存器被写入In。&lt;/li&gt;
  &lt;li&gt;Mux用于解析读取时的地址，用3位sel在8个寄存器中选择想要读取的那一路数据&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbef8oh05tj31ca0qywfd.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：RAM8&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 8 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel=address, a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    Register(in=in, load=load0, out=R0);
    Register(in=in, load=load1, out=R1);
    Register(in=in, load=load2, out=R2);
    Register(in=in, load=load3, out=R3);
    Register(in=in, load=load4, out=R4);
    Register(in=in, load=load5, out=R5);
    Register(in=in, load=load6, out=R6);
    Register(in=in, load=load7, out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel=address, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了RAM8，我们就可以利用8个RAM8的组合实现RAM64，以此类推实现后面容量更大的RAM。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实现RAM64的技巧是对地址位的拆分，RAM64需要6个地址位，把6个地址为拆分为3+3&lt;/li&gt;
  &lt;li&gt;和实现RAM8的时候类似，需要引入一组Mux和DMux，这组选择芯片使用6位地址中的高三位，通过高3位把地址初步划分为8个地址段，每个地址段的容量即RAM8中寄存器的数量&lt;/li&gt;
  &lt;li&gt;每个RAM8使用6位地址中的低三位，然后从中定位到目标地址寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeg2r9r8oj30wu0loaab.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：RAM64&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 64 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM64 {
    IN in[16], load, address[6];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    RAM8(in=in, load=load0, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R0);
    RAM8(in=in, load=load1, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R1);
    RAM8(in=in, load=load2, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R2);
    RAM8(in=in, load=load3, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R3);
    RAM8(in=in, load=load4, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R4);
    RAM8(in=in, load=load5, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R5);
    RAM8(in=in, load=load6, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R6);
    RAM8(in=in, load=load7, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HDL实现：RAM4K&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Memory of 4K registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM4K {
    IN in[16], load, address[12];
    OUT out[16];

    PARTS:
    DMux8Way(in=true, sel[0..2]=address[9..11], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);

    And(a=a, b=load, out=load0);
    And(a=b, b=load, out=load1);
    And(a=c, b=load, out=load2);
    And(a=d, b=load, out=load3);
    And(a=e, b=load, out=load4);
    And(a=f, b=load, out=load5);
    And(a=g, b=load, out=load6);
    And(a=h, b=load, out=load7);

    RAM512(in=in, load=load0, address[0..8]=address[0..8], out=R0);
    RAM512(in=in, load=load1, address[0..8]=address[0..8], out=R1);
    RAM512(in=in, load=load2, address[0..8]=address[0..8], out=R2);
    RAM512(in=in, load=load3, address[0..8]=address[0..8], out=R3);
    RAM512(in=in, load=load4, address[0..8]=address[0..8], out=R4);
    RAM512(in=in, load=load5, address[0..8]=address[0..8], out=R5);
    RAM512(in=in, load=load6, address[0..8]=address[0..8], out=R6);
    RAM512(in=in, load=load7, address[0..8]=address[0..8], out=R7);

    Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0..2]=address[9..11], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;至此，我们了解了RAM中内存访问的方式。在RAM中的存储单元可以通过解析地址信号来进行随机的访问，而不会受限于存储单元的位置，访问任何位置的存储单元的速度都是相等的，例如访问内存中一个数组中任意下标的数据的速度都是相等的。这也是Random Access Memory概念的由来。&lt;/p&gt;

&lt;h3 id=&quot;计数器&quot;&gt;计数器&lt;/h3&gt;
&lt;p&gt;计数器也是CPU中一个重要的原件，主要用来存储将要执行指令的内存地址。在大多数情况下，计数器每个周期简单的进行+1操作，这时计算机能够获取下一条地址，这和CPU顺序执行指令的模式相符，同时CPU也支持直接跳转到编号为n的指令去执行，因此计数器要支持将其值设置为n的能力。下面我们来看一下计数器的接口设计：计数器芯片有2个附加控制位reset和inc，当inc=1时，计数器在每个时钟周期自加1，其输出值为out(t)=out(t-1)+1；如果想要将计数器置为0，就将reset置为1。如果想要将计数器设置为某个值，则将load置为1，并将数值从in输入。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbeis1709vj30l007it8p.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;下图是我对计数器的实现逻辑&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reset，inc，load用一个Or8way输出，只要其中有一个为1，那么register的load为就为1，register的值会被更新&lt;/li&gt;
  &lt;li&gt;3个Mux串联用于选择自增1、in的输入值、重置0这三种操作&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbejy994vbj317g0ra3z0.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：计数器&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * A 16-bit counter with load and reset control bits.
 * if      (reset[t] == 1) out[t+1] = 0
 * else if (load[t] == 1)  out[t+1] = in[t]
 * else if (inc[t] == 1)   out[t+1] = out[t] + 1  (integer addition)
 * else                    out[t+1] = out[t]
 */

CHIP PC {
    IN in[16],load,inc,reset;
    OUT out[16];

    PARTS:
    Or8Way(in[0]=inc, in[1]=reset, in[2]=load, in[3..7]=false, out=ReLoad);

    Mux16(a=outBack, b=outPlus, sel=inc, out=loadIN);
    Mux16(a=loadIN, b=in, sel=load, out=resetIN);
    Mux16(a=resetIN, b=false, sel=reset, out=ReIn);

    Register(in=ReIn, load=ReLoad, out=out, out=outBack);
    Inc16(in=outBack, out=outPlus);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们以下图为例，看一下计数器是如何在时钟系统下变化数值的。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdrw718d4j31be0hiaat.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;至此，我们实现了hack CPU所需的所有芯片。组合逻辑芯片主要负责算数运算、逻辑运算、选择逻辑，并且通过适当的组合可以用来实现指令解析和某些功能控制；时序芯片主要负责存储数据。下一篇我们会用这些芯片搭建一个简单但实用的CPU。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">上一篇我们实现了一系列组合逻辑芯片和CPU的运算大脑：ALU，但是组合逻辑芯片是一个实时系统，只要输入值改变了输出值也马上跟着改变，上一秒辛苦计算出来的值，下一秒就消失不见了，因此我们需要一个具备”记忆功能”的原件，用于存储数据。这就是我们本篇要介绍的：时序逻辑芯片。 反馈电路、时钟系统、D触发器 组合逻辑芯片之所以无法记住上一次计算的值，是因为电流信息的流向是单向的，它总是向前流动，导致我们无法两次踏入同一条河流。要解决这个问题也很简单，我们引一条导线让数据回流，形成一个环路即可（即形成反馈）。下图就是用OR门加上一路环路构成的一位存储器，但他的缺点是只能记忆一次1的输入，后续无论输入如何改变，输出总是为1。如果想要实现功能更强大的记忆芯片就需要更复杂的电路设计，但仍然是基于门的输出再重新作为输入的原理。 提到”记忆”就不能不涉及到”时间”，计算机中的时间是基于震荡时钟系统的，震荡时钟提供连续的交变信号（高低电平）从而形成离散的时间周期。时钟周期是计算机系统中各元器件能整齐划一，协调同步的工作的基础。当一个时钟周期到来时，计算机的各个元器件必须抓紧在本次周期内完成自己的任务，然后停下来安静等待下一个周期的来临（这也是为什么时钟频率通常被当做衡量计算机性能的重要指标，因为频率越高，单位时间内计算机完成的工作步骤就越多）。例如只有当时钟上升沿到来时，各时序芯片才会瞬间改变状态，其余时间保持状态锁定。如果把CPU、内存、输入输出设备比作乐团中各个乐器的乐手，那么时钟系统就是计算机乐团的乐队指挥。 在搭建hack的时候，我们一共用到了两个基本芯片（即不用自己实现的芯片），一个是上一篇用于搭建组合逻辑芯片系统的Nand，另外一个就是本片用于搭建时序逻辑芯片的DFF（data Flip-Flop：D触发器）。DFF的结构由R-S锁存器派生而来。（DFF的实现相对复杂，如果对锁存器和DFF感兴趣，可以参考《编码的奥秘》Charles Petzold）。 边沿触发的D型触发器 DFF包含1bit的输入和1bit的输出，另外DFF有一个时钟输入（图中的小三角代表时钟输入），DFF根据数据输入位和时钟输入位的输入实现了out(t)=in(t-1)，即DFF简单的将前一个时间周期的输入值作为当前时间周期的输出值。这是DFF具备记忆功能的表现，也是我们后续实现16bit寄存器，16K、64K、256K等RAM的基础。 1位寄存器和16位寄存器 有了DFF的记忆功能，我们接下来先实现最简单1bit寄存器和16bit寄存器。1bit寄存器的接口包括：in输入管脚，负责传输输入数据；load管脚，load管脚是控制位，只有当load为1的时候，才会存储in的输入数据；out管脚输出当前存储的值。接口如下所示： 1bit芯片很好实现，主要是实现load位的控制功能即可，根据芯片描述可以把芯片设计为：load为1时选择输入in的数据，load为0时选择输入上一次寄存器保存的数据。这种选择功能正好是上一篇我们实现的Multiplexor芯片（后面在实现RAM的时候，Multiplexor在地址选择中的作用体现得更加明显）。1bit寄存器内部实现如下： 然后我们用硬件描述语言（HDL）实现： /** * 1-bit register: * If load[t] == 1 then out[t+1] = in[t] * else out does not change (out[t+1] = out[t]) */ CHIP Bit { IN in, load; OUT out; PARTS: Mux(a=outBack, b=in, sel=load, out=dffIn); DFF(in=dffIn, out=out, out=outBack); } 有1bit寄存器，16bit寄存器可以看做是16个1bit寄存器的组合： HDL实现：16bit寄存器 /** * 16-bit register: * If load[t] == 1 then out[t+1] = in[t] * else out does not change */ CHIP Register { IN in[16], load; OUT out[16]; PARTS: Mux(a=outBack0, b=in[0], sel=load, out=dffIn0); DFF(in=dffIn0, out=out[0], out=outBack0); Mux(a=outBack1, b=in[1], sel=load, out=dffIn1); DFF(in=dffIn1, out=out[1], out=outBack1); Mux(a=outBack2, b=in[2], sel=load, out=dffIn2); DFF(in=dffIn2, out=out[2], out=outBack2); Mux(a=outBack3, b=in[3], sel=load, out=dffIn3); DFF(in=dffIn3, out=out[3], out=outBack3); Mux(a=outBack4, b=in[4], sel=load, out=dffIn4); DFF(in=dffIn4, out=out[4], out=outBack4); Mux(a=outBack5, b=in[5], sel=load, out=dffIn5); DFF(in=dffIn5, out=out[5], out=outBack5); // ...6到15 } RAM 接着我们来实现计算机中另一个非常重要的组成部分：RAM。刚才看到，16bit寄存器可以由16个1bit的寄存器组合而成，同理一个mKB的RAM，可以由n个16位寄存器组合而成，16位寄存器就是RAM中的基本存储单元，寄存器的宽度（此处是16位）就是RAM”字”（WORD）的宽度。我们都知道，需要通过地址来访问RAM，RAM中每个寄存器都绑定到一个唯一地址。下图是RAM的接口设计，RAM有三种输入：数据输入，地址输入和加载位。地址指定了当前周期RAM中哪一个寄存器被访问，当进行读操作时（load=0），RAM立即输出被选中的寄存器的值，当进行写操作时（load=1），被选中的寄存器被赋予新的值，从下个周期开始RAM将开始发出新的值。输入和输出的数据宽度就是RAM”字”的宽度。 接下来我们要实现RAM8，RAM64，RAM512，RAM4K，RAM16K几种内存容量的RAM。RAMn中的n即代表RAM中有n个寄存器。例如RAM16K中有16K个16位寄存器，那么他的内存容量就是16K*(16/2)byte=32Kbyte。想要实现一个RAMn芯片，我们需要在RAMn芯片中集成n个寄存器，外加一些列控制逻辑（处理load）和地址选择逻辑，那么涉及到选择逻辑自然少不了Multiplexor和DMultiplexor。那么下面我们以RAM8为例讲一下我自己的实现方式： RAM8中有8个寄存器 8个寄存器有8个地址，所以我们的地址位需要2^n=8, n=3位 DMux用于解析写入时的地址，用3位sel分离出需要写入的那一路，再和load做与操作后作为寄存器的load位输入，最终通过load位来决定哪一个寄存器被写入In。 Mux用于解析读取时的地址，用3位sel在8个寄存器中选择想要读取的那一路数据 HDL实现：RAM8 /** * Memory of 8 registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM8 { IN in[16], load, address[3]; OUT out[16]; PARTS: DMux8Way(in=true, sel=address, a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); Register(in=in, load=load0, out=R0); Register(in=in, load=load1, out=R1); Register(in=in, load=load2, out=R2); Register(in=in, load=load3, out=R3); Register(in=in, load=load4, out=R4); Register(in=in, load=load5, out=R5); Register(in=in, load=load6, out=R6); Register(in=in, load=load7, out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel=address, out=out); } 有了RAM8，我们就可以利用8个RAM8的组合实现RAM64，以此类推实现后面容量更大的RAM。 实现RAM64的技巧是对地址位的拆分，RAM64需要6个地址位，把6个地址为拆分为3+3 和实现RAM8的时候类似，需要引入一组Mux和DMux，这组选择芯片使用6位地址中的高三位，通过高3位把地址初步划分为8个地址段，每个地址段的容量即RAM8中寄存器的数量 每个RAM8使用6位地址中的低三位，然后从中定位到目标地址寄存器 HDL实现：RAM64 /** * Memory of 64 registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM64 { IN in[16], load, address[6]; OUT out[16]; PARTS: DMux8Way(in=true, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); RAM8(in=in, load=load0, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R0); RAM8(in=in, load=load1, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R1); RAM8(in=in, load=load2, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R2); RAM8(in=in, load=load3, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R3); RAM8(in=in, load=load4, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R4); RAM8(in=in, load=load5, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R5); RAM8(in=in, load=load6, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R6); RAM8(in=in, load=load7, address[0]=address[0], address[1]=address[1], address[2]=address[2], out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0]=address[3], sel[1]=address[4], sel[2]=address[5], out=out); } HDL实现：RAM4K /** * Memory of 4K registers, each 16 bit-wide. Out holds the value * stored at the memory location specified by address. If load==1, then * the in value is loaded into the memory location specified by address * (the loaded value will be emitted to out from the next time step onward). */ CHIP RAM4K { IN in[16], load, address[12]; OUT out[16]; PARTS: DMux8Way(in=true, sel[0..2]=address[9..11], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h); And(a=a, b=load, out=load0); And(a=b, b=load, out=load1); And(a=c, b=load, out=load2); And(a=d, b=load, out=load3); And(a=e, b=load, out=load4); And(a=f, b=load, out=load5); And(a=g, b=load, out=load6); And(a=h, b=load, out=load7); RAM512(in=in, load=load0, address[0..8]=address[0..8], out=R0); RAM512(in=in, load=load1, address[0..8]=address[0..8], out=R1); RAM512(in=in, load=load2, address[0..8]=address[0..8], out=R2); RAM512(in=in, load=load3, address[0..8]=address[0..8], out=R3); RAM512(in=in, load=load4, address[0..8]=address[0..8], out=R4); RAM512(in=in, load=load5, address[0..8]=address[0..8], out=R5); RAM512(in=in, load=load6, address[0..8]=address[0..8], out=R6); RAM512(in=in, load=load7, address[0..8]=address[0..8], out=R7); Mux8Way16(a=R0, b=R1, c=R2, d=R3, e=R4, f=R5, g=R6, h=R7, sel[0..2]=address[9..11], out=out); } 至此，我们了解了RAM中内存访问的方式。在RAM中的存储单元可以通过解析地址信号来进行随机的访问，而不会受限于存储单元的位置，访问任何位置的存储单元的速度都是相等的，例如访问内存中一个数组中任意下标的数据的速度都是相等的。这也是Random Access Memory概念的由来。 计数器 计数器也是CPU中一个重要的原件，主要用来存储将要执行指令的内存地址。在大多数情况下，计数器每个周期简单的进行+1操作，这时计算机能够获取下一条地址，这和CPU顺序执行指令的模式相符，同时CPU也支持直接跳转到编号为n的指令去执行，因此计数器要支持将其值设置为n的能力。下面我们来看一下计数器的接口设计：计数器芯片有2个附加控制位reset和inc，当inc=1时，计数器在每个时钟周期自加1，其输出值为out(t)=out(t-1)+1；如果想要将计数器置为0，就将reset置为1。如果想要将计数器设置为某个值，则将load置为1，并将数值从in输入。 下图是我对计数器的实现逻辑 reset，inc，load用一个Or8way输出，只要其中有一个为1，那么register的load为就为1，register的值会被更新 3个Mux串联用于选择自增1、in的输入值、重置0这三种操作 HDL实现：计数器 /** * A 16-bit counter with load and reset control bits. * if (reset[t] == 1) out[t+1] = 0 * else if (load[t] == 1) out[t+1] = in[t] * else if (inc[t] == 1) out[t+1] = out[t] + 1 (integer addition) * else out[t+1] = out[t] */ CHIP PC { IN in[16],load,inc,reset; OUT out[16]; PARTS: Or8Way(in[0]=inc, in[1]=reset, in[2]=load, in[3..7]=false, out=ReLoad); Mux16(a=outBack, b=outPlus, sel=inc, out=loadIN); Mux16(a=loadIN, b=in, sel=load, out=resetIN); Mux16(a=resetIN, b=false, sel=reset, out=ReIn); Register(in=ReIn, load=ReLoad, out=out, out=outBack); Inc16(in=outBack, out=outPlus); } 我们以下图为例，看一下计数器是如何在时钟系统下变化数值的。 总结 至此，我们实现了hack CPU所需的所有芯片。组合逻辑芯片主要负责算数运算、逻辑运算、选择逻辑，并且通过适当的组合可以用来实现指令解析和某些功能控制；时序芯片主要负责存储数据。下一篇我们会用这些芯片搭建一个简单但实用的CPU。</summary></entry><entry><title type="html">从0到1构建计算机(3/10)–组合逻辑芯片：逻辑门、加法器、ALU</title><link href="http://localhost:4000/2019/12/16/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E9%80%BB%E8%BE%91%E9%97%A8-%E5%8A%A0%E6%B3%95%E5%99%A8-ALU.html" rel="alternate" type="text/html" title="从0到1构建计算机(3/10)--组合逻辑芯片：逻辑门、加法器、ALU" /><published>2019-12-16T00:00:00+08:00</published><updated>2019-12-16T00:00:00+08:00</updated><id>http://localhost:4000/2019/12/16/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87:%E9%80%BB%E8%BE%91%E9%97%A8%E3%80%81%E5%8A%A0%E6%B3%95%E5%99%A8%E3%80%81ALU</id><content type="html" xml:base="http://localhost:4000/2019/12/16/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%8A%AF%E7%89%87-%E9%80%BB%E8%BE%91%E9%97%A8-%E5%8A%A0%E6%B3%95%E5%99%A8-ALU.html">&lt;p&gt;上篇说到：通过使用Nand门，我们可以实现任何逻辑门，进而实现可以一个CPU。后面我们就会搭建一个麻雀虽小但五脏俱全的计算机平台：hack。本篇我们开始第一步，实现搭建hack所需的一组芯片：组合逻辑芯片&lt;/p&gt;

&lt;h3 id=&quot;组合逻辑芯片&quot;&gt;组合逻辑芯片&lt;/h3&gt;

&lt;p&gt;一个最基本的CPU主要由两类芯片组成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;组合逻辑芯片（Combinational Chips）：与、或、非门，加法器，ALU芯片等。这些芯片主要负责逻辑计算&lt;/li&gt;
  &lt;li&gt;时序芯片（Sequential Chips）：寄存器，计数器，RAM等。这些芯片主要负责暂存数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组合逻辑芯片（下面简称逻辑芯片）可以类比为一个布尔函数，它仅负责处理逻辑运算：输出结果仅依赖于其输入变量的排列组合。逻辑芯片是没有记忆能力的，它们不能维持自身的状态，当逻辑芯片的输入值改变的时候，它们的输出值也会实时地改变。&lt;/p&gt;

&lt;p&gt;hack所需要的逻辑芯片有以下四种：基本逻辑门、多通道逻辑门、加法器、ALU（算数逻辑单元）。&lt;/p&gt;

&lt;h3 id=&quot;基本逻辑门&quot;&gt;基本逻辑门&lt;/h3&gt;
&lt;p&gt;基本逻辑门是一些简单的布尔函数的实现，我们需要的基本逻辑门如下，有1位和多位（16位）之分。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1g9yzjn8lngj30qe0mgwew.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;我们所有组合逻辑芯片都是基于Nand实现的，下面是Nand的真值表：只有当两个输入都为1时输出为0，其余输出为1反，然后输出。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga16e7ws5tj30b007s3yd.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Nand真值表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;首先我们用Nand实现一个Not。Not很简单，对其输入取反，然后输出。下面是我自己的实现方式：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga21uf1wocj30s609e3yh.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Not电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;HDL实现：硬件描述语言实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Not HDL实现
 * Not gate:
 * out = not in
 */

CHIP Not {
    IN in;
    OUT out;

    PARTS:
    Nand(a=in, b=in, out=out); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们继续用刚刚实现的Not和Nand组合使用，再实现一个And。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga221fwwf3j310m08mgll.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;And电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * And gate: 
 * out = 1 if (a == 1 and b == 1)
 *       0 otherwise
 */

CHIP And {
    IN a, b;
    OUT out;

    PARTS:
    Nand(a=a, b=b, out=nandOut);
    Not(in=nandOut, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多位基本逻辑门是1位基本逻辑门的简单组合，以16位And为例，用16个1位And组合成16位And.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16-bit bitwise And:
 * for i = 0..15: out[i] = (a[i] and b[i])
 */

CHIP And16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    And(a=a[0], b=b[0], out=out[0]);
    And(a=a[1], b=b[1], out=out[1]);
    And(a=a[2], b=b[2], out=out[2]);
    And(a=a[3], b=b[3], out=out[3]);
    And(a=a[4], b=b[4], out=out[4]);
    And(a=a[5], b=b[5], out=out[5]);
    And(a=a[6], b=b[6], out=out[6]);
    And(a=a[7], b=b[7], out=out[7]);
    And(a=a[8], b=b[8], out=out[8]);
    And(a=a[9], b=b[9], out=out[9]);
    And(a=a[10], b=b[10], out=out[10]);
    And(a=a[11], b=b[11], out=out[11]);
    And(a=a[12], b=b[12], out=out[12]);
    And(a=a[13], b=b[13], out=out[13]);
    And(a=a[14], b=b[14], out=out[14]);
    And(a=a[15], b=b[15], out=out[15]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;以此类推，我们可以一步步实现其他所有基本逻辑门。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;加法器&quot;&gt;加法器&lt;/h3&gt;
&lt;p&gt;有了上面实现的这些基本逻辑门，我们就可以实现CPU中一个非常重要的基本芯片：加法器。实现加法器的顺序是：半加器-&amp;gt;全加器-&amp;gt;16位加法器&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cyn6tzgj30va0d8glt.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;第一步：实现一个半加器，半加器负责计算两个一位二进制相加，输出sum和carry（进位）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xb8b2xej30sc09m74d.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;半加器&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;虽然半加器看上去跳出了布尔运算，升级到的小学数学，但其仍然可以用真值表表示，所以也就可以用基本逻辑门实现，我们用一个Xor和And就可以实现半加器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2c9rhu5bj30sa0ge3yo.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;半加器电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 半加器
 * Computes the sum of two bits.
 */

CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b 
        carry;  // Left bit of a + b

    PARTS:
    Xor(a=a, b=b, out=sum);
    And(a=a, b=b, out=carry);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;半加器只能计算两个一位二进制数相加，接着我们在输入端再加入一个进位管脚（代表低位做加法时进过来的进位），就成为了一个全加器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xom01j9j30u80de0sv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;全加器&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cemdwywj318g0gu0t1.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;全加器电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 全加器
 * Computes the sum of three bits.
 */

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, carry=carryA, sum=sumA);
    HalfAdder(a=sumA, b=c, carry=carryB, sum=sum);
    Or(a=carryA, b=carryB, out=carry);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后我们利用全加器实现16位加法器，有了16位加法器，我们就可以进行2个不大于2^16的整数的加法了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xrljwy9j30te06sdfv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;16位加法器&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 16位加法器
 * Adds two 16-bit values.
 * The most significant carry bit is ignored.
 */

CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=ca0);
    FullAdder(a=a[1], b=b[1], c=ca0, sum=out[1], carry=ca1);
    FullAdder(a=a[2], b=b[2], c=ca1, sum=out[2], carry=ca2);
    FullAdder(a=a[3], b=b[3], c=ca2, sum=out[3], carry=ca3);
    FullAdder(a=a[4], b=b[4], c=ca3, sum=out[4], carry=ca4);
    FullAdder(a=a[5], b=b[5], c=ca4, sum=out[5], carry=ca5);
    FullAdder(a=a[6], b=b[6], c=ca5, sum=out[6], carry=ca6);
    FullAdder(a=a[7], b=b[7], c=ca6, sum=out[7], carry=ca7);
    FullAdder(a=a[8], b=b[8], c=ca7, sum=out[8], carry=ca8);
    FullAdder(a=a[9], b=b[9], c=ca8, sum=out[9], carry=ca9);
    FullAdder(a=a[10], b=b[10], c=ca9, sum=out[10], carry=ca10);
    FullAdder(a=a[11], b=b[11], c=ca10, sum=out[11], carry=ca11);
    FullAdder(a=a[12], b=b[12], c=ca11, sum=out[12], carry=ca12);
    FullAdder(a=a[13], b=b[13], c=ca12, sum=out[13], carry=ca13);
    FullAdder(a=a[14], b=b[14], c=ca13, sum=out[14], carry=ca14);
    FullAdder(a=a[15], b=b[15], c=ca14, sum=out[15], carry=ignorCa); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了加法器，我们再实现一个累加器，它对输入数据进行加1，然后输出。累加器是后面CPU中程序计数器的重要部分。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 累加器
 * 16-bit incrementer:
 * out = in + 1 (arithmetic addition)
 */

CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Add16(a=in, b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=false, b[5]=false, b[6]=false, b[7]=false, b[8]=false, b[9]=false, b[10]=false, b[11]=false, b[12]=false, b[13]=false, b[14]=false, b[15]=false, out=out);
}     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;多通道逻辑门&quot;&gt;多通道逻辑门&lt;/h3&gt;
&lt;p&gt;我们看到基本逻辑门负责计算布尔运算，但其只能根据输入计算出输出，缺少控制能力。下面我们介绍的多通道逻辑门则在逻辑控制方面扮演了重要角色，因为多通道逻辑门具有&lt;strong&gt;选择功能&lt;/strong&gt;。多通道逻辑门在CPU和RAM中起到了重要作用。多通道逻辑门分为以下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Multiplexor:&lt;/strong&gt; 有多路输入，一路输出，选择输入中的一路作为输出&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DMultiplexor:&lt;/strong&gt; 有一路输入，多路输出，在输出路中选择一路降输入值输出&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cyl836uj30v60meaaw.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y8t42i3j30p60dq0sv.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;Multiplexor&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&amp;lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y9h0fixj30me08mjrd.jpg&quot; width=&quot;600&amp;gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;DMultiplexor&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;这里我们实现一个2路1位的Mux。a，b是两路1位信号输入，sel是选择位。如果sel == 0，out管脚输出a的值，否则输出b的值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1zhhi4a2j30rm0kuq36.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;2路1位Mux电路图&lt;/figcaption&gt;&lt;/center&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
 * 2路1位Mux
 * Multiplexor:
 * out = a if sel == 0
 *       b otherwise
 */

CHIP Mux {
    IN a, b, sel;
    OUT out;

    PARTS:
    Not(in= sel, out=NotSel);
    And(a=a, b=NotSel, out=AndAOut);
    And(a=b, b=sel, out=AndBOut);
    Or(a=AndAOut, b=AndBOut, out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然除了2路选择器，还有4路、8路、16路等多路选择器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yd61q3mj30ze09at8v.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;多路Mux&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;下面是4路16位选择器的一种实现方式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 4-way 16-bit multiplexor:
 * out = a if sel == 00
 *       b if sel == 01
 *       c if sel == 10
 *       d if sel == 11
 */

CHIP Mux4Way16 {
    IN a[16], b[16], c[16], d[16], sel[2];
    OUT out[16];

    PARTS:
    Mux16(a=a, b=b, sel=sel[0], out=outA);
    Mux16(a=c, b=d, sel=sel[0], out=outB);
    Mux16(a=outA, b=outB, sel=sel[1], out=out);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;alu&quot;&gt;ALU&lt;/h3&gt;
&lt;p&gt;有了多通道逻辑门，我们就可以进一步实现一个更为复杂的芯片：ALU。ALU是CPU的三大基本模块之一（ALU、寄存器、程序计数器）。基本逻辑门只能计算一种布尔逻辑，而ALU可以通过改变控制位输入变量的组合（zx,nz,zy,ny,f,no），可以控制实现多种计算逻辑。这类似于一个CPU可以执行指令集中的众多指令一样（当然这其中就依赖于ALU）。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga2cylk4d8j30uo05i3yg.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;芯片列表&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yf3rz82j30pi0i0dg1.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;ALU&lt;/figcaption&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1yf94f4ej314x0u0jsn.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;ALU真值表&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;下面我们就用上面实现的芯片来实现一下ALU（由于比较复杂，就先不画电路图了）。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * The ALU (Arithmetic Logic Unit).
 * Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&amp;amp;y, x|y on two 16-bit inputs, 
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * In addition, the ALU computes two 1-bit outputs:
 * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;
 * if the ALU output &amp;lt; 0, ng is set to 1; otherwise ng is set to 0.
 */

// Implementation: the ALU logic manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) set x = 0        // 16-bit constant
// if (nx == 1) set x = !x       // bitwise not
// if (zy == 1) set y = 0        // 16-bit constant
// if (ny == 1) set y = !y       // bitwise not
// if (f == 1)  set out = x + y  // integer 2's complement addition
// if (f == 0)  set out = x &amp;amp; y  // bitwise and
// if (no == 1) set out = !out   // bitwise not
// if (out == 0) set zr = 1
// if (out &amp;lt; 0) set ng = 1

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute out = x + y (if 1) or x &amp;amp; y (if 0)
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out &amp;lt; 0),  0 otherwise

    PARTS:
    Mux16(a=x, b=false, sel=zx, out=zSelX);
    Not16(in=zSelX, out=notZSelx);
    Mux16(a=zSelX, b=notZSelx, sel=nx, out=outX);

    Mux16(a=y, b=false, sel=zy, out=zSelY);
    Not16(in=zSelY, out=notZSelY);
    Mux16(a=zSelY, b=notZSelY, sel=ny, out=outY);

    Add16(a=outX, b=outY, out=outAdd); // X+Y
    And16(a=outX, b=outY, out=outAnd); // X&amp;amp;Y

    Mux16(a=outAnd, b=outAdd, sel=f, out=outF);
    Not16(in=outF, out=notF);

    Mux16(a=outF, b=notF, sel=no, out=out, out[0..7]=outZrA, out[8..15]=outZrB, out[15]=outMSB);

    Or8Way(in=outZrA, out=zrL);
    Or8Way(in=outZrB, out=zrH);
    Or(a=zrL, b=zrH, out=notZr);
    Not(in=notZr, out=zr);

    And(a=true, b=outMSB, out=ng);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;补码&quot;&gt;补码&lt;/h3&gt;
&lt;p&gt;最后我们再来谈一下补码，上面我们提到的加法器都没有考虑正负符号的问题，如果引入符号，那么电路会变得更加复杂。通过使用补码可以很好的规避这个问题，因为补码有一个很重要的特性：&lt;strong&gt;任何两个用补码表示的有符号数的加法和正数的加法完全相同&lt;/strong&gt;，例如用正数加法操作（-2）+（-3），所得的结果正好是（-5）的补码；补码的减法可以用加法来代替实现，例如x-y == x+(-y)。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">上篇说到：通过使用Nand门，我们可以实现任何逻辑门，进而实现可以一个CPU。后面我们就会搭建一个麻雀虽小但五脏俱全的计算机平台：hack。本篇我们开始第一步，实现搭建hack所需的一组芯片：组合逻辑芯片 组合逻辑芯片 一个最基本的CPU主要由两类芯片组成： 组合逻辑芯片（Combinational Chips）：与、或、非门，加法器，ALU芯片等。这些芯片主要负责逻辑计算 时序芯片（Sequential Chips）：寄存器，计数器，RAM等。这些芯片主要负责暂存数据 组合逻辑芯片（下面简称逻辑芯片）可以类比为一个布尔函数，它仅负责处理逻辑运算：输出结果仅依赖于其输入变量的排列组合。逻辑芯片是没有记忆能力的，它们不能维持自身的状态，当逻辑芯片的输入值改变的时候，它们的输出值也会实时地改变。 hack所需要的逻辑芯片有以下四种：基本逻辑门、多通道逻辑门、加法器、ALU（算数逻辑单元）。 基本逻辑门 基本逻辑门是一些简单的布尔函数的实现，我们需要的基本逻辑门如下，有1位和多位（16位）之分。 芯片列表 我们所有组合逻辑芯片都是基于Nand实现的，下面是Nand的真值表：只有当两个输入都为1时输出为0，其余输出为1反，然后输出。 Nand真值表 首先我们用Nand实现一个Not。Not很简单，对其输入取反，然后输出。下面是我自己的实现方式： Not电路图 HDL实现：硬件描述语言实现。 /** * Not HDL实现 * Not gate: * out = not in */ CHIP Not { IN in; OUT out; PARTS: Nand(a=in, b=in, out=out); } 然后我们继续用刚刚实现的Not和Nand组合使用，再实现一个And。 And电路图 /** * And gate: * out = 1 if (a == 1 and b == 1) * 0 otherwise */ CHIP And { IN a, b; OUT out; PARTS: Nand(a=a, b=b, out=nandOut); Not(in=nandOut, out=out); } 多位基本逻辑门是1位基本逻辑门的简单组合，以16位And为例，用16个1位And组合成16位And. /** * 16-bit bitwise And: * for i = 0..15: out[i] = (a[i] and b[i]) */ CHIP And16 { IN a[16], b[16]; OUT out[16]; PARTS: And(a=a[0], b=b[0], out=out[0]); And(a=a[1], b=b[1], out=out[1]); And(a=a[2], b=b[2], out=out[2]); And(a=a[3], b=b[3], out=out[3]); And(a=a[4], b=b[4], out=out[4]); And(a=a[5], b=b[5], out=out[5]); And(a=a[6], b=b[6], out=out[6]); And(a=a[7], b=b[7], out=out[7]); And(a=a[8], b=b[8], out=out[8]); And(a=a[9], b=b[9], out=out[9]); And(a=a[10], b=b[10], out=out[10]); And(a=a[11], b=b[11], out=out[11]); And(a=a[12], b=b[12], out=out[12]); And(a=a[13], b=b[13], out=out[13]); And(a=a[14], b=b[14], out=out[14]); And(a=a[15], b=b[15], out=out[15]); } 以此类推，我们可以一步步实现其他所有基本逻辑门。 加法器 有了上面实现的这些基本逻辑门，我们就可以实现CPU中一个非常重要的基本芯片：加法器。实现加法器的顺序是：半加器-&amp;gt;全加器-&amp;gt;16位加法器 芯片列表 第一步：实现一个半加器，半加器负责计算两个一位二进制相加，输出sum和carry（进位）。 半加器 虽然半加器看上去跳出了布尔运算，升级到的小学数学，但其仍然可以用真值表表示，所以也就可以用基本逻辑门实现，我们用一个Xor和And就可以实现半加器。 半加器电路图 /** * 半加器 * Computes the sum of two bits. */ CHIP HalfAdder { IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry); } 半加器只能计算两个一位二进制数相加，接着我们在输入端再加入一个进位管脚（代表低位做加法时进过来的进位），就成为了一个全加器。 全加器 全加器电路图 /** * 全加器 * Computes the sum of three bits. */ CHIP FullAdder { IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, carry=carryA, sum=sumA); HalfAdder(a=sumA, b=c, carry=carryB, sum=sum); Or(a=carryA, b=carryB, out=carry); } 最后我们利用全加器实现16位加法器，有了16位加法器，我们就可以进行2个不大于2^16的整数的加法了。 16位加法器 /** * 16位加法器 * Adds two 16-bit values. * The most significant carry bit is ignored. */ CHIP Add16 { IN a[16], b[16]; OUT out[16]; PARTS: FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=ca0); FullAdder(a=a[1], b=b[1], c=ca0, sum=out[1], carry=ca1); FullAdder(a=a[2], b=b[2], c=ca1, sum=out[2], carry=ca2); FullAdder(a=a[3], b=b[3], c=ca2, sum=out[3], carry=ca3); FullAdder(a=a[4], b=b[4], c=ca3, sum=out[4], carry=ca4); FullAdder(a=a[5], b=b[5], c=ca4, sum=out[5], carry=ca5); FullAdder(a=a[6], b=b[6], c=ca5, sum=out[6], carry=ca6); FullAdder(a=a[7], b=b[7], c=ca6, sum=out[7], carry=ca7); FullAdder(a=a[8], b=b[8], c=ca7, sum=out[8], carry=ca8); FullAdder(a=a[9], b=b[9], c=ca8, sum=out[9], carry=ca9); FullAdder(a=a[10], b=b[10], c=ca9, sum=out[10], carry=ca10); FullAdder(a=a[11], b=b[11], c=ca10, sum=out[11], carry=ca11); FullAdder(a=a[12], b=b[12], c=ca11, sum=out[12], carry=ca12); FullAdder(a=a[13], b=b[13], c=ca12, sum=out[13], carry=ca13); FullAdder(a=a[14], b=b[14], c=ca13, sum=out[14], carry=ca14); FullAdder(a=a[15], b=b[15], c=ca14, sum=out[15], carry=ignorCa); } 有了加法器，我们再实现一个累加器，它对输入数据进行加1，然后输出。累加器是后面CPU中程序计数器的重要部分。 /** * 累加器 * 16-bit incrementer: * out = in + 1 (arithmetic addition) */ CHIP Inc16 { IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=false, b[5]=false, b[6]=false, b[7]=false, b[8]=false, b[9]=false, b[10]=false, b[11]=false, b[12]=false, b[13]=false, b[14]=false, b[15]=false, out=out); } 多通道逻辑门 我们看到基本逻辑门负责计算布尔运算，但其只能根据输入计算出输出，缺少控制能力。下面我们介绍的多通道逻辑门则在逻辑控制方面扮演了重要角色，因为多通道逻辑门具有选择功能。多通道逻辑门在CPU和RAM中起到了重要作用。多通道逻辑门分为以下两种： Multiplexor: 有多路输入，一路输出，选择输入中的一路作为输出 DMultiplexor: 有一路输入，多路输出，在输出路中选择一路降输入值输出 芯片列表 Multiplexor &amp;lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga1y9h0fixj30me08mjrd.jpg&quot; width=&quot;600&amp;gt; DMultiplexor 这里我们实现一个2路1位的Mux。a，b是两路1位信号输入，sel是选择位。如果sel == 0，out管脚输出a的值，否则输出b的值。 2路1位Mux电路图 /** * 2路1位Mux * Multiplexor: * out = a if sel == 0 * b otherwise */ CHIP Mux { IN a, b, sel; OUT out; PARTS: Not(in= sel, out=NotSel); And(a=a, b=NotSel, out=AndAOut); And(a=b, b=sel, out=AndBOut); Or(a=AndAOut, b=AndBOut, out=out); } 当然除了2路选择器，还有4路、8路、16路等多路选择器。 多路Mux 下面是4路16位选择器的一种实现方式 /** * 4-way 16-bit multiplexor: * out = a if sel == 00 * b if sel == 01 * c if sel == 10 * d if sel == 11 */ CHIP Mux4Way16 { IN a[16], b[16], c[16], d[16], sel[2]; OUT out[16]; PARTS: Mux16(a=a, b=b, sel=sel[0], out=outA); Mux16(a=c, b=d, sel=sel[0], out=outB); Mux16(a=outA, b=outB, sel=sel[1], out=out); } ALU 有了多通道逻辑门，我们就可以进一步实现一个更为复杂的芯片：ALU。ALU是CPU的三大基本模块之一（ALU、寄存器、程序计数器）。基本逻辑门只能计算一种布尔逻辑，而ALU可以通过改变控制位输入变量的组合（zx,nz,zy,ny,f,no），可以控制实现多种计算逻辑。这类似于一个CPU可以执行指令集中的众多指令一样（当然这其中就依赖于ALU）。 芯片列表 ALU ALU真值表 下面我们就用上面实现的芯片来实现一下ALU（由于比较复杂，就先不画电路图了）。 /** * The ALU (Arithmetic Logic Unit). * Computes one of the following functions: * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y, * x+1, y+1, x-1, y-1, x&amp;amp;y, x|y on two 16-bit inputs, * according to 6 input bits denoted zx,nx,zy,ny,f,no. * In addition, the ALU computes two 1-bit outputs: * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0; * if the ALU output &amp;lt; 0, ng is set to 1; otherwise ng is set to 0. */ // Implementation: the ALU logic manipulates the x and y inputs // and operates on the resulting values, as follows: // if (zx == 1) set x = 0 // 16-bit constant // if (nx == 1) set x = !x // bitwise not // if (zy == 1) set y = 0 // 16-bit constant // if (ny == 1) set y = !y // bitwise not // if (f == 1) set out = x + y // integer 2's complement addition // if (f == 0) set out = x &amp;amp; y // bitwise and // if (no == 1) set out = !out // bitwise not // if (out == 0) set zr = 1 // if (out &amp;lt; 0) set ng = 1 CHIP ALU { IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp;amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &amp;lt; 0), 0 otherwise PARTS: Mux16(a=x, b=false, sel=zx, out=zSelX); Not16(in=zSelX, out=notZSelx); Mux16(a=zSelX, b=notZSelx, sel=nx, out=outX); Mux16(a=y, b=false, sel=zy, out=zSelY); Not16(in=zSelY, out=notZSelY); Mux16(a=zSelY, b=notZSelY, sel=ny, out=outY); Add16(a=outX, b=outY, out=outAdd); // X+Y And16(a=outX, b=outY, out=outAnd); // X&amp;amp;Y Mux16(a=outAnd, b=outAdd, sel=f, out=outF); Not16(in=outF, out=notF); Mux16(a=outF, b=notF, sel=no, out=out, out[0..7]=outZrA, out[8..15]=outZrB, out[15]=outMSB); Or8Way(in=outZrA, out=zrL); Or8Way(in=outZrB, out=zrH); Or(a=zrL, b=zrH, out=notZr); Not(in=notZr, out=zr); And(a=true, b=outMSB, out=ng); } 补码 最后我们再来谈一下补码，上面我们提到的加法器都没有考虑正负符号的问题，如果引入符号，那么电路会变得更加复杂。通过使用补码可以很好的规避这个问题，因为补码有一个很重要的特性：任何两个用补码表示的有符号数的加法和正数的加法完全相同，例如用正数加法操作（-2）+（-3），所得的结果正好是（-5）的补码；补码的减法可以用加法来代替实现，例如x-y == x+(-y)。</summary></entry><entry><title type="html">从0到1构建计算机(2/10)–与非门实现CPU的数理基础</title><link href="http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80.html" rel="alternate" type="text/html" title="从0到1构建计算机(2/10)--与非门实现CPU的数理基础" /><published>2019-10-17T00:00:00+08:00</published><updated>2019-10-17T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000/2019/10/17/%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%AE%9E%E7%8E%B0CPU%E7%9A%84%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80.html">&lt;h3 id=&quot;cpu和布尔函数&quot;&gt;CPU和布尔函数&lt;/h3&gt;

&lt;p&gt;CPU本质上是一个函数计算器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;信号通过输入管脚输入，对应着函数的入参&lt;/li&gt;
  &lt;li&gt;CPU的内部电路是函数的黑盒实现&lt;/li&gt;
  &lt;li&gt;信号通过输出管脚输出，对应着函数的出参&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbdjx10y6yj31gu0och04.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;8086 CPU&lt;/figcaption&gt;&lt;/center&gt;

&lt;p&gt;大家有没有思考过现代计算机为什么是基于二进制的🤔？事实上，在计算机的发展历程中确实出现过其他进制的计算机，例如10进制，3进制（现在计算机也是一步步演化过来了，其某些核心设计思想甚至来源于织布机，有兴趣的同学可以翻翻计算机发展史，有助于加深对计算机原理的理解）。我认为现代计算机基于二进制的原因主要有两个：一方面是基于二进制，在物理实现上会更加容易，例如电路设计更加简单，0和1的表示也更加稳定（高低电平）；另一方面，既然CPU是函数的实现，那么就需要有完备的数学理论做支撑，其中布尔代数正好完美契合了现代计算机只能执行非常简单的算数逻辑运算集但却能够以超高速方式运行的特点。英国数学家布尔在1854年创立了布尔代数学科，布尔代数本身十分简单，但却为百年之后出现的二进制计算机提供了重要的数学方法和理论基础。&lt;/p&gt;

&lt;h3 id=&quot;布尔函数&quot;&gt;布尔函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;布尔函数：&lt;/strong&gt;布尔函数处理布尔数值(它的输入输出都是二进制数值)。布尔函数在数字计算机的芯片设计中扮演基础角色，也在密码学中扮演关键角色。&lt;/p&gt;

&lt;p&gt;布尔函数的两种表示方法：&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;真值表：&lt;/strong&gt;枚举出函数所有输入变量的组合，然后写出每一种组合对应的函数输出值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921635xlzj30d00d2wed.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;figcaption&gt;真值表&lt;/figcaption&gt;&lt;/center&gt;
&lt;p&gt;2.&lt;strong&gt;布尔表达式：&lt;/strong&gt;使用布尔操作符（And，Or，Not等）表达，上面的真值表可以用此表达式表示：&lt;/p&gt;
&lt;center&gt;f(x, y, z) = (x And y) Or (Not(x) And z)&lt;/center&gt;

&lt;h3 id=&quot;布尔函数和门&quot;&gt;布尔函数和门&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;门（gate）&lt;/strong&gt;是用来实现布尔函数的物理设备，例如与门，或门，非门，与非门等。门是基本的电子元器件，复杂的门电路就构成了CPU&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921661g24j30u004at8o.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;门有输入管脚和输出管脚，对应着布尔函数的入参和出参；门电路的具体实现方式则对应着布尔函数的运算规则。复杂的布尔函数就对应的复杂的门电路&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g92165tk1lj311g0d63yy.jpg&quot; width=&quot;600&quot; /&gt;&lt;/center&gt;

&lt;p&gt;布尔函数是门电路的数学表达，门电路是布尔函数的物理实现。&lt;strong&gt;一个复杂的CPU物理实现对应着一个复杂的布尔函数设计，可以说CPU的实现是建立在布尔函数之上的。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;用与非门实现cpu的数理基础&quot;&gt;用与非门实现CPU的数理基础&lt;/h3&gt;

&lt;p&gt;布尔函数的一些数学结论：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;任何一个布尔函数，无论多复杂，都可以只用三种布尔操作符And，Or，Not完全表达。&lt;/li&gt;
  &lt;li&gt;And，Or，Not运算都可以只用Nand（与非）一种运算来代替实现，或者只用Nor（或非）一种运算来代替实现。&lt;/li&gt;
  &lt;li&gt;由1、2可得：仅使用Nand运算，就能够构建任何布尔函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;以上证明方法可以自行Google&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;有了上面的数理基础做支撑，我们可以得出结论：&lt;strong&gt;一旦我们在物理上实现了Nand（与非门），我们就能够实现任何门电路，进而实现一个CPU。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;用软件实现硬件&quot;&gt;用软件实现硬件&lt;/h3&gt;

&lt;p&gt;今天，硬件设计者们也不再亲手制作硬件了，而是用软件来实现设计：通过编写硬件描述语言（HDL）来描述芯片结构，并能通过测试用例来验证设计。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g921650gf9j313r0u077e.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;好了，下面就让我们用Nand来实现一个CPU吧~&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">CPU和布尔函数 CPU本质上是一个函数计算器： 信号通过输入管脚输入，对应着函数的入参 CPU的内部电路是函数的黑盒实现 信号通过输出管脚输出，对应着函数的出参 8086 CPU 大家有没有思考过现代计算机为什么是基于二进制的🤔？事实上，在计算机的发展历程中确实出现过其他进制的计算机，例如10进制，3进制（现在计算机也是一步步演化过来了，其某些核心设计思想甚至来源于织布机，有兴趣的同学可以翻翻计算机发展史，有助于加深对计算机原理的理解）。我认为现代计算机基于二进制的原因主要有两个：一方面是基于二进制，在物理实现上会更加容易，例如电路设计更加简单，0和1的表示也更加稳定（高低电平）；另一方面，既然CPU是函数的实现，那么就需要有完备的数学理论做支撑，其中布尔代数正好完美契合了现代计算机只能执行非常简单的算数逻辑运算集但却能够以超高速方式运行的特点。英国数学家布尔在1854年创立了布尔代数学科，布尔代数本身十分简单，但却为百年之后出现的二进制计算机提供了重要的数学方法和理论基础。 布尔函数 布尔函数：布尔函数处理布尔数值(它的输入输出都是二进制数值)。布尔函数在数字计算机的芯片设计中扮演基础角色，也在密码学中扮演关键角色。 布尔函数的两种表示方法： 1.真值表：枚举出函数所有输入变量的组合，然后写出每一种组合对应的函数输出值。 真值表 2.布尔表达式：使用布尔操作符（And，Or，Not等）表达，上面的真值表可以用此表达式表示： f(x, y, z) = (x And y) Or (Not(x) And z) 布尔函数和门 门（gate）是用来实现布尔函数的物理设备，例如与门，或门，非门，与非门等。门是基本的电子元器件，复杂的门电路就构成了CPU 门有输入管脚和输出管脚，对应着布尔函数的入参和出参；门电路的具体实现方式则对应着布尔函数的运算规则。复杂的布尔函数就对应的复杂的门电路 布尔函数是门电路的数学表达，门电路是布尔函数的物理实现。一个复杂的CPU物理实现对应着一个复杂的布尔函数设计，可以说CPU的实现是建立在布尔函数之上的。 用与非门实现CPU的数理基础 布尔函数的一些数学结论： 任何一个布尔函数，无论多复杂，都可以只用三种布尔操作符And，Or，Not完全表达。 And，Or，Not运算都可以只用Nand（与非）一种运算来代替实现，或者只用Nor（或非）一种运算来代替实现。 由1、2可得：仅使用Nand运算，就能够构建任何布尔函数。 以上证明方法可以自行Google 有了上面的数理基础做支撑，我们可以得出结论：一旦我们在物理上实现了Nand（与非门），我们就能够实现任何门电路，进而实现一个CPU。 用软件实现硬件 今天，硬件设计者们也不再亲手制作硬件了，而是用软件来实现设计：通过编写硬件描述语言（HDL）来描述芯片结构，并能通过测试用例来验证设计。 好了，下面就让我们用Nand来实现一个CPU吧~</summary></entry><entry><title type="html">从0到1构建计算机(1/10)–从与非门到俄罗斯方块</title><link href="http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html" rel="alternate" type="text/html" title="从0到1构建计算机(1/10)--从与非门到俄罗斯方块" /><published>2019-10-16T00:00:00+08:00</published><updated>2019-10-16T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97</id><content type="html" xml:base="http://localhost:4000/2019/10/16/%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html">&lt;p&gt;&lt;img src=&quot;/post_image/nand_start/adam_god_nand.png&quot; alt=&quot;adam_god_nand&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mark!!! 开始学习课程：&lt;a href=&quot;https://www.nand2tetris.org/&quot;&gt;From Nand To Tetris&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本课程将从0到1地构建一个计算机，自底向上地一步步实现各种基本逻辑门、ALU、寄存器、RAM、CPU；定义机器语言、汇编语言，实现汇编器；定义高级语言，实现编译器；实现一套最简单的操作系统；最后编写一个小游戏并把它运行在这个完全由自己构建的计算机之上。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc0kvqha75j31140mcgn0.jpg&quot; width=&quot;800&quot; /&gt;&lt;/center&gt;

&lt;p&gt;现代计算机是非常复杂的，复杂性之一就在于计算机一层层的封装架构（同时工业级的计算机每一层的实现也是非常复杂的），封装导致我们往往只能够看到冰山一角，至于水面下的实现原理，特色社会主义下的程序员在996的工作制之下，往往只能靠推测理解，或者通过学习一些零散的技术资料来形成一个不太完整，甚至理解有一些偏差的知识体系（我经常会陷入对某个知识点的理解是不是正确的无限自我怀疑之中）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0mo58x1fj30nq0w6467.jpg&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;

&lt;p&gt;我们把将要构建的这个计算机命名为Hack，Hack是一个麻雀虽小，但五脏俱全的冯·诺依曼架构的现代计算机。Hack极其精简，它只保留了计算机最基本的功能，一方面降低了我们的实现成本，更重要的是它把我们从计算机科学中众多复杂的实现细节中解脱出来，瞄准计算机工作的原理和本质。我们在构建Hack的同时，也加深了自己对计算机理解的准确性和系统性。&lt;/p&gt;

&lt;p&gt;还有一篇类似课程：&lt;a href=&quot;https://www.youtube.com/watch?v=WqrNphu6HaU&amp;amp;list=PLdYq_l3Bzf1elCyzIfx2JgHfSMTsWbnfg&amp;amp;index=1&quot;&gt;计算机科学速成课&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;😀😀😀&lt;/p&gt;</content><author><name>Your Name</name></author><category term="计算机基础" /><category term="从0到1构建计算机" /><summary type="html">Mark!!! 开始学习课程：From Nand To Tetris 本课程将从0到1地构建一个计算机，自底向上地一步步实现各种基本逻辑门、ALU、寄存器、RAM、CPU；定义机器语言、汇编语言，实现汇编器；定义高级语言，实现编译器；实现一套最简单的操作系统；最后编写一个小游戏并把它运行在这个完全由自己构建的计算机之上。 现代计算机是非常复杂的，复杂性之一就在于计算机一层层的封装架构（同时工业级的计算机每一层的实现也是非常复杂的），封装导致我们往往只能够看到冰山一角，至于水面下的实现原理，特色社会主义下的程序员在996的工作制之下，往往只能靠推测理解，或者通过学习一些零散的技术资料来形成一个不太完整，甚至理解有一些偏差的知识体系（我经常会陷入对某个知识点的理解是不是正确的无限自我怀疑之中）。 我们把将要构建的这个计算机命名为Hack，Hack是一个麻雀虽小，但五脏俱全的冯·诺依曼架构的现代计算机。Hack极其精简，它只保留了计算机最基本的功能，一方面降低了我们的实现成本，更重要的是它把我们从计算机科学中众多复杂的实现细节中解脱出来，瞄准计算机工作的原理和本质。我们在构建Hack的同时，也加深了自己对计算机理解的准确性和系统性。 还有一篇类似课程：计算机科学速成课 😀😀😀</summary></entry></feed>