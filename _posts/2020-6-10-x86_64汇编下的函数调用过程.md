---
title: x86_64汇编下的函数调用过程
tags: 计算机基础 汇编语言
---


### 材料准备

首先手写一个简单的C程序：main.c

```c
#include <stdio.h>

void empty();
int  add(int i, int j);
void myPrint(int num);
void testParams(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k);

int main()
{
	// 测试空函数
	empty();

	// 测试传2个参数的函数
	int i = 3;
	int j = 4;
	int k = add(i, j);

	// 测试传多个参数的函数
	testParams(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);

	// 测试print函数（不定参数）
	myPrint(k);
	
	return 0;
}

void empty()
{
	return;
}

int add(int i, int j)
{
	int k = i + j;
	return k;
}

void myPrint(int num)
{
	printf("%s %s %s: %d\n", "hello", "world", "print", num);
}

void testParams(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k)
{
	return;
}
```

然后执行 clang main.c，默认生成 a.out 文件。查看 a.out，可以看到 a.out 是一个 x86_64 架构下的 Mach-O 格式的文件。

```
➜  函数调用过程 git:(master) ✗ clang main.c
➜  函数调用过程 git:(master) ✗ ls
a.out  main.c
➜  函数调用过程 git:(master) ✗ file a.out 
a.out: Mach-O 64-bit executable x86_64
➜  函数调用过程 git:(master) ✗ 
```

### 查看Mach-O

我们使用工具来分析Mach-O文件：[MachOView](https://github.com/gdbinit/MachOView)

展开段：__TEXT_text，我们可以看到 main.c 中我们自定义的函数的以汇编指令的形式顺序的排列在这里。
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfubijrys3j30u01rc4c2.jpg" width="800">

### 函数调用过程

分析函数调用过程，其实就是分析程序执行过程中**指令的跳转和栈内存区域的变化**

在函数调用过程中有2个非常重要的指针寄存器：**bp 和 sp**
1. bp始终指向当前最顶部的栈帧的栈底
2. sp指向当前最顶部的栈帧的栈顶（原则上是需要指向栈顶，但由于代码优化的原因，并不是总是）

<center><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfucqsz6rpj30hq0q20tk.jpg" width="300"></center>

### 空函数的调用

接着让我们用debug的方式来看下 x86_64 下函数的调用过程。首先程序会先进入 main 函数，然后调用 empty 函数，empty 函数非常简单，什么都不做就退出了。

```
1 // 调用 lldb 开始调试 a.out
➜  函数调用过程 git:(master) ✗ lldb a.out 
(lldb) target create "a.out"
Current executable set to 'a.out' (x86_64).

2 // 设置断点到 main
(lldb) breakpoint set --name main 
Breakpoint 1: where = a.out`main, address = 0x0000000100000e20

3 // run 程序
(lldb) run
Process 42767 launched: '/Users/guosai/practice_C/函数调用过程/a.out' (x86_64)
Process 42767 stopped

* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100000e20 a.out`main
a.out`main:
->  0x100000e20 <+0>: pushq  %rbp
    0x100000e21 <+1>: movq   %rsp, %rbp
    0x100000e24 <+4>: subq   $0x40, %rsp
    0x100000e28 <+8>: movl   $0x0, -0x4(%rbp)
Target 0: (a.out) stopped.
(lldb) 
```

可以看到，程序停留在了 main 函数的第一条指令 pushq    %rbp。然后我们再来分析看下 main 函数和 empty 函数的汇编代码（用 disassemble --name 命令）

```
a.out`main:
->  0x100000e20 <+0>:   pushq  %rbp
    0x100000e21 <+1>:   movq   %rsp, %rbp
    0x100000e24 <+4>:   subq   $0x40, %rsp
    0x100000e28 <+8>:   movl   $0x0, -0x4(%rbp)
    0x100000e2f <+15>:  callq  0x100000f60               ; empty
    0x100000e34 <+20>:  movl   $0x3, -0x8(%rbp)
    0x100000e3b <+27>:  movl   $0x4, -0xc(%rbp)
    0x100000e42 <+34>:  movl   -0x8(%rbp), %edi
    0x100000e45 <+37>:  movl   -0xc(%rbp), %esi
    0x100000e48 <+40>:  callq  0x100000eb0               ; add
    0x100000e4d <+45>:  movl   %eax, -0x10(%rbp)
    0x100000e50 <+48>:  movl   $0x1, %edi
    0x100000e55 <+53>:  movl   $0x2, %esi
    0x100000e5a <+58>:  movl   $0x3, %edx
    0x100000e5f <+63>:  movl   $0x4, %ecx
    0x100000e64 <+68>:  movl   $0x5, %r8d
    0x100000e6a <+74>:  movl   $0x6, %r9d
    0x100000e70 <+80>:  movl   $0x7, (%rsp)
    0x100000e77 <+87>:  movl   $0x8, 0x8(%rsp)
    0x100000e7f <+95>:  movl   $0x9, 0x10(%rsp)
    0x100000e87 <+103>: movl   $0xa, 0x18(%rsp)
    0x100000e8f <+111>: movl   $0xb, 0x20(%rsp)
    0x100000e97 <+119>: callq  0x100000ed0               ; testParams
    0x100000e9c <+124>: movl   -0x10(%rbp), %edi
    0x100000e9f <+127>: callq  0x100000f20               ; myPrint
    0x100000ea4 <+132>: xorl   %eax, %eax
    0x100000ea6 <+134>: addq   $0x40, %rsp
    0x100000eaa <+138>: popq   %rbp
    0x100000eab <+139>: retq   
    0x100000eac <+140>: nopl   (%rax)
```

```
a.out`empty:
    0x100000f60 <+0>: pushq  %rbp
    0x100000f61 <+1>: movq   %rsp, %rbp
    0x100000f64 <+4>: popq   %rbp
    0x100000f65 <+5>: retq   
```

要分析一个空函数的调用过程，主要是分析一下几个指令（或指令组合）

|  指令（指令组合）   | 作用  |
|  ----  | ----  |
|  callq  数值                      | 跳转到某函数 |
|  pushq  %rbp 和 movq   %rsp, %rbp | 暂存bp指针，并开辟新的栈帧 |
|  popq   %rbp 和 popq   %rbp       | 函数结束，返回上一级函数 |

#### callq

callq 就是 call 指令（q代表要处理的字节长度，q是8字节，l是4字节，w是2字节）。call 指令指示 CPU 应跳转到某个地址去执行新的函数。

现在我们执行4次step指令，让 CPU 停留在第五条指令上：callq  0x100000f60（去跳转 empty 函数），在分析这条指令之前，我们先来看下 CPU 中各寄存器的状态（register read 命令）
```
a.out`main:
    0x100000e20 <+0>:   pushq  %rbp
    0x100000e21 <+1>:   movq   %rsp, %rbp
    0x100000e24 <+4>:   subq   $0x40, %rsp
    0x100000e28 <+8>:   movl   $0x0, -0x4(%rbp)
->  0x100000e2f <+15>:  callq  0x100000f60               ; empty
    0x100000e34 <+20>:  movl   $0x3, -0x8(%rbp)
    0x100000e3b <+27>:  movl   $0x4, -0xc(%rbp)
    ............

General Purpose Registers:
       rax = 0x0000000100000e20  a.out`main
       rbx = 0x0000000000000000
       rcx = 0x00007ffeefbff5a8
       rdx = 0x00007ffeefbff3a8
       rdi = 0x0000000000000001
       rsi = 0x00007ffeefbff398
       rbp = 0x00007ffeefbff370
       rsp = 0x00007ffeefbff330
        r8 = 0x0000000000000000
        r9 = 0x0000000000000000
       r10 = 0x0000000000000000
       r11 = 0x0000000000000000
       r12 = 0x0000000000000000
       r13 = 0x0000000000000000
       r14 = 0x0000000000000000
       r15 = 0x0000000000000000
       rip = 0x0000000100000e2f  a.out`main + 15
    rflags = 0x0000000000000206
        cs = 0x000000000000002b
        fs = 0x0000000000000000
        gs = 0x0000000000000000
```

<center><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfudzgrh42j31jq0i874t.jpg" width="800"></center>

可以看到此时：
* rbp = 0x00007ffeefbff370，main栈帧的栈底的地址就是 0x00007ffeefbff370
* rsp = 0x00007ffeefbff330，main栈帧的栈顶的地址就是 0x00007ffeefbff330（因为栈是向下生长的，所以sp小于dp）

由此可以算出 main 的栈帧占的内存空间大小是 0x40 ，正好符合第三条指令：subq   $0x40, %rsp

* rip 指向当前等待执行的指令的地址，此时 rip = 0x0000000100000e2f，正好是（0x100000e2f <+15>:  callq  0x100000f60）

那么 callq  0x100000f60 指令做了什么呢？我们首先抛出结论：
1. 首先 call 指令把当前指令的下一条指令 push 入栈（先把这条指令的地址暂存下来，等后面被调用函数返回的时候才能找到它，并继续执行）
2. 找到下一条需要执行的指令的地址（即 empty 的地址），并跳转执行。

首先我们来验证第2点，当前的跳转指令是：callq  0x100000f60，empty 的第一条指令的地址也是 0x100000f60（0x100000f60 <+0>: pushq  %rbp）。这里 0x100000f60 是 lldb帮我们计算出来的值，算法是：目的值 = 偏移值+下一条指令的地址，这个逻辑就是地址无关代码（position independent code）

然后我们验证第一点，先看一下当前内存中栈顶附近（rsp = 0x00007ffeefbff330）存储的数值（memory read 指令）
```
memory read --size 4 --format x --count 16 0x00007ffeefbff310

0x7ffeefbff310: 0x00000000 0x00000000 0xefbff398 0x00007ffe
0x7ffeefbff320: 0xefbff380 0x00007ffe (0x00000000 0x00000001)
0x7ffeefbff330: 0x00000001 0x0000000e 0x00000000 0x00000000
0x7ffeefbff340: 0x00000000 0x00000000 0x00000000 0x00000000
(lldb) 
```
上面的(0x00000000 0x00000001)表示0x7ffeefbff328地址存的现在存的值是 0000000100000000(小端模式)，后面在会被覆盖成函数返回地址 0x100000e34。

然后执行 step。再次观察寄存器和内存数值的变化：
```
memory read --size 4 --format x --count 16 0x00007ffeefbff310
0x7ffeefbff310: 0x00000000 0x00000000 0xefbff398 0x00007ffe
0x7ffeefbff320: 0xefbff380 0x00007ffe (0x00000e34 0x00000001)
0x7ffeefbff330: 0x00000001 0x0000000e 0x00000000 0x00000000
0x7ffeefbff340: 0x00000000 0x00000000 0x00000000 0x00000000

(lldb) register read
General Purpose Registers:
       rax = 0x0000000100000e20  a.out`main
       rbx = 0x0000000000000000
       rcx = 0x00007ffeefbff5a8
       rdx = 0x00007ffeefbff3a8
       rdi = 0x0000000000000001
       rsi = 0x00007ffeefbff398
       rbp = 0x00007ffeefbff370
       rsp = 0x00007ffeefbff328
        r8 = 0x0000000000000000
        r9 = 0x0000000000000000
       r10 = 0x0000000000000000
       r11 = 0x0000000000000000
       r12 = 0x0000000000000000
       r13 = 0x0000000000000000
       r14 = 0x0000000000000000
       r15 = 0x0000000000000000
       rip = 0x0000000100000f60  a.out`empty
    rflags = 0x0000000000000206
        cs = 0x000000000000002b
        fs = 0x0000000000000000
        gs = 0x0000000000000000
```

可以看到有三个地方变化了
1. 0x7ffeefbff328 地址内存的值有(0x00000000 0x00000001)变成了(0x00000e34 0x00000001，即小端模式下的 0000000100000e34)，正好是 callq  0x100000f60 的下一条指令的地址 0x100000e34。
2. 因为有新的值入栈了，所以rsp的值也需要更新到新的栈顶，即 0x00007ffeefbff330 - 8 = 0x00007ffeefbff328（push入栈的指针占8个字节）
3. rip指向了新的指令地址：empty函数的第一条指令：rip = 0x0000000100000f60  a.out`empty

执行完call指令后，执行逻辑就从main跳出来，去执行empty了。

<center><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfufv8slmmj31dg0u0jsc.jpg" width="800"></center>








