---
layout:     post
title:      OS内核(xv6)探究-系统调用
date:       2021-5-21
author:     "guosai"
tags:
    - 计算机基础
    - 操作系统
    - OS内核
---

### 内核态和用户态

计算机在加载操作系统之后，再继续执行任何指令的时候，都会处在某种特权级下（privilege）。例如在Linux下，可能会有ring0，ring1，ring2，ring3等几种状态，这些状态可以简单的**分成用户态和内核态两种**。我们写的上层应用的代码大多数情况运行在用户态，当我们的程序需要执行一些特殊的任务的时候，例如：访问文件，发起网络请求，向屏幕输出文字，fork一个子进程等等，**我们的用户态程序是不具备这些权限的，只能把这些任务委托给操作系统**（通过系统调用），因为只有运行在内核态的操作系统才有权限做这些事情。

为什么要区分用户态和内核态呢？最重要的原因还是要**对计算机进行保护**。内核态的代码往往要操作文件，网络，屏幕，外设，还有一些非常关键的指令，如设置中断向量表、全局描述符表等，这些资源和操作都是高度重要的，如果操作不当就会导致计算机完全崩溃、宕机，所以必须保证执行这些操作的代码是最可靠的代码。上层应用代码往往是不太可靠的，或因为程序bug，甚至可能有恶意程序，所以操作系统觉不能把这些操作交给用户程序去执行。这就像在我们家中电源、电器、刀具等器件只能由大人来使用，不能让小孩子使用，并且要尽量锁起来或者放在小孩子够不到的地方来加以保护。

一般用用户态陷入内核态的方式有三种：
1. 中断：例如时钟中断，外设中断
2. 异常：例如CPU除零操作，段错误
3. 系统调用：上层应用通过指令主动调起，例如int80,int3

<center><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrkgv0w5qj315t0u0tks.jpg" width="500"></center>

### 什么是系统调用

了解了用户态和内核态我们也就基本理解了系统调用。**系统调用就是操作系统为用户程序提供的一系列API接口**，来帮助用户程序完成一些操作。这些API接口基本都封装在标准库中，例如C语言的libc库，C语言中常见的系统调用例如：open(打开文件)，print，fork，getpid等等。从用户程序的角度来看，系统调用是用户程序和操作系统的唯一接口，用户程序只能通过系统调用感知操作系统的存在。其他的操作系统功能，例如进程切换，页机制等机制对于用户程序来说则是完全透明。

系统调用一方面保护了计算机，另一方面也**帮助用户程序封装了底层功能的实现**，这些实现往往都是非常复杂的，系统调用帮助用户程序提高了开发效率。

同时如果能提供一套标准的系统调用API接口就可能大大增强上层应用软件的可移植性，比较常见的标准就是POSIX标准。

<center><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrlrjny6kj30re09yaa5.jpg" width="500"></center>

### 系统调用和过程调用的区别

主要区别：
1. 执行的指令：系统调用是从用户程序代码跳转到操作系统代码（内核地址空间）；过程调用是用户程序在执行过程中跳转到自己的代码或者动态库的代码（用户地址空间）。
2. 特权级的改变：系统调用要从用户态切换到内核态；过程调用不用切换，全部在用户态完成。
   3. 函数栈：系统调用发生时，要从用户栈切换到内核栈；过程调用不切换，在当前栈完成。
4. 传参：系统调用基本使用寄存器传参；过程调用使用栈或者寄存器传参。

一个典型的系统调用过程大概如下：用户程序->调用标准库->切换到内核态->通过系统调用号跳转到对应的系统调用实现->系统调用执行完成->结果返回给用户程序并切换回用户态。

一个典型的过程调用的过程可以参考之前的博客：[x86_64汇编下的函数调用过程](https://guosainpu.github.io/2020/06/10/x86_64%E6%B1%87%E7%BC%96%E4%B8%8B%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/)

### xv6系统调用的过程分析

