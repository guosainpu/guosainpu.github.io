---
title: 从0到1构建计算机(10/10)--简单的操作系统
tags: 计算机基础 从0到1构建计算机
---
上一篇我们完成了Jack的编译器，这就意味着我们可以随心所欲地在Hack上编写Jack程序了。但是以Jack目前的能力，即使是想完成一些简单的操作也要编写非常复杂的代码，例如我们想要在屏幕上输出“Hello Workd!”，就必须在屏幕上特定位置画上几百个像素点。所以我们需要实现一个简单的操作系统来让事情变得更简单一些。

操作系统就是用来衔接计算机的硬件系统和软件系统的，以使得计算机对程序员和用户而言更容易使用。本篇的操作系统包含了一个最小规模的操作系统（其实就是一个Jack标准库的集合），主要包括：数学运算、字符串操作、内存管理、文本和图形输出到屏幕、键盘输入处理等功能，不包括：进程管理、磁盘管理、通信等功能。

### 数学操作

目前Hack在硬件上只支持加法和减法，因此我们需要在软件层面完善Hack的数学操作，包括：乘法、除法、绝对值、最大值、最小值、开平方操作。

**效率第一**，在加减法的基础上实现这些数学操作的方式可能有很多，在这里我们最应该关注的是执行的效率，因为数学操作是计算机工作时最常做的基本操作之一，最大程度的优化数学操作是优化计算机性能的重要主题。例如CPU会专门为浮点数设计浮点数计算单元，更擅长数学运算的GPU也被设计出来用于辅助计算机的数学运算。

#### 乘法

对于乘法 sum=x\*y，最简单的方法是把 sum=sum+x 重复运算 y 次，算法的时间复杂度为 O(n)。另一种方式是模拟小学运算乘法的竖式方式：用 shiftedx 去乘 y 的每一位，如果 y 的这位为1，则把结果加到 sum 中，如果为0则舍弃；处理完 y 的当前位后，处理 y 的下一位，此时需要操作 shiftedx=shiftedx\*2（此操作可以通过加法实现，或者通过移位实现，移位效率更高，虽然Hack不支持移位操作）。第二种方式效率更高，算法的时间复杂度为 O(log2(n))。

<center><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcq3caoxlhj30ra09mq2w.jpg" width="500"></center>
<center><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcq2u7z2gtj31220bijrp.jpg" width="600"></center>

实现：
```java
static int powers_of_two;

function void init() {
    let powers_of_two = Array.new(16);
    let powers_of_two[0] = 1;
    let powers_of_two[1] = 2;
    let powers_of_two[2] = 4;
    let powers_of_two[3] = 8;
    let powers_of_two[4] = 16;
    let powers_of_two[5] = 32;
    let powers_of_two[6] = 64;
    let powers_of_two[7] = 128;
    let powers_of_two[8] = 256;
    let powers_of_two[9] = 512;
    let powers_of_two[10] = 1024;
    let powers_of_two[11] = 2048;
    let powers_of_two[12] = 4096;
    let powers_of_two[13] = 8192;
    let powers_of_two[14] = 16384;
    let powers_of_two[15] = 16384+16384;
    return;
}

// 判断x的第n位是否为1
function boolean bit(int x, int n) {
    return ~((x & powers_of_two[n]) = 0);
}

function int multiply(int x, int y) {
    var int sum, shiftedX;
    var int j;
    
    let sum = 0;
    let shiftedX = x;
    let j = 0;
    while( j < 16 ) {   // 16-bit numbers
        if(Math.bit(y, j)) {
            let sum = sum + shiftedX;
        }
        let shiftedX = shiftedX + shiftedX;
        let j = j + 1;
    }
    return sum;
}
```

#### 除法

对于除法 d=x/y，容易想到的方法是重复计算 x=x-y，每计算一次后 d=d+1，直至 x-y<0 为止。在这种情况下，最坏的情况是 y=1 的情况，此时的步长最短，需要重复计算x次，时间复杂度为 O(x)。我们可以进一步优化，增加步长，每次不是减去y，而是减去2y，而且是递归的进行下去，直至 x<y 时返回，此时最坏的时间复杂度为 O(log2(n))。

<center><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcq7h7f8ezj311m0bk3yt.jpg" width="600"></center>

```java
function int divide(int x, int y) {
    var int neg_x, neg_y;
    var int q;
    var int result;
    
    let neg_x = x < 0;
    let neg_y = y < 0;
    let x = Math.abs(x);
    let y = Math.abs(y);

    if( y > x ) {
        return 0;
    }
    let q = Math.divide(x, y+y);
    if( x-(2*q*y) < y ) {
        let result = q+q;
    }
    else {
        let result = q+q+1;
    }
    
    if( neg_x = neg_y ) {
        return result;
    }
    else {
        return -result;
    }
}
```

#### 开平方

这个开平方函数返回入参 x 开平方后结果的整数部分。算法可以使用二分查找的方式，找到 $y^2\leq x<(y+1)^2$ 即可。该算法的时间复杂度为O(log2(n))，但由于我们计算的 x 大小有上限（$2^{16}-1$），所以真实执行时循环的次数是固定的 n/2 (n=16)，复杂度是O(n/2)。

```java
伪代码：
y = 0
for j = n/2 - 1 ... 1, 0 do
    if (y+2^j)^2 < x then y = 2^j
return y

function int sqrt(int x) {
    var int j, y;
    var int approx;
    var int approx_squared;
    
    let y = 0;
    let j = 7;      // = #bits / 2 - 1
    while( ~(j < 0) ) {
        let approx = y + powers_of_two[j];
        let approx_squared = approx * approx;
        if( ~(approx_squared > x) & (approx_squared > 0) ) {    // in case of overflow
            let y = approx;
        }
        let j = j - 1;
    }
    return y;
}
```

#### 绝对值、最大值、最小值、取模

这些运算就比较简单了

```java
function int max(int a, int b) {
    if( a > b ) {
        return a;
    }
    else {
        return b;
    }
}

function int min(int a, int b) {
    if( a < b ) {
        return a;
    }
    else {
        return b;
    }
}

function int abs(int x) {
    if( x < 0 ) {
        let x = -x;
    }
    return x;
}

function int mod(int x, int y) {
    var int q;
    
    let q = Math.divide(x, y);
    return x - (q*y);
}
```

### 字符串

字符串的逻辑比较简单。在Jack中，一个字符串是一个数组，存储内容一串ascii编码（且不需要以\0结尾）。我们用String类来实现，其中最核心的两个方法是构造函数 new(int length) 和 appendChar(char c)，这里我们只支持一个一个地追加字符，不支持直接传入一个字符串😂。附上[ascii编码表：](https://zh.wikipedia.org/wiki/ASCII)

```java
class String {
    field Array buffer;
    field int buffer_len;
    field int str_len;
    
    constructor String new(int maxLength) {
        if( maxLength = 0 ) {
            let maxLength = 1;
        }
        let buffer = Array.new(maxLength);
        let buffer_len = maxLength;
        let str_len = 0;
        return this;
    }

    method void dispose() {
        do Array.dispose(buffer);
        return;
    }

    method int length() {
        return str_len;
    }

    method char charAt(int j) {
        return buffer[j];
    }

    method void setCharAt(int j, char c) {
        let buffer[j] = c;
        return;
    }

     *  Returns this string as the return value. */
    method String appendChar(char c) {
        if( str_len < buffer_len ) {
            let buffer[str_len] = c;
            let str_len = str_len + 1;
        }
        return this;
    }

    method void eraseLastChar() {
        if( str_len > 0 ) {
            let str_len = str_len - 1;
        }
        return;
    }

    /** 返回字符串代表的整数值 */
    method int intValue() {
        var int int_val;
        var int i;
        var boolean neg;
        
        let int_val = 0;
        
        if( (str_len > 0) & (buffer[0] = 45) ) {      // '-'
            let neg = true;
            let i = 1;
        }
        else {
            let neg = false;
            let i = 0;
        }
        
        while( (i < str_len) & String.is_digit(buffer[i]) ) {
            let int_val = (int_val * 10) + String.digit_val(buffer[i]);
            let i = i + 1;
        }
        
        if( neg ) {
            return -int_val;
        }
        else {
            return int_val;
        }
    }
    
    function boolean is_digit(char c) {
        return ~(c < 48) & ~(c > 57);
    }
    
    function int digit_val(char c) {
        return c - 48;
    }
    
    function char digit_char(int i) {
        return i + 48;
    }

    /** 以字符串的形式保存整数 */
    method void setInt(int number) {
        let str_len = 0;    // Clear string
        
        if( number < 0 ) {
            let number = -number;
            do appendChar(45);      // leading '-'
        }
        
        do do_set_int(number);
        return;
    }

    method void do_set_int(int number) {
        var int q;
        var int mod;
        var char c;
        
        let q = number / 10;
        let mod = number - (q*10);
        let c = String.digit_char(mod);
        
        if( number < 10 ) {
            do appendChar(c);
        }
        else {
            do do_set_int(q);
            do appendChar(c);
        }
        return;
    }
    
    function char newLine() {
        return 128;
    }

    function char backSpace() {
        return 129;
    }

    /** 双引号 */
    function char doubleQuote() {
        return 34;
    }
}
```
