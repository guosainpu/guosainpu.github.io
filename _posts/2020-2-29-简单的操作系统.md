---
title: 从0到1构建计算机(10/10)--简单的操作系统
tags: 计算机基础 从0到1构建计算机
---
上一篇我们完成了Jack的编译器，这就意味着我们可以随心所欲地在Hack上编写Jack程序了。但是以Jack目前的能力，即使是想完成一些简单的操作也要编写非常复杂的代码，例如我们想要在屏幕上输出“Hello Workd!”，就必须在屏幕上特定位置画上几百个像素点。所以我们需要实现一个简单的操作系统来让事情变得更简单一些。

操作系统就是用来衔接计算机的硬件系统和软件系统的，以使得计算机对程序员和用户而言更容易使用。本篇的操作系统包含了一个最小规模的操作系统（其实就是一个Jack标准库的集合），主要包括：数学运算、字符串操作、内存管理、文本和图形输出到屏幕、键盘输入处理等功能，不包括：进程管理、磁盘管理、通信等功能。

### 数学操作

目前Hack在硬件上只支持加法和减法，因此我们需要在软件层面完善Hack的数学操作，包括：乘法、除法、绝对值、最大值、最小值、开平方操作。

**效率第一**，在加减法的基础上实现这些数学操作的方式可能有很多，在这里我们最应该关注的是执行的效率，因为数学操作是计算机工作时最常做的基本操作之一，最大程度的优化数学操作是优化计算机性能的重要主题。例如CPU会专门为浮点数设计浮点数计算单元，更擅长数学运算的GPU也被设计出来用于辅助计算机的数学运算。

#### 乘法

对于乘法 sum=x\*y，最简单的方法是把 sum=sum+x 重复运算 y 次，算法的时间复杂度为 O(n)。另一种方式是模拟小学运算乘法的竖式方式：用 shiftedx 去乘 y 的每一位，如果 y 的这位为1，则把结果加到 sum 中，如果为0则舍弃；处理完 y 的当前位后，处理 y 的下一位，此时需要操作 shiftedx=shiftedx\*2（此操作可以通过加法实现，或者通过移位实现，移位效率更高，虽然Hack不支持移位操作）。第二种方式效率更高，算法的时间复杂度为 O(log2(n))。

<center><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcq3caoxlhj30ra09mq2w.jpg" width="500"></center>
<center><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcq2u7z2gtj31220bijrp.jpg" width="600"></center>

实现：
```java

    static int powers_of_two;
   
    function void init() {
        let powers_of_two = Array.new(16);
        let powers_of_two[0] = 1;
        let powers_of_two[1] = 2;
        let powers_of_two[2] = 4;
        let powers_of_two[3] = 8;
        let powers_of_two[4] = 16;
        let powers_of_two[5] = 32;
        let powers_of_two[6] = 64;
        let powers_of_two[7] = 128;
        let powers_of_two[8] = 256;
        let powers_of_two[9] = 512;
        let powers_of_two[10] = 1024;
        let powers_of_two[11] = 2048;
        let powers_of_two[12] = 4096;
        let powers_of_two[13] = 8192;
        let powers_of_two[14] = 16384;
        let powers_of_two[15] = 16384+16384;
        return;
    }

    // 判断x的第n位是否为1
    function boolean bit(int x, int n) {
        return ~((x & powers_of_two[n]) = 0);
    }

    function int multiply(int x, int y) {
        var int sum, shiftedX;
        var int j;
        
        let sum = 0;
        let shiftedX = x;
        let j = 0;
        while( j < 16 ) {   // 16-bit numbers
            if(Math.bit(y, j)) {
                let sum = sum + shiftedX;
            }
            let shiftedX = shiftedX + shiftedX;
            let j = j + 1;
        }
        return sum;
    }
```

#### 除法

对于除法 d=x/y，容易想到的方法是重复计算 x=x-y，每计算一次后 d=d+1，直至 x-y<0 为止。在这种情况下，最坏的情况是 y=1 的情况，此时的步长最短，需要重复计算x次，时间复杂度为 O(x)。我们可以进一步优化，增加步长，每次不是减去y，而是减去2y，而且是递归的进行下去，直至 x<y 时返回，此时最坏的时间复杂度为 O(log2(n))。

<center><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcq7h7f8ezj311m0bk3yt.jpg" width="600"></center>

```java
    function int divide(int x, int y) {
        var int neg_x, neg_y;
        var int q;
        var int result;
        
        let neg_x = x < 0;
        let neg_y = y < 0;
        let x = Math.abs(x);
        let y = Math.abs(y);

        if( y > x ) {
            return 0;
        }
        let q = Math.divide(x, y+y);
        if( x-(2*q*y) < y ) {
            let result = q+q;
        }
        else {
            let result = q+q+1;
        }
        
        if( neg_x = neg_y ) {
            return result;
        }
        else {
            return -result;
        }
    }
```

#### 开平方

这个开平方函数返回入参 x 开平方后结果的整数部分。算法可以使用二分查找的方式，找到 $y^2\leq x<(y+1)^2$ 即可。该算法的时间复杂度为O(log2(n))，但由于我们计算的 x 大小有上限（$2^{16}-1$），所以真实执行时循环的次数是固定的 n/2 (n=16)，复杂度是O(n/2)。

```java
    伪代码：
    y = 0
    for j = n/2 - 1 ... 1, 0 do
        if (y+2^j)^2 < x then y = 2^j
    return y

    function int sqrt(int x) {
        var int j, y;
        var int approx;
        var int approx_squared;
        
        let y = 0;
        let j = 7;      // = #bits / 2 - 1
        while( ~(j < 0) ) {
            let approx = y + powers_of_two[j];
            let approx_squared = approx * approx;
            if( ~(approx_squared > x) & (approx_squared > 0) ) {    // in case of overflow
                let y = approx;
            }
            let j = j - 1;
        }
        return y;
    }
```

#### 绝对值、最大值、最小值、取模

这些运算就比较简单了

```java
    function int max(int a, int b) {
        if( a > b ) {
            return a;
        }
        else {
            return b;
        }
    }

    function int min(int a, int b) {
        if( a < b ) {
            return a;
        }
        else {
            return b;
        }
    }

    function int abs(int x) {
        if( x < 0 ) {
            let x = -x;
        }
        return x;
    }

    function int mod(int x, int y) {
        var int q;
        
        let q = Math.divide(x, y);
        return x - (q*y);
    }
```

